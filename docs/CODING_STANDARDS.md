# 开发标准 - 强制阅读

> **警告**: 每次写代码或修改代码之前，必须先阅读此文档！

---

## 一、犯过的错误（绝对不能再犯）

### 1. 叠加功能不删旧代码
- **错误**: 新增功能时保留旧代码，导致新旧逻辑冲突
- **正确做法**: 先删除旧逻辑，再写新逻辑，不要同时存在

### 2. 字段命名不统一
- **错误**: 同一概念用多个名字 (`fundingFee`, `accFundingFee`, `fundingIndex`)
- **正确做法**: 一个概念只用一个名字，全局统一

### 3. 定义了函数但不使用
- **错误**: `lockMargin()` 定义了但从未调用
- **正确做法**: 不需要的函数直接删除，需要的函数必须使用

### 4. 定义了字段但不更新
- **错误**: `bankruptcyPrice`, `breakEvenPrice`, `realizedPnL` 从不更新
- **正确做法**: 每个字段必须有明确的更新时机，否则不要定义

### 5. 重复计算
- **错误**: ADL Score 每100ms计算两次
- **正确做法**: 一个计算只在一个地方执行

### 6. 硬编码散落多处
- **错误**: `0.05%` 手续费在3个地方硬编码
- **正确做法**: 所有常量定义在文件顶部，只定义一次

### 7. 余额计算公式错误
- **错误**: `availableBalance` 文档说是 `totalBalance - usedMargin`，但实际计算不是
- **正确做法**: 公式必须和文档一致，实现前先写清楚公式

### 8. 内存数据重启丢失
- **错误**: 余额存内存，重启后丢失
- **正确做法**: 重要数据必须持久化到 Redis/数据库

### 9. 两套ID系统
- **错误**: 仓位用时间戳ID和UUID两套系统
- **正确做法**: 只用一套ID系统

### 10. 链上调用被注释
- **错误**: 清算的链上调用是 TODO，功能不完整
- **正确做法**: 功能要么完整实现，要么不写

---

## 二、统一标准

### 1. 精度标准（全局统一）

| 数据类型 | 精度 | 示例 |
|---------|------|------|
| USD金额 | 1e6 | $100 = 100000000 |
| 代币数量 | 1e18 | 1 token = 1000000000000000000 |
| 价格 | 1e12 | $0.000007 = 7000000 |
| 杠杆 | 1e4 | 75x = 750000 |
| 费率/比率 | 1e4 (基点) | 0.05% = 5, 2% = 200 |

### 2. 字段命名标准

| 概念 | 统一名称 | 禁止使用 |
|------|---------|---------|
| 可用余额 | `availableBalance` | available, balance |
| 已用保证金 | `usedMargin` | lockedMargin, margin |
| 未实现盈亏 | `unrealizedPnL` | upnl, pnl, UPNL |
| 已实现盈亏 | `realizedPnL` | rpnl |
| 累计资金费 | `accumulatedFunding` | fundingFee, accFundingFee |
| 开仓价 | `entryPrice` | avgPrice, openPrice |
| 标记价格 | `markPrice` | currentPrice, price |
| 强平价格 | `liquidationPrice` | liqPrice |
| 仓位大小 | `size` | amount, quantity |

### 3. API 响应格式（统一）

```typescript
// 成功
{
  "success": true,
  "data": { ... }
}

// 失败
{
  "success": false,
  "error": {
    "code": "INSUFFICIENT_BALANCE",
    "message": "余额不足"
  }
}
```

### 4. WebSocket 消息格式（统一）

```typescript
{
  "type": "orderbook" | "trade" | "position" | "balance" | "liquidation",
  "token": "0x...",      // 可选，按代币订阅时
  "trader": "0x...",     // 可选，按用户订阅时
  "timestamp": 1234567890,
  "data": { ... }
}
```

### 5. 订单状态（统一）

```typescript
enum OrderStatus {
  PENDING = 0,           // 待成交
  PARTIALLY_FILLED = 1,  // 部分成交
  FILLED = 2,            // 完全成交
  CANCELLED = 3,         // 已取消
  EXPIRED = 4,           // 已过期
  REJECTED = 5           // 被拒绝
}
```

### 6. 仓位状态（统一）

```typescript
enum PositionStatus {
  OPEN = 0,              // 持仓中
  CLOSED = 1,            // 已平仓
  LIQUIDATED = 2         // 已强平
}
```

---

## 三、系统架构（必须遵守）

### 职责划分

| 模块 | 职责 |
|------|------|
| **链上合约** | 托管资金、确认成交（批量）、记录最终状态 |
| **后端** | 订单撮合、仓位计算、实时推送、资金费结算、强平执行、撤单退款 |
| **前端** | 显示数据、发起请求、渲染推送数据 |

### 核心流程

```
1. 开仓：前端读取派生钱包余额 → 用户签名 → 后端撮合 → 批量上链确认
2. 撮合：后端实时撮合 → 计算成交状态 → 推送给前端
3. 部分成交：已成交部分生成仓位 → 未成交部分继续挂单或用户撤单
4. 撤单：后端计算未成交部分(保证金+手续费) → 退还到派生钱包
5. 强平：后端检测 → 后端执行 → 上链确认（或双重确认）
6. 资金费：后端计算 → 后端结算 → 推送更新
```

### 批量上链策略

```
触发条件（先到先触发）：
- 数量：累计 10,000 笔成交
- 时间：最长 1 小时

目的：节省 gas 费，同时保证透明
```

### 交易授权机制

```
授权流程：
1. 用户首次交易输入交易密码
2. 创建交易会话（加密签名权限）
3. 有效期内免密交易

有效期选项（用户自选）：
- 15分钟
- 2小时
- 24小时

自动失效条件：
- 超过有效期
- 用户主动登出
- 切换设备/IP
- 连续失败3次
```

### 派生钱包安全（红线）

```
生成：
1. 用户设置交易密码
2. 后端生成派生钱包
3. 用 AES-256 + 用户密码 + 盐值 加密私钥
4. 只存储加密数据，明文立即清除

使用：
1. 用户授权（输入密码）
2. 创建加密会话
3. 会话内免密交易

安全保证：
- 私钥绝不明文存储
- 私钥绝不写入日志
- 开发人员无法访问
- 只有用户本人能查看私钥
```

### 余额来源
```
开仓时读取：用户派生钱包余额（链上）
开仓后：资金已扣到合约，后端追踪仓位状态
```

### 2. 保证金计算
```
仓位价值 = size × markPrice / 1e24  (结果1e6精度)
初始保证金 = 仓位价值 × 10000 / leverage
维持保证金 = 仓位价值 × MMR / 10000
```

### 3. 盈亏计算（GMX标准）
```
多头: PnL = size × (markPrice - entryPrice) / entryPrice / 1e18
空头: PnL = size × (entryPrice - markPrice) / entryPrice / 1e18
```

### 4. 强平价格（Bybit标准）
```
多头: liqPrice = entryPrice × (1 - 1/leverage + MMR/10000)
空头: liqPrice = entryPrice × (1 + 1/leverage - MMR/10000)
```

### 5. 保证金率
```
marginRatio = 维持保证金 / (仓位保证金 + 未实现盈亏)
当 marginRatio >= 100% 时触发强平
```

### 6. 下单扣款流程
```
1. 下单时：扣除 (保证金 + 手续费) 从可用余额
2. 成交时：保证金转入仓位占用，手续费收取
3. 撤单时：退还未成交部分的 (保证金 + 手续费)
```

---

## 四、架构原则

### 1. 数据流向
```
用户操作 → API → 验证 → 业务逻辑 → 持久化 → WebSocket推送
```

### 2. 单一职责
- 每个函数只做一件事
- 每个模块只负责一个功能

### 3. 数据持久化（Redis + PostgreSQL）

**Redis（实时数据）：**
```
- 订单簿（当前挂单）
- 当前仓位状态
- 用户会话/授权
- 实时价格
- 撮合队列
```

**PostgreSQL（历史数据）：**
```
- 用户账户信息
- 派生钱包（加密）
- 历史订单
- 历史交易/成交记录
- 结算记录
- 资金费记录
- 强平记录
```

### 4. 推送优先
- 余额变化 → 推送
- 仓位变化 → 推送
- 订单状态变化 → 推送
- 成交通知 → 推送
- 强平预警 → 推送
- 不要让前端轮询

---

## 五、代码风格

### 1. 常量定义在文件顶部
```typescript
// ============================================================
// 常量定义
// ============================================================
const FEE_RATE = 5n;           // 0.05% = 5 基点
const MMR = 200n;              // 2% = 200 基点
const PRECISION_USD = 1000000n; // 1e6
```

### 2. 函数必须有注释说明
```typescript
/**
 * 计算强平价格
 * @param entryPrice 开仓价 (1e12精度)
 * @param leverage 杠杆 (1e4精度)
 * @param isLong 是否多头
 * @returns 强平价格 (1e12精度)
 */
function calculateLiquidationPrice(...) { }
```

### 3. 删除不用的代码
- 不要注释掉代码保留
- 不用就删除

---

## 六、检查清单（每次提交前）

- [ ] 是否删除了旧的冲突代码？
- [ ] 字段命名是否符合统一标准？
- [ ] 公式是否符合行业标准？
- [ ] 数据是否持久化？
- [ ] 状态变化是否推送？
- [ ] 是否有未使用的函数/字段？
- [ ] 常量是否统一定义？
- [ ] 拿不准的地方是否问了用户？

---

## 七、不明白就问

**以下情况必须停下来问用户：**

1. 业务逻辑不确定
2. 公式计算不确定
3. 字段含义不确定
4. 数据流向不确定
5. 多种实现方案不知道选哪个

**问的格式：**
```
我不确定 XXX 应该怎么处理：
方案A: ...
方案B: ...
请确认使用哪个方案？
```

---

*最后更新: 2024-01-28*
*版本: 1.0*
