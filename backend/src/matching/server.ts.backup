/**
 * æ’®åˆå¼•æ“ HTTP API æœåŠ¡å™¨ + WebSocket æ¨é€
 *
 * ä¸ºå‰ç«¯æä¾›ï¼š
 * - REST API: è®¢å•æäº¤ã€è®¢å•ç°¿æŸ¥è¯¢ã€ä»“ä½æŸ¥è¯¢ç­‰
 * - WebSocket: å®æ—¶æ¨é€è®¢å•ç°¿ã€æˆäº¤è®°å½•
 */

import "dotenv/config";
import { type Address, type Hex, verifyTypedData, createPublicClient, http } from "viem";
import { baseSepolia } from "viem/chains";
import { WebSocketServer, WebSocket } from "ws";
import { MatchingEngine, SettlementSubmitter, OrderType, OrderStatus, TimeInForce, type Order, type Match, type Trade, type Kline, type TokenStats } from "./engine";

// ============================================================
// Configuration
// ============================================================

const PORT = parseInt(process.env.PORT || "8081");
const RPC_URL = process.env.RPC_URL || "https://base-sepolia-rpc.publicnode.com";
const MATCHER_PRIVATE_KEY = process.env.MATCHER_PRIVATE_KEY as Hex;
const SETTLEMENT_ADDRESS = process.env.SETTLEMENT_ADDRESS as Address;
const TOKEN_FACTORY_ADDRESS = (process.env.TOKEN_FACTORY_ADDRESS || "0xCfDCD9F8D39411cF855121331B09aef1C88dc056") as Address;
const PRICE_FEED_ADDRESS = (process.env.PRICE_FEED_ADDRESS || "0xd69A4DB60cEc962A46C6B9Bc8CC0883081c4eFb7") as Address;
const BATCH_INTERVAL_MS = parseInt(process.env.BATCH_INTERVAL_MS || "30000"); // 30 seconds
const FUNDING_RATE_INTERVAL_MS = parseInt(process.env.FUNDING_RATE_INTERVAL_MS || "5000"); // 5 seconds
const SPOT_PRICE_SYNC_INTERVAL_MS = parseInt(process.env.SPOT_PRICE_SYNC_INTERVAL_MS || "1000"); // 1 second

// æ”¯æŒçš„ä»£å¸åˆ—è¡¨ï¼ˆåç»­å¯ä»é…ç½®æˆ–é“¾ä¸Šè·å–ï¼‰
const SUPPORTED_TOKENS: Address[] = [
  "0x01c6058175eda34fc8922eeae32bc383cb203211" as Address, // TOKEN_123
];

// ============================================================
// EIP-712 Types for Signature Verification
// ============================================================

const EIP712_DOMAIN = {
  name: "MemePerp",
  version: "1",
  chainId: 84532, // Base Sepolia
  verifyingContract: SETTLEMENT_ADDRESS,
};

const ORDER_TYPES = {
  Order: [
    { name: "trader", type: "address" },
    { name: "token", type: "address" },
    { name: "isLong", type: "bool" },
    { name: "size", type: "uint256" },
    { name: "leverage", type: "uint256" },
    { name: "price", type: "uint256" },
    { name: "deadline", type: "uint256" },
    { name: "nonce", type: "uint256" },
    { name: "orderType", type: "uint8" },
  ],
} as const;

// Settlement åˆçº¦ ABI (ç”¨äºè¯»å–é“¾ä¸Šä»“ä½å’Œç›‘å¬äº‹ä»¶)
const SETTLEMENT_ABI = [
  // ========== View Functions ==========
  {
    inputs: [{ name: "user", type: "address" }],
    name: "getUserPairIds",
    outputs: [{ type: "uint256[]" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ name: "pairId", type: "uint256" }],
    name: "getPairedPosition",
    outputs: [
      {
        components: [
          { name: "pairId", type: "uint256" },
          { name: "longTrader", type: "address" },
          { name: "shortTrader", type: "address" },
          { name: "token", type: "address" },
          { name: "size", type: "uint256" },
          { name: "entryPrice", type: "uint256" },
          { name: "longCollateral", type: "uint256" },
          { name: "shortCollateral", type: "uint256" },
          { name: "longLeverage", type: "uint256" },
          { name: "shortLeverage", type: "uint256" },
          { name: "openTime", type: "uint256" },
          { name: "accFundingLong", type: "int256" },
          { name: "accFundingShort", type: "int256" },
          { name: "status", type: "uint8" },
        ],
        type: "tuple",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "nextPairId",
    outputs: [{ type: "uint256" }],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [{ name: "user", type: "address" }],
    name: "getUserBalance",
    outputs: [
      { name: "available", type: "uint256" },
      { name: "locked", type: "uint256" },
    ],
    stateMutability: "view",
    type: "function",
  },
  // ========== Events (ç”¨äºç›‘å¬é“¾ä¸ŠçŠ¶æ€å˜åŒ–) ==========
  {
    type: "event",
    name: "Deposited",
    inputs: [
      { name: "user", type: "address", indexed: true },
      { name: "amount", type: "uint256", indexed: false },
    ],
  },
  {
    type: "event",
    name: "DepositedFor",
    inputs: [
      { name: "user", type: "address", indexed: true },
      { name: "relayer", type: "address", indexed: true },
      { name: "token", type: "address", indexed: false },
      { name: "amount", type: "uint256", indexed: false },
    ],
  },
  {
    type: "event",
    name: "Withdrawn",
    inputs: [
      { name: "user", type: "address", indexed: true },
      { name: "amount", type: "uint256", indexed: false },
    ],
  },
  {
    type: "event",
    name: "PairOpened",
    inputs: [
      { name: "pairId", type: "uint256", indexed: true },
      { name: "longTrader", type: "address", indexed: true },
      { name: "shortTrader", type: "address", indexed: true },
      { name: "token", type: "address", indexed: false },
      { name: "size", type: "uint256", indexed: false },
      { name: "entryPrice", type: "uint256", indexed: false },
    ],
  },
  {
    type: "event",
    name: "PairClosed",
    inputs: [
      { name: "pairId", type: "uint256", indexed: true },
      { name: "exitPrice", type: "uint256", indexed: false },
      { name: "longPnL", type: "int256", indexed: false },
      { name: "shortPnL", type: "int256", indexed: false },
    ],
  },
  {
    type: "event",
    name: "Liquidated",
    inputs: [
      { name: "pairId", type: "uint256", indexed: true },
      { name: "liquidatedTrader", type: "address", indexed: true },
      { name: "liquidator", type: "address", indexed: true },
      { name: "reward", type: "uint256", indexed: false },
    ],
  },
] as const;

// ============================================================
// State
// ============================================================

const engine = new MatchingEngine();
let submitter: SettlementSubmitter | null = null;

// WebSocket state
let wss: WebSocketServer | null = null;
const wsClients = new Map<WebSocket, Set<Address>>(); // client => subscribed tokens

// User nonces - ä¸å†å†…éƒ¨è¿½è¸ªï¼Œä»é“¾ä¸ŠåŒæ­¥
// æ’®åˆå¼•æ“åªè´Ÿè´£æ’®åˆï¼ŒnonceéªŒè¯ç”±é“¾ä¸Šåˆçº¦å¤„ç†
const userNonces = new Map<Address, bigint>();
const SYNC_NONCE_FROM_CHAIN = true; // å¯ç”¨é“¾ä¸ŠnonceåŒæ­¥

// Submitted pairs tracking
const submittedMatches = new Map<string, Match>();

// Position tracking (from on-chain events, simplified for now)
/**
 * ä»“ä½ä¿¡æ¯ (è¡Œä¸šæ ‡å‡† - å‚è€ƒ OKX/Binance/Bybit)
 *
 * Meme Perp ç‰¹æœ‰å­—æ®µï¼š
 * - bankruptcyPrice: ç©¿ä»“ä»·æ ¼
 * - mmr: åŠ¨æ€ç»´æŒä¿è¯é‡‘ç‡ (meme éœ€è¦æ›´é«˜)
 * - adlScore: ADL è¯„åˆ†ç”¨äºæ’åº
 */
interface Position {
  // === åŸºæœ¬æ ‡è¯† ===
  pairId: string;
  trader: Address;
  token: Address;

  // === ä»“ä½å‚æ•° ===
  isLong: boolean;
  size: string;                   // ä»“ä½å¤§å° (ä»£å¸æ•°é‡, 1e18)
  entryPrice: string;             // å¼€ä»“å‡ä»· (1e12)
  averageEntryPrice: string;      // åŠ ä»“åçš„å¹³å‡ä»·æ ¼ (1e12)
  leverage: string;               // æ æ†å€æ•° (æ•´æ•°)

  // === ä»·æ ¼ä¿¡æ¯ ===
  markPrice: string;              // æ ‡è®°ä»·æ ¼ (å®æ—¶, 1e12)
  liquidationPrice: string;       // å¼ºå¹³ä»·æ ¼ (1e12)
  bankruptcyPrice: string;        // ç©¿ä»“ä»·æ ¼ (1e12) - ä¿è¯é‡‘å½’é›¶çš„ä»·æ ¼
  breakEvenPrice: string;         // ç›ˆäºå¹³è¡¡ä»·æ ¼ (å«æ‰‹ç»­è´¹, 1e12)

  // === ä¿è¯é‡‘ä¿¡æ¯ ===
  collateral: string;             // åˆå§‹ä¿è¯é‡‘ (1e6 USD)
  margin: string;                 // å½“å‰ä¿è¯é‡‘ = åˆå§‹ + UPNL (1e6 USD)
  marginRatio: string;            // ä¿è¯é‡‘ç‡ (åŸºç‚¹, 10000 = 100%)
  mmr: string;                    // ç»´æŒä¿è¯é‡‘ç‡ (åŸºç‚¹, åŠ¨æ€è°ƒæ•´)
  maintenanceMargin: string;      // ç»´æŒä¿è¯é‡‘é‡‘é¢ (1e6 USD)

  // === ç›ˆäºä¿¡æ¯ ===
  unrealizedPnL: string;          // æœªå®ç°ç›ˆäº (1e6 USD)
  realizedPnL: string;            // å·²å®ç°ç›ˆäº (1e6 USD)
  roe: string;                    // æ”¶ç›Šç‡ ROE% (åŸºç‚¹)
  fundingFee: string;             // ç´¯è®¡èµ„é‡‘è´¹ (1e6 USD)

  // === æ­¢ç›ˆæ­¢æŸ ===
  takeProfitPrice: string | null;
  stopLossPrice: string | null;

  // === ç³»ç»Ÿä¿¡æ¯ ===
  counterparty: Address;
  createdAt: number;
  updatedAt: number;

  // === ADL é£é™©æŒ‡æ ‡ (Meme Perp æ ¸å¿ƒ) ===
  adlRanking: number;             // ADL æ’åç­‰çº§ (1-5, 5æœ€å±é™©)
  adlScore: string;               // ADL è¯„åˆ† = (UPNL% / margin) Ã— leverage
  riskLevel: "low" | "medium" | "high" | "critical"; // é£é™©ç­‰çº§
  isLiquidatable: boolean;        // æ˜¯å¦å¯è¢«å¼ºå¹³
  isAdlCandidate: boolean;        // æ˜¯å¦ä¸º ADL å€™é€‰ (ç›ˆåˆ©æ–¹)
}
const userPositions = new Map<Address, Position[]>();

// ============================================================
// ADL è‡ªåŠ¨å‡ä»“ç³»ç»Ÿ (Meme Perp æ ¸å¿ƒ)
// ============================================================

/**
 * ADL é˜Ÿåˆ— - æŒ‰ adlScore æ’åºçš„ç›ˆåˆ©ä»“ä½
 * å½“ç©¿ä»“å‘ç”Ÿæ—¶ï¼Œä»é˜Ÿåˆ—å¤´éƒ¨å¼€å§‹å‡ä»“
 */
interface ADLQueue {
  token: Address;
  longQueue: Position[];   // å¤šå¤´ç›ˆåˆ©é˜Ÿåˆ— (æŒ‰ adlScore é™åº)
  shortQueue: Position[];  // ç©ºå¤´ç›ˆåˆ©é˜Ÿåˆ— (æŒ‰ adlScore é™åº)
}
const adlQueues = new Map<Address, ADLQueue>();

/**
 * å¼ºå¹³é˜Ÿåˆ— - æŒ‰ marginRatio æ’åº
 * ä¼˜å…ˆå¼ºå¹³é«˜é£é™©ä»“ä½
 */
interface LiquidationCandidate {
  position: Position;
  marginRatio: number;     // å½“å‰ä¿è¯é‡‘ç‡ (è¶Šä½è¶Šå±é™©)
  urgency: number;         // ç´§æ€¥ç¨‹åº¦ (0-100)
}
const liquidationQueue: LiquidationCandidate[] = [];

/**
 * è®¡ç®— ADL Score
 * å…¬å¼: ADL Score = (UPNL / Margin) Ã— Leverage
 *
 * ç›ˆåˆ©è¶Šå¤šã€æ æ†è¶Šé«˜ï¼ŒADL é£é™©è¶Šé«˜
 */
function calculateADLScore(position: Position): number {
  const upnl = Number(position.unrealizedPnL);
  const margin = Number(position.collateral);
  const leverage = Number(position.leverage);

  if (margin === 0) return 0;

  // åªæœ‰ç›ˆåˆ©çš„ä»“ä½æ‰æœ‰ ADL é£é™©
  if (upnl <= 0) return 0;

  // ADL Score = (UPNL% / margin) Ã— leverage
  const upnlPercent = upnl / margin;
  const score = upnlPercent * leverage;

  return score;
}

/**
 * è®¡ç®— ADL æ’å (1-5)
 * 1 = æœ€å®‰å…¨, 5 = æœ€å±é™© (æœ€å¯èƒ½è¢« ADL)
 */
function calculateADLRanking(score: number, allScores: number[]): number {
  if (score <= 0) return 1; // äºæŸä»“ä½ä¸ä¼šè¢« ADL

  // æŒ‰åˆ†ä½æ•°åˆ’åˆ†
  const sorted = allScores.filter(s => s > 0).sort((a, b) => a - b);
  if (sorted.length === 0) return 1;

  const percentile = sorted.findIndex(s => s >= score) / sorted.length;

  if (percentile >= 0.8) return 5;      // Top 20% æœ€å±é™©
  if (percentile >= 0.6) return 4;
  if (percentile >= 0.4) return 3;
  if (percentile >= 0.2) return 2;
  return 1;
}

/**
 * æ›´æ–° ADL é˜Ÿåˆ—
 */
function updateADLQueues(): void {
  // æ¸…ç©ºæ—§é˜Ÿåˆ—
  adlQueues.clear();

  // éå†æ‰€æœ‰ä»“ä½ï¼ŒæŒ‰ token åˆ†ç»„
  for (const [trader, positions] of userPositions.entries()) {
    for (const pos of positions) {
      const token = pos.token.toLowerCase() as Address;

      // è·å–æˆ–åˆ›å»ºé˜Ÿåˆ—
      let queue = adlQueues.get(token);
      if (!queue) {
        queue = { token, longQueue: [], shortQueue: [] };
        adlQueues.set(token, queue);
      }

      // åªæœ‰ç›ˆåˆ©çš„ä»“ä½æ‰åŠ å…¥ ADL é˜Ÿåˆ—
      const upnl = Number(pos.unrealizedPnL);
      if (upnl > 0) {
        if (pos.isLong) {
          queue.longQueue.push(pos);
        } else {
          queue.shortQueue.push(pos);
        }
      }
    }
  }

  // æŒ‰ adlScore é™åºæ’åº
  for (const [token, queue] of adlQueues.entries()) {
    queue.longQueue.sort((a, b) => Number(b.adlScore) - Number(a.adlScore));
    queue.shortQueue.sort((a, b) => Number(b.adlScore) - Number(a.adlScore));
  }
}

/**
 * æ‰§è¡Œ ADL å‡ä»“
 * å½“ç©¿ä»“å‘ç”Ÿæ—¶è°ƒç”¨
 *
 * @param bankruptPosition ç©¿ä»“çš„ä»“ä½
 * @param deficit ç©¿ä»“é‡‘é¢ (éœ€è¦ä»å¯¹æ‰‹æ–¹å‡ä»“çš„é‡‘é¢)
 */
async function executeADL(
  bankruptPosition: Position,
  deficit: bigint
): Promise<void> {
  const token = bankruptPosition.token.toLowerCase() as Address;
  const queue = adlQueues.get(token);

  if (!queue) {
    console.error(`[ADL] No queue for token ${token}`);
    return;
  }

  // ç©¿ä»“çš„æ˜¯å¤šå¤´ï¼Œéœ€è¦ä»ç©ºå¤´ç›ˆåˆ©é˜Ÿåˆ—å‡ä»“
  // ç©¿ä»“çš„æ˜¯ç©ºå¤´ï¼Œéœ€è¦ä»å¤šå¤´ç›ˆåˆ©é˜Ÿåˆ—å‡ä»“
  const targetQueue = bankruptPosition.isLong ? queue.shortQueue : queue.longQueue;

  if (targetQueue.length === 0) {
    console.error(`[ADL] No profitable positions to ADL against`);
    // è§¦å‘ä¿é™©åŸºé‡‘
    return;
  }

  let remainingDeficit = deficit;
  const adlTargets: { position: Position; amount: bigint }[] = [];

  // ä»é˜Ÿåˆ—å¤´éƒ¨å¼€å§‹å‡ä»“
  for (const pos of targetQueue) {
    if (remainingDeficit <= 0n) break;

    const positionValue = BigInt(pos.collateral) + BigInt(pos.unrealizedPnL);

    if (positionValue <= 0n) continue;

    // è®¡ç®—éœ€è¦å‡ä»“çš„æ¯”ä¾‹
    const adlAmount = remainingDeficit > positionValue ? positionValue : remainingDeficit;

    adlTargets.push({ position: pos, amount: adlAmount });
    remainingDeficit -= adlAmount;

    console.log(`[ADL] Target: ${pos.trader.slice(0, 10)} ${pos.isLong ? 'LONG' : 'SHORT'} amount=$${Number(adlAmount) / 1e6}`);
  }

  // æ‰§è¡Œ ADL (è°ƒç”¨é“¾ä¸Šåˆçº¦)
  if (submitter && adlTargets.length > 0) {
    const currentPrice = engine.getOrderBook(token).getCurrentPrice();

    for (const { position, amount } of adlTargets) {
      try {
        // éƒ¨åˆ†å¹³ä»“æˆ–å…¨éƒ¨å¹³ä»“
        const adlRatio = Number(amount) / (Number(position.collateral) + Number(position.unrealizedPnL));

        console.log(`[ADL] Executing ADL on pairId ${position.pairId}, ratio=${(adlRatio * 100).toFixed(2)}%`);

        // TODO: è°ƒç”¨é“¾ä¸Š ADL å‡½æ•°
        // await submitter.executeADL(position.pairId, currentPrice, adlRatio);

        // å¹¿æ’­ ADL äº‹ä»¶
        broadcastADLEvent(position, amount, currentPrice);
      } catch (e) {
        console.error(`[ADL] Failed to execute ADL on ${position.pairId}:`, e);
      }
    }
  }
}

/**
 * å¹¿æ’­ ADL äº‹ä»¶åˆ°å‰ç«¯
 */
function broadcastADLEvent(position: Position, amount: bigint, price: bigint): void {
  const message = JSON.stringify({
    type: "adl_triggered",
    pairId: position.pairId,
    trader: position.trader,
    token: position.token,
    isLong: position.isLong,
    adlAmount: amount.toString(),
    price: price.toString(),
    timestamp: Date.now(),
  });

  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  }
}

// ============================================================
// åŠ¨æ€ MMR (ç»´æŒä¿è¯é‡‘ç‡) - Meme Perp æ ¸å¿ƒ
// ============================================================

/**
 * ä»£å¸é£é™©é…ç½®
 */
interface TokenRiskConfig {
  baseMMR: number;           // åŸºç¡€ MMR (åŸºç‚¹)
  volatilityMultiplier: number; // æ³¢åŠ¨ç‡ä¹˜æ•°
  maxMMR: number;            // æœ€å¤§ MMR (åŸºç‚¹)
  minMMR: number;            // æœ€å° MMR (åŸºç‚¹)
  positionTiers: {           // ä»“ä½åˆ†å±‚
    size: bigint;            // ä»“ä½å¤§å°é˜ˆå€¼
    mmrAdd: number;          // é¢å¤– MMR (åŸºç‚¹)
  }[];
}

// é»˜è®¤ Meme Token é£é™©é…ç½® (æ¯” BTC é«˜å¾ˆå¤š)
const DEFAULT_MEME_RISK_CONFIG: TokenRiskConfig = {
  baseMMR: 200,              // 2% åŸºç¡€ MMR (BTC é€šå¸¸æ˜¯ 0.5%)
  volatilityMultiplier: 2,   // æ³¢åŠ¨ç‡æ¯å¢åŠ  1%, MMR å¢åŠ  2bp
  maxMMR: 1000,              // æœ€å¤§ 10%
  minMMR: 100,               // æœ€å° 1%
  positionTiers: [
    { size: 10000n * 10n ** 6n, mmrAdd: 0 },      // < $10k: +0%
    { size: 50000n * 10n ** 6n, mmrAdd: 50 },     // < $50k: +0.5%
    { size: 100000n * 10n ** 6n, mmrAdd: 100 },   // < $100k: +1%
    { size: 500000n * 10n ** 6n, mmrAdd: 200 },   // < $500k: +2%
  ],
};

const tokenRiskConfigs = new Map<Address, TokenRiskConfig>();

// ä»£å¸æ³¢åŠ¨ç‡è¿½è¸ª (5åˆ†é’Ÿæ»šåŠ¨çª—å£)
interface VolatilityTracker {
  prices: { price: bigint; timestamp: number }[];
  volatility: number;        // å½“å‰æ³¢åŠ¨ç‡ (%)
  lastUpdate: number;
}
const volatilityTrackers = new Map<Address, VolatilityTracker>();

/**
 * è®¡ç®—åŠ¨æ€ MMR
 *
 * MMR = baseMMR + (volatility Ã— multiplier) + positionSizeAdj
 */
function calculateDynamicMMR(
  token: Address,
  positionSize: bigint,
  leverage: number
): number {
  const config = tokenRiskConfigs.get(token.toLowerCase() as Address) || DEFAULT_MEME_RISK_CONFIG;
  const tracker = volatilityTrackers.get(token.toLowerCase() as Address);

  // 1. åŸºç¡€ MMR
  let mmr = config.baseMMR;

  // 2. æ³¢åŠ¨ç‡è°ƒæ•´
  if (tracker && tracker.volatility > 0) {
    mmr += Math.floor(tracker.volatility * config.volatilityMultiplier);
  }

  // 3. ä»“ä½å¤§å°è°ƒæ•´ (å¤§ä»“ä½ MMR æ›´é«˜)
  for (const tier of config.positionTiers) {
    if (positionSize >= tier.size) {
      mmr += tier.mmrAdd;
    }
  }

  // 4. æ æ†è°ƒæ•´ (é«˜æ æ† MMR æ›´é«˜)
  if (leverage > 20) {
    mmr += Math.floor((leverage - 20) * 10); // æ¯å¢åŠ  1x æ æ†ï¼ŒMMR å¢åŠ  0.1%
  }

  // 5. é™åˆ¶èŒƒå›´
  mmr = Math.max(config.minMMR, Math.min(config.maxMMR, mmr));

  return mmr;
}

/**
 * æ›´æ–°ä»£å¸æ³¢åŠ¨ç‡
 */
function updateVolatility(token: Address, currentPrice: bigint): void {
  const normalizedToken = token.toLowerCase() as Address;
  let tracker = volatilityTrackers.get(normalizedToken);

  if (!tracker) {
    tracker = { prices: [], volatility: 0, lastUpdate: Date.now() };
    volatilityTrackers.set(normalizedToken, tracker);
  }

  const now = Date.now();

  // æ·»åŠ æ–°ä»·æ ¼
  tracker.prices.push({ price: currentPrice, timestamp: now });

  // ä¿ç•™æœ€è¿‘ 5 åˆ†é’Ÿçš„æ•°æ®
  const fiveMinutesAgo = now - 5 * 60 * 1000;
  tracker.prices = tracker.prices.filter(p => p.timestamp > fiveMinutesAgo);

  // è®¡ç®—æ³¢åŠ¨ç‡ (ä»·æ ¼å˜åŒ–ç™¾åˆ†æ¯”çš„æ ‡å‡†å·®)
  if (tracker.prices.length >= 2) {
    const changes: number[] = [];
    for (let i = 1; i < tracker.prices.length; i++) {
      const prev = Number(tracker.prices[i - 1].price);
      const curr = Number(tracker.prices[i].price);
      if (prev > 0) {
        changes.push(Math.abs((curr - prev) / prev) * 100);
      }
    }

    if (changes.length > 0) {
      const mean = changes.reduce((a, b) => a + b, 0) / changes.length;
      const variance = changes.reduce((a, b) => a + (b - mean) ** 2, 0) / changes.length;
      tracker.volatility = Math.sqrt(variance);
    }
  }

  tracker.lastUpdate = now;
}

// ============================================================
// 100ms Risk Engine - Meme Perp æ ¸å¿ƒ
// ============================================================

let riskEngineInterval: NodeJS.Timeout | null = null;
const RISK_ENGINE_INTERVAL_MS = 100; // 100ms

/**
 * å¯åŠ¨ 100ms Risk Engine
 */
function startRiskEngine(): void {
  if (riskEngineInterval) {
    clearInterval(riskEngineInterval);
  }

  console.log(`[RiskEngine] Starting 100ms risk engine...`);

  riskEngineInterval = setInterval(() => {
    runRiskCheck();
  }, RISK_ENGINE_INTERVAL_MS);
}

/**
 * åœæ­¢ Risk Engine
 */
function stopRiskEngine(): void {
  if (riskEngineInterval) {
    clearInterval(riskEngineInterval);
    riskEngineInterval = null;
  }
}

/**
 * é£é™©æ£€æŸ¥ä¸»å¾ªç¯ (æ¯ 100ms æ‰§è¡Œ)
 */
function runRiskCheck(): void {
  const startTime = Date.now();

  // æ¸…ç©ºå¼ºå¹³é˜Ÿåˆ—
  liquidationQueue.length = 0;

  // æ”¶é›†æ‰€æœ‰ä»“ä½çš„ ADL scores ç”¨äºæ’åè®¡ç®—
  const allScores: number[] = [];

  // éå†æ‰€æœ‰ä»“ä½ï¼Œæ›´æ–°é£é™©æŒ‡æ ‡
  for (const [trader, positions] of userPositions.entries()) {
    for (const pos of positions) {
      const token = pos.token.toLowerCase() as Address;
      const orderBook = engine.getOrderBook(token);
      const currentPrice = orderBook.getCurrentPrice();

      // æ›´æ–°æ ‡è®°ä»·æ ¼
      pos.markPrice = currentPrice.toString();

      // æ›´æ–°æ³¢åŠ¨ç‡
      updateVolatility(token, currentPrice);

      // è®¡ç®— UPNL
      const upnl = calculateUnrealizedPnL(
        BigInt(pos.size),
        BigInt(pos.entryPrice),
        currentPrice,
        pos.isLong
      );
      pos.unrealizedPnL = upnl.toString();

      // è®¡ç®—å½“å‰ä¿è¯é‡‘
      const currentMargin = BigInt(pos.collateral) + upnl;
      pos.margin = currentMargin.toString();

      // è®¡ç®—åŠ¨æ€ MMR
      const leverage = Number(pos.leverage);
      const positionValue = (BigInt(pos.size) * currentPrice) / (10n ** 24n);
      const mmr = calculateDynamicMMR(token, positionValue, leverage);
      pos.mmr = mmr.toString();

      // è®¡ç®—ç»´æŒä¿è¯é‡‘
      const maintenanceMargin = (positionValue * BigInt(mmr)) / 10000n;
      pos.maintenanceMargin = maintenanceMargin.toString();

      // è®¡ç®—ä¿è¯é‡‘ç‡ (åŸºç‚¹)
      const marginRatio = positionValue > 0n
        ? Number((currentMargin * 10000n) / positionValue)
        : 10000;
      pos.marginRatio = marginRatio.toString();

      // è®¡ç®— ROE
      const collateral = BigInt(pos.collateral);
      const roe = collateral > 0n
        ? Number((upnl * 10000n) / collateral)
        : 0;
      pos.roe = roe.toString();

      // è®¡ç®— ADL Score
      const adlScore = calculateADLScore(pos);
      pos.adlScore = adlScore.toString();
      allScores.push(adlScore);

      // åˆ¤æ–­æ˜¯å¦å¯è¢«å¼ºå¹³
      pos.isLiquidatable = marginRatio < mmr;

      // åˆ¤æ–­æ˜¯å¦ä¸º ADL å€™é€‰ (ç›ˆåˆ©æ–¹)
      pos.isAdlCandidate = upnl > 0n;

      // æ›´æ–°é£é™©ç­‰çº§
      if (marginRatio < mmr) {
        pos.riskLevel = "critical";
      } else if (marginRatio < mmr * 1.5) {
        pos.riskLevel = "high";
      } else if (marginRatio < mmr * 2) {
        pos.riskLevel = "medium";
      } else {
        pos.riskLevel = "low";
      }

      // å¦‚æœå¯è¢«å¼ºå¹³ï¼ŒåŠ å…¥å¼ºå¹³é˜Ÿåˆ—
      if (pos.isLiquidatable) {
        const urgency = Math.max(0, Math.min(100, Math.floor((mmr - marginRatio) / mmr * 100)));
        liquidationQueue.push({
          position: pos,
          marginRatio,
          urgency,
        });
      }

      // ============================================================
      // P2: Take Profit / Stop Loss ç›‘æ§
      // ============================================================
      checkTakeProfitStopLoss(pos, currentPrice);

      // ============================================================
      // P2: Trailing Stop ç›‘æ§
      // ============================================================
      updateTrailingStop(pos, currentPrice);

      // ============================================================
      // P3: Conditional Orders ç›‘æ§
      // ============================================================
      checkConditionalOrders(token, currentPrice);

      pos.updatedAt = Date.now();
    }
  }

  // æ›´æ–°æ‰€æœ‰ä»“ä½çš„ ADL æ’å
  for (const [trader, positions] of userPositions.entries()) {
    for (const pos of positions) {
      const score = Number(pos.adlScore);
      pos.adlRanking = calculateADLRanking(score, allScores);
    }
  }

  // æŒ‰ marginRatio å‡åºæ’åºå¼ºå¹³é˜Ÿåˆ— (æœ€å±é™©çš„åœ¨å‰é¢)
  liquidationQueue.sort((a, b) => a.marginRatio - b.marginRatio);

  // æ›´æ–° ADL é˜Ÿåˆ—
  updateADLQueues();

  // å¤„ç†å¼ºå¹³ (ç›´æ¥å¼ºå¹³ï¼Œæ— ç¼“å†²)
  processLiquidations();

  // å¤„ç† TP/SL è§¦å‘é˜Ÿåˆ— (P2)
  processTPSLTriggerQueue();

  // å¤„ç† Trailing Stop è§¦å‘é˜Ÿåˆ— (P2)
  processTrailingStopTriggerQueue();

  // å¤„ç† Conditional Orders è§¦å‘é˜Ÿåˆ— (P3)
  processConditionalTriggerQueue();

  // ============================================================
  // P4: å…¨ä»“æ¨¡å¼è´¦æˆ·æ›´æ–°å’Œå¼ºå¹³æ£€æŸ¥
  // ============================================================
  processCrossMarginAccounts();

  const elapsed = Date.now() - startTime;
  if (elapsed > 50) {
    console.warn(`[RiskEngine] Slow risk check: ${elapsed}ms`);
  }
}

/**
 * å¤„ç†å…¨ä»“æ¨¡å¼è´¦æˆ· (åœ¨ Risk Engine ä¸­è°ƒç”¨)
 */
function processCrossMarginAccounts(): void {
  for (const [trader, account] of crossMarginAccounts.entries()) {
    // æ›´æ–°å…¨ä»“è´¦æˆ·æŒ‡æ ‡
    updateCrossMarginMetrics(trader);

    // æ£€æŸ¥æ˜¯å¦éœ€è¦å¼ºå¹³
    const checkResult = isCrossMarginLiquidatable(trader);
    if (checkResult.liquidatable) {
      console.log(`[CrossMargin] âš ï¸ Account at risk: ${trader.slice(0, 10)} marginRatio=${checkResult.marginRatio}bp`);

      // è§¦å‘å¼ºå¹³
      processCrossMarginLiquidation(trader);
    }
  }
}

/**
 * å¤„ç†å¼ºå¹³é˜Ÿåˆ—
 */
async function processLiquidations(): Promise<void> {
  if (liquidationQueue.length === 0) return;

  console.log(`[RiskEngine] ${liquidationQueue.length} positions pending liquidation`);

  for (const candidate of liquidationQueue) {
    const pos = candidate.position;

    console.log(`[Liquidation] Processing: ${pos.trader.slice(0, 10)} ${pos.isLong ? 'LONG' : 'SHORT'} marginRatio=${candidate.marginRatio}bp urgency=${candidate.urgency}`);

    // æ£€æŸ¥æ˜¯å¦ä¼šç©¿ä»“
    const currentMargin = BigInt(pos.margin);
    const maintenanceMargin = BigInt(pos.maintenanceMargin);

    if (currentMargin < 0n) {
      // ç©¿ä»“ï¼éœ€è¦ ADL
      const deficit = -currentMargin;
      console.log(`[Liquidation] BANKRUPTCY! Deficit: $${Number(deficit) / 1e6}`);

      // è§¦å‘ ADL
      await executeADL(pos, deficit);
    }

    // è°ƒç”¨é“¾ä¸Šå¼ºå¹³
    if (submitter) {
      try {
        const pairId = BigInt(pos.pairId);
        // TODO: è°ƒç”¨é“¾ä¸Š liquidate å‡½æ•°
        // await submitter.liquidate(pairId);
        console.log(`[Liquidation] Submitted to chain: pairId=${pos.pairId}`);
      } catch (e) {
        console.error(`[Liquidation] Failed to liquidate ${pos.pairId}:`, e);
      }
    }

    // å¹¿æ’­å¼ºå¹³äº‹ä»¶
    broadcastLiquidationEvent(pos);
  }
}

/**
 * å¹¿æ’­å¼ºå¹³äº‹ä»¶
 */
function broadcastLiquidationEvent(position: Position): void {
  const message = JSON.stringify({
    type: "liquidation_warning",
    pairId: position.pairId,
    trader: position.trader,
    token: position.token,
    isLong: position.isLong,
    marginRatio: position.marginRatio,
    mmr: position.mmr,
    riskLevel: position.riskLevel,
    timestamp: Date.now(),
  });

  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  }
}

// ============================================================
// ä¿é™©åŸºé‡‘ (Insurance Fund) - Meme Perp æ ¸å¿ƒ
// ============================================================

/**
 * ä¿é™©åŸºé‡‘çŠ¶æ€
 * ç”¨äº:
 * 1. ç©¿ä»“æ—¶ï¼Œåœ¨ ADL ä¹‹å‰å…ˆç”¨ä¿é™©åŸºé‡‘è¦†ç›–
 * 2. å¼ºå¹³æ”¶ç›Šçš„ä¸€éƒ¨åˆ†æ³¨å…¥ä¿é™©åŸºé‡‘
 */
interface InsuranceFund {
  balance: bigint;                    // å½“å‰ä½™é¢ (1e6 USD)
  totalContributions: bigint;         // ç´¯è®¡æ³¨å…¥ (æ¥è‡ªæ¸…ç®—æ”¶ç›Šã€æ‰‹ç»­è´¹)
  totalPayouts: bigint;               // ç´¯è®¡æ”¯å‡º (å¼¥è¡¥ç©¿ä»“)
  lastUpdated: number;
}

// å…¨å±€ä¿é™©åŸºé‡‘ (æ‰€æœ‰ä»£å¸å…±ç”¨)
let insuranceFund: InsuranceFund = {
  balance: 10000n * 10n ** 6n,        // åˆå§‹ $10,000 (æµ‹è¯•ç”¨)
  totalContributions: 10000n * 10n ** 6n,
  totalPayouts: 0n,
  lastUpdated: Date.now(),
};

// æ¯ä¸ªä»£å¸çš„ä¿é™©åŸºé‡‘ (ç”¨äºéš”ç¦»é£é™©)
const tokenInsuranceFunds = new Map<Address, InsuranceFund>();

/**
 * è·å–ä»£å¸ä¿é™©åŸºé‡‘
 */
function getTokenInsuranceFund(token: Address): InsuranceFund {
  const normalizedToken = token.toLowerCase() as Address;
  let fund = tokenInsuranceFunds.get(normalizedToken);
  if (!fund) {
    fund = {
      balance: 1000n * 10n ** 6n,       // æ¯ä¸ªä»£å¸åˆå§‹ $1,000
      totalContributions: 1000n * 10n ** 6n,
      totalPayouts: 0n,
      lastUpdated: Date.now(),
    };
    tokenInsuranceFunds.set(normalizedToken, fund);
  }
  return fund;
}

/**
 * å‘ä¿é™©åŸºé‡‘æ³¨å…¥èµ„é‡‘
 * æ¥æº: æ¸…ç®—æ‰‹ç»­è´¹ã€äº¤æ˜“æ‰‹ç»­è´¹çš„ä¸€éƒ¨åˆ†
 */
function contributeToInsuranceFund(amount: bigint, token?: Address): void {
  if (token) {
    const fund = getTokenInsuranceFund(token);
    fund.balance += amount;
    fund.totalContributions += amount;
    fund.lastUpdated = Date.now();
    console.log(`[InsuranceFund] Token ${token.slice(0, 10)} contribution: +$${Number(amount) / 1e6}, balance: $${Number(fund.balance) / 1e6}`);
  } else {
    insuranceFund.balance += amount;
    insuranceFund.totalContributions += amount;
    insuranceFund.lastUpdated = Date.now();
    console.log(`[InsuranceFund] Global contribution: +$${Number(amount) / 1e6}, balance: $${Number(insuranceFund.balance) / 1e6}`);
  }
}

/**
 * ä»ä¿é™©åŸºé‡‘æ”¯å‡º
 * ç”¨é€”: Oracle ç»“ç®—ç›ˆåˆ©ã€ç©¿ä»“è¦†ç›–
 *
 * @returns å®é™…æ”¯å‡ºé‡‘é¢ (å¯èƒ½å°äºè¯·æ±‚é‡‘é¢)
 */
function payFromInsuranceFund(amount: bigint, token?: Address): bigint {
  if (token) {
    const fund = getTokenInsuranceFund(token);
    const actualPayout = amount > fund.balance ? fund.balance : amount;
    fund.balance -= actualPayout;
    fund.totalPayouts += actualPayout;
    fund.lastUpdated = Date.now();
    console.log(`[InsuranceFund] Token ${token.slice(0, 10)} payout: -$${Number(actualPayout) / 1e6}, balance: $${Number(fund.balance) / 1e6}`);
    return actualPayout;
  } else {
    const actualPayout = amount > insuranceFund.balance ? insuranceFund.balance : amount;
    insuranceFund.balance -= actualPayout;
    insuranceFund.totalPayouts += actualPayout;
    insuranceFund.lastUpdated = Date.now();
    console.log(`[InsuranceFund] Global payout: -$${Number(actualPayout) / 1e6}, balance: $${Number(insuranceFund.balance) / 1e6}`);
    return actualPayout;
  }
}

/**
 * æ£€æŸ¥ä¿é™©åŸºé‡‘æ˜¯å¦å……è¶³
 */
function hasInsuranceFundCoverage(amount: bigint, token?: Address): boolean {
  if (token) {
    const fund = getTokenInsuranceFund(token);
    return fund.balance >= amount;
  }
  return insuranceFund.balance >= amount;
}

// ============================================================
// Dynamic Funding (åŠ¨æ€èµ„é‡‘è´¹) - Meme Perp P1 åŠŸèƒ½
// ============================================================

/**
 * Meme Token åŠ¨æ€èµ„é‡‘è´¹é…ç½®
 *
 * ä¸ BTC/ETH ä¸åŒï¼ŒMeme Token éœ€è¦:
 * 1. æ›´é¢‘ç¹çš„ç»“ç®—å‘¨æœŸ (1h vs 8h)
 * 2. æ›´é«˜çš„æœ€å¤§è´¹ç‡ (3% vs 0.75%)
 * 3. æ³¢åŠ¨ç‡è°ƒæ•´çš„è´¹ç‡
 * 4. å®æ—¶è´¹ç‡æ›´æ–°
 */
interface DynamicFundingConfig {
  token: Address;
  baseInterval: number;          // åŸºç¡€ç»“ç®—å‘¨æœŸ (ms)
  minInterval: number;           // æœ€å°ç»“ç®—å‘¨æœŸ (é«˜æ³¢åŠ¨æ—¶)
  maxRate: number;               // æœ€å¤§è´¹ç‡ (basis points, 100 = 1%)
  volatilityMultiplier: number;  // æ³¢åŠ¨ç‡ä¹˜æ•°
  imbalanceMultiplier: number;   // å¤šç©ºä¸å¹³è¡¡ä¹˜æ•°
}

// é»˜è®¤ Meme Token èµ„é‡‘è´¹é…ç½®
const DEFAULT_MEME_FUNDING_CONFIG: Omit<DynamicFundingConfig, "token"> = {
  baseInterval: 60 * 60 * 1000,      // 1 å°æ—¶åŸºç¡€å‘¨æœŸ (BTC/ETH æ˜¯ 8 å°æ—¶)
  minInterval: 15 * 60 * 1000,       // æœ€å° 15 åˆ†é’Ÿ (é«˜æ³¢åŠ¨æ—¶)
  maxRate: 300,                      // æœ€å¤§ 3% (BTC æ˜¯ 0.75%)
  volatilityMultiplier: 1.5,         // æ³¢åŠ¨ç‡æ¯å¢åŠ  1%ï¼Œè´¹ç‡å¢åŠ  1.5 å€
  imbalanceMultiplier: 2,            // å¤šç©ºä¸å¹³è¡¡ä¹˜æ•°
};

const tokenFundingConfigs = new Map<Address, DynamicFundingConfig>();

/**
 * è·å–ä»£å¸èµ„é‡‘è´¹é…ç½®
 */
function getTokenFundingConfig(token: Address): DynamicFundingConfig {
  const normalizedToken = token.toLowerCase() as Address;
  let config = tokenFundingConfigs.get(normalizedToken);
  if (!config) {
    config = { token: normalizedToken, ...DEFAULT_MEME_FUNDING_CONFIG };
    tokenFundingConfigs.set(normalizedToken, config);
  }
  return config;
}

/**
 * èµ„é‡‘è´¹æ”¯ä»˜è®°å½•
 */
interface FundingPayment {
  pairId: string;
  trader: Address;
  token: Address;
  isLong: boolean;
  positionSize: string;
  fundingRate: string;            // è´¹ç‡ (basis points)
  fundingAmount: string;          // æ”¯ä»˜é‡‘é¢ (1e6 USD)
  isPayer: boolean;               // true = ä»˜æ¬¾æ–¹, false = æ”¶æ¬¾æ–¹
  timestamp: number;
}

// èµ„é‡‘è´¹æ”¯ä»˜å†å² (æŒ‰ä»£å¸åˆ†ç»„)
const fundingPaymentHistory = new Map<Address, FundingPayment[]>();

// ä¸‹æ¬¡èµ„é‡‘è´¹ç»“ç®—æ—¶é—´ (æŒ‰ä»£å¸)
const nextFundingSettlement = new Map<Address, number>();

// å½“å‰èµ„é‡‘è´¹ç‡ (æŒ‰ä»£å¸, basis points)
const currentFundingRates = new Map<Address, bigint>();

/**
 * è®¡ç®—åŠ¨æ€èµ„é‡‘è´¹ç‡
 *
 * åŠ¨æ€è´¹ç‡ = åŸºç¡€è´¹ç‡ Ã— (1 + æ³¢åŠ¨ç‡è°ƒæ•´) Ã— (1 + ä¸å¹³è¡¡è°ƒæ•´)
 *
 * åŸºç¡€è´¹ç‡æ¥è‡ªå¼•æ“çš„ calculateFundingRate
 */
function calculateDynamicFundingRate(token: Address): bigint {
  const normalizedToken = token.toLowerCase() as Address;
  const config = getTokenFundingConfig(normalizedToken);

  // è·å–å¼•æ“è®¡ç®—çš„åŸºç¡€è´¹ç‡
  const baseRate = engine.calculateFundingRate(normalizedToken);

  // è·å–æ³¢åŠ¨ç‡
  const tracker = volatilityTrackers.get(normalizedToken);
  const volatility = tracker?.volatility || 0;

  // æ³¢åŠ¨ç‡è°ƒæ•´ (æ³¢åŠ¨ç‡è¶Šé«˜ï¼Œè´¹ç‡è¶Šé«˜)
  const volatilityAdjustment = 1 + (volatility * config.volatilityMultiplier / 100);

  // è®¡ç®—å¤šç©ºä¸å¹³è¡¡
  const { longOI, shortOI } = calculateOpenInterest(normalizedToken);
  const totalOI = longOI + shortOI;
  let imbalanceRatio = 0;
  if (totalOI > 0n) {
    const imbalance = longOI > shortOI ? longOI - shortOI : shortOI - longOI;
    imbalanceRatio = Number(imbalance * 100n / totalOI);
  }

  // ä¸å¹³è¡¡è°ƒæ•´ (ä¸å¹³è¡¡è¶Šå¤§ï¼Œè´¹ç‡è¶Šé«˜)
  const imbalanceAdjustment = 1 + (imbalanceRatio * config.imbalanceMultiplier / 100);

  // è®¡ç®—æœ€ç»ˆè´¹ç‡
  let dynamicRate = BigInt(Math.floor(Number(baseRate) * volatilityAdjustment * imbalanceAdjustment));

  // é™åˆ¶æœ€å¤§è´¹ç‡
  const maxRateBigInt = BigInt(config.maxRate);
  if (dynamicRate > maxRateBigInt) dynamicRate = maxRateBigInt;
  if (dynamicRate < -maxRateBigInt) dynamicRate = -maxRateBigInt;

  currentFundingRates.set(normalizedToken, dynamicRate);

  console.log(`[DynamicFunding] Token ${token.slice(0, 10)}: base=${baseRate}bp vol=${volatility.toFixed(2)}% imbal=${imbalanceRatio.toFixed(2)}% final=${dynamicRate}bp`);

  return dynamicRate;
}

/**
 * è®¡ç®—å¤šç©ºæŒä»“é‡
 */
function calculateOpenInterest(token: Address): { longOI: bigint; shortOI: bigint } {
  const normalizedToken = token.toLowerCase() as Address;
  let longOI = 0n;
  let shortOI = 0n;

  for (const [trader, positions] of userPositions.entries()) {
    for (const pos of positions) {
      if ((pos.token.toLowerCase() as Address) === normalizedToken) {
        const positionValue = BigInt(pos.size);
        if (pos.isLong) {
          longOI += positionValue;
        } else {
          shortOI += positionValue;
        }
      }
    }
  }

  return { longOI, shortOI };
}

/**
 * è·å–åŠ¨æ€èµ„é‡‘è´¹ç»“ç®—å‘¨æœŸ
 *
 * é«˜æ³¢åŠ¨æ—¶ç¼©çŸ­å‘¨æœŸï¼Œä½æ³¢åŠ¨æ—¶ä½¿ç”¨åŸºç¡€å‘¨æœŸ
 */
function getDynamicFundingInterval(token: Address): number {
  const normalizedToken = token.toLowerCase() as Address;
  const config = getTokenFundingConfig(normalizedToken);

  // è·å–æ³¢åŠ¨ç‡
  const tracker = volatilityTrackers.get(normalizedToken);
  const volatility = tracker?.volatility || 0;

  // æ³¢åŠ¨ç‡ > 5% æ—¶ï¼Œå‘¨æœŸç¼©çŸ­åˆ°æœ€å°
  if (volatility > 5) {
    return config.minInterval;
  }

  // æ³¢åŠ¨ç‡ 1-5% æ—¶ï¼ŒæŒ‰æ¯”ä¾‹è°ƒæ•´
  if (volatility > 1) {
    const ratio = 1 - (volatility - 1) / 4; // 1% -> 1.0, 5% -> 0.0
    const interval = config.minInterval + (config.baseInterval - config.minInterval) * ratio;
    return Math.floor(interval);
  }

  return config.baseInterval;
}

/**
 * æ‰§è¡Œèµ„é‡‘è´¹ç»“ç®—
 *
 * æ­£è´¹ç‡: å¤šå¤´ä»˜ç»™ç©ºå¤´
 * è´Ÿè´¹ç‡: ç©ºå¤´ä»˜ç»™å¤šå¤´
 */
async function settleFunding(token: Address): Promise<void> {
  const normalizedToken = token.toLowerCase() as Address;
  const rate = currentFundingRates.get(normalizedToken) || 0n;

  if (rate === 0n) {
    console.log(`[DynamicFunding] No funding rate for ${token.slice(0, 10)}`);
    return;
  }

  console.log(`[DynamicFunding] Settling funding for ${token.slice(0, 10)} rate=${rate}bp`);

  const payments: FundingPayment[] = [];
  let totalLongPayment = 0n;
  let totalShortPayment = 0n;

  // éå†æ‰€æœ‰ä»“ä½ï¼Œè®¡ç®—èµ„é‡‘è´¹
  for (const [trader, positions] of userPositions.entries()) {
    for (const pos of positions) {
      if ((pos.token.toLowerCase() as Address) !== normalizedToken) continue;

      const positionSize = BigInt(pos.size);
      const currentPrice = BigInt(pos.markPrice);

      // è®¡ç®—ä»“ä½ä»·å€¼ (USD)
      const positionValue = (positionSize * currentPrice) / (10n ** 24n);

      // è®¡ç®—èµ„é‡‘è´¹é‡‘é¢ = ä»“ä½ä»·å€¼ Ã— è´¹ç‡ / 10000
      const fundingAmount = (positionValue * (rate >= 0n ? rate : -rate)) / 10000n;

      // æ­£è´¹ç‡: å¤šå¤´ä»˜ç»™ç©ºå¤´
      // è´Ÿè´¹ç‡: ç©ºå¤´ä»˜ç»™å¤šå¤´
      const isPayer = (rate > 0n && pos.isLong) || (rate < 0n && !pos.isLong);

      const payment: FundingPayment = {
        pairId: pos.pairId,
        trader: pos.trader,
        token: pos.token,
        isLong: pos.isLong,
        positionSize: pos.size,
        fundingRate: rate.toString(),
        fundingAmount: (isPayer ? -fundingAmount : fundingAmount).toString(),
        isPayer,
        timestamp: Date.now(),
      };

      payments.push(payment);

      // æ›´æ–°ä»“ä½çš„ç´¯è®¡èµ„é‡‘è´¹
      const currentFundingFee = BigInt(pos.fundingFee || "0");
      pos.fundingFee = (currentFundingFee + (isPayer ? -fundingAmount : fundingAmount)).toString();

      // ç»Ÿè®¡æ€»æ”¯ä»˜/æ”¶å–
      if (pos.isLong) {
        totalLongPayment += isPayer ? -fundingAmount : fundingAmount;
      } else {
        totalShortPayment += isPayer ? -fundingAmount : fundingAmount;
      }
    }
  }

  // ä¿å­˜æ”¯ä»˜è®°å½•
  const history = fundingPaymentHistory.get(normalizedToken) || [];
  history.push(...payments);
  if (history.length > 10000) {
    // ä¿ç•™æœ€è¿‘ 10000 æ¡
    fundingPaymentHistory.set(normalizedToken, history.slice(-10000));
  } else {
    fundingPaymentHistory.set(normalizedToken, history);
  }

  // è®¾ç½®ä¸‹æ¬¡ç»“ç®—æ—¶é—´
  const nextInterval = getDynamicFundingInterval(normalizedToken);
  nextFundingSettlement.set(normalizedToken, Date.now() + nextInterval);

  console.log(`[DynamicFunding] Settled: long=${totalLongPayment}usd short=${totalShortPayment}usd payments=${payments.length}`);

  // å¹¿æ’­èµ„é‡‘è´¹ç»“ç®—äº‹ä»¶
  broadcastFundingSettlement(normalizedToken, rate, payments.length);
}

/**
 * å¹¿æ’­èµ„é‡‘è´¹ç»“ç®—äº‹ä»¶
 */
function broadcastFundingSettlement(
  token: Address,
  rate: bigint,
  paymentCount: number
): void {
  const message = JSON.stringify({
    type: "funding_settlement",
    token,
    rate: rate.toString(),
    paymentCount,
    nextSettlement: nextFundingSettlement.get(token),
    timestamp: Date.now(),
  });

  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  }
}

/**
 * å¯åŠ¨åŠ¨æ€èµ„é‡‘è´¹å¼•æ“
 */
let dynamicFundingInterval: NodeJS.Timeout | null = null;
const DYNAMIC_FUNDING_CHECK_INTERVAL = 10000; // æ¯ 10 ç§’æ£€æŸ¥ä¸€æ¬¡

function startDynamicFundingEngine(): void {
  if (dynamicFundingInterval) {
    clearInterval(dynamicFundingInterval);
  }

  console.log(`[DynamicFunding] Starting dynamic funding engine...`);

  dynamicFundingInterval = setInterval(() => {
    const now = Date.now();

    for (const token of SUPPORTED_TOKENS) {
      const normalizedToken = token.toLowerCase() as Address;

      // è®¡ç®—åŠ¨æ€è´¹ç‡
      calculateDynamicFundingRate(normalizedToken);

      // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»“ç®—æ—¶é—´
      const nextSettlement = nextFundingSettlement.get(normalizedToken);
      if (!nextSettlement || now >= nextSettlement) {
        settleFunding(normalizedToken).catch((e) => {
          console.error(`[DynamicFunding] Settlement failed for ${token.slice(0, 10)}:`, e);
        });
      }
    }
  }, DYNAMIC_FUNDING_CHECK_INTERVAL);
}

/**
 * åœæ­¢åŠ¨æ€èµ„é‡‘è´¹å¼•æ“
 */
function stopDynamicFundingEngine(): void {
  if (dynamicFundingInterval) {
    clearInterval(dynamicFundingInterval);
    dynamicFundingInterval = null;
  }
}

// ============================================================
// Take Profit / Stop Loss (æ­¢ç›ˆæ­¢æŸ) - Meme Perp P2 åŠŸèƒ½
// ============================================================

/**
 * TP/SL è®¢å•ç±»å‹
 */
interface TPSLOrder {
  pairId: string;
  trader: Address;
  token: Address;
  isLong: boolean;

  // æ­¢ç›ˆé…ç½®
  takeProfitPrice: bigint | null;
  takeProfitTriggered: boolean;

  // æ­¢æŸé…ç½®
  stopLossPrice: bigint | null;
  stopLossTriggered: boolean;

  // è§¦å‘åçš„æ‰§è¡ŒçŠ¶æ€
  executionStatus: "pending" | "executing" | "executed" | "failed";
  executedAt: number | null;
  executionPrice: bigint | null;
  executionPnL: bigint | null;

  createdAt: number;
  updatedAt: number;
}

// TP/SL è®¢å•å­˜å‚¨ (æŒ‰ pairId)
const tpslOrders = new Map<string, TPSLOrder>();

// å¾…æ‰§è¡Œçš„ TP/SL è§¦å‘é˜Ÿåˆ—
const tpslTriggerQueue: { order: TPSLOrder; triggerType: "tp" | "sl"; triggerPrice: bigint }[] = [];

/**
 * è®¾ç½®æˆ–æ›´æ–° TP/SL
 */
function setTakeProfitStopLoss(
  pairId: string,
  takeProfitPrice: bigint | null,
  stopLossPrice: bigint | null
): TPSLOrder | null {
  // æŸ¥æ‰¾ä»“ä½
  let position: Position | null = null;
  for (const [trader, positions] of userPositions.entries()) {
    const found = positions.find(p => p.pairId === pairId);
    if (found) {
      position = found;
      break;
    }
  }

  if (!position) {
    console.error(`[TP/SL] Position not found: ${pairId}`);
    return null;
  }

  const entryPrice = BigInt(position.entryPrice);

  // éªŒè¯ TP/SL ä»·æ ¼åˆç†æ€§
  if (takeProfitPrice !== null) {
    // å¤šå¤´ TP å¿…é¡»é«˜äºå…¥åœºä»·ï¼Œç©ºå¤´ TP å¿…é¡»ä½äºå…¥åœºä»·
    if (position.isLong && takeProfitPrice <= entryPrice) {
      console.error(`[TP/SL] Invalid TP for LONG: TP ${takeProfitPrice} <= entry ${entryPrice}`);
      return null;
    }
    if (!position.isLong && takeProfitPrice >= entryPrice) {
      console.error(`[TP/SL] Invalid TP for SHORT: TP ${takeProfitPrice} >= entry ${entryPrice}`);
      return null;
    }
  }

  if (stopLossPrice !== null) {
    // å¤šå¤´ SL å¿…é¡»ä½äºå…¥åœºä»·ï¼Œç©ºå¤´ SL å¿…é¡»é«˜äºå…¥åœºä»·
    if (position.isLong && stopLossPrice >= entryPrice) {
      console.error(`[TP/SL] Invalid SL for LONG: SL ${stopLossPrice} >= entry ${entryPrice}`);
      return null;
    }
    if (!position.isLong && stopLossPrice <= entryPrice) {
      console.error(`[TP/SL] Invalid SL for SHORT: SL ${stopLossPrice} <= entry ${entryPrice}`);
      return null;
    }

    // SL ä¸èƒ½ä½äº/é«˜äºå¼ºå¹³ä»·
    const liqPrice = BigInt(position.liquidationPrice);
    if (position.isLong && stopLossPrice <= liqPrice) {
      console.error(`[TP/SL] SL ${stopLossPrice} below liquidation price ${liqPrice}`);
      return null;
    }
    if (!position.isLong && stopLossPrice >= liqPrice) {
      console.error(`[TP/SL] SL ${stopLossPrice} above liquidation price ${liqPrice}`);
      return null;
    }
  }

  // æ›´æ–°æˆ–åˆ›å»º TP/SL è®¢å•
  let order = tpslOrders.get(pairId);
  const now = Date.now();

  if (order) {
    // æ›´æ–°ç°æœ‰è®¢å•
    order.takeProfitPrice = takeProfitPrice;
    order.stopLossPrice = stopLossPrice;
    order.updatedAt = now;
  } else {
    // åˆ›å»ºæ–°è®¢å•
    order = {
      pairId,
      trader: position.trader,
      token: position.token,
      isLong: position.isLong,
      takeProfitPrice,
      takeProfitTriggered: false,
      stopLossPrice,
      stopLossTriggered: false,
      executionStatus: "pending",
      executedAt: null,
      executionPrice: null,
      executionPnL: null,
      createdAt: now,
      updatedAt: now,
    };
    tpslOrders.set(pairId, order);
  }

  // æ›´æ–°ä»“ä½çš„ TP/SL ä»·æ ¼æ˜¾ç¤º
  position.takeProfitPrice = takeProfitPrice?.toString() || null;
  position.stopLossPrice = stopLossPrice?.toString() || null;

  console.log(`[TP/SL] Set for ${pairId}: TP=${takeProfitPrice?.toString() || 'none'} SL=${stopLossPrice?.toString() || 'none'}`);

  return order;
}

/**
 * å–æ¶ˆ TP/SL
 */
function cancelTakeProfitStopLoss(pairId: string, cancelType: "tp" | "sl" | "both"): boolean {
  const order = tpslOrders.get(pairId);
  if (!order) return false;

  if (cancelType === "tp" || cancelType === "both") {
    order.takeProfitPrice = null;
    order.takeProfitTriggered = false;
  }

  if (cancelType === "sl" || cancelType === "both") {
    order.stopLossPrice = null;
    order.stopLossTriggered = false;
  }

  // æ›´æ–°ä»“ä½æ˜¾ç¤º
  for (const [trader, positions] of userPositions.entries()) {
    const position = positions.find(p => p.pairId === pairId);
    if (position) {
      if (cancelType === "tp" || cancelType === "both") position.takeProfitPrice = null;
      if (cancelType === "sl" || cancelType === "both") position.stopLossPrice = null;
      break;
    }
  }

  // å¦‚æœéƒ½å–æ¶ˆäº†ï¼Œåˆ é™¤è®¢å•
  if (order.takeProfitPrice === null && order.stopLossPrice === null) {
    tpslOrders.delete(pairId);
  }

  console.log(`[TP/SL] Cancelled ${cancelType} for ${pairId}`);
  return true;
}

/**
 * æ£€æŸ¥ TP/SL è§¦å‘ (åœ¨ Risk Engine ä¸­è°ƒç”¨)
 */
function checkTakeProfitStopLoss(position: Position, currentPrice: bigint): void {
  const order = tpslOrders.get(position.pairId);
  if (!order || order.executionStatus !== "pending") return;

  // æ£€æŸ¥æ­¢ç›ˆ
  if (order.takeProfitPrice !== null && !order.takeProfitTriggered) {
    const tpPrice = order.takeProfitPrice;

    // å¤šå¤´: å½“å‰ä»·æ ¼ >= TP ä»·æ ¼è§¦å‘
    // ç©ºå¤´: å½“å‰ä»·æ ¼ <= TP ä»·æ ¼è§¦å‘
    const tpTriggered = position.isLong
      ? currentPrice >= tpPrice
      : currentPrice <= tpPrice;

    if (tpTriggered) {
      order.takeProfitTriggered = true;
      tpslTriggerQueue.push({ order, triggerType: "tp", triggerPrice: currentPrice });
      console.log(`[TP/SL] ğŸ¯ Take Profit TRIGGERED: ${position.pairId} @ ${currentPrice}`);
      broadcastTPSLTriggered(position, "tp", currentPrice);
    }
  }

  // æ£€æŸ¥æ­¢æŸ (å¦‚æœæ­¢ç›ˆæ²¡è§¦å‘)
  if (order.stopLossPrice !== null && !order.stopLossTriggered && !order.takeProfitTriggered) {
    const slPrice = order.stopLossPrice;

    // å¤šå¤´: å½“å‰ä»·æ ¼ <= SL ä»·æ ¼è§¦å‘
    // ç©ºå¤´: å½“å‰ä»·æ ¼ >= SL ä»·æ ¼è§¦å‘
    const slTriggered = position.isLong
      ? currentPrice <= slPrice
      : currentPrice >= slPrice;

    if (slTriggered) {
      order.stopLossTriggered = true;
      tpslTriggerQueue.push({ order, triggerType: "sl", triggerPrice: currentPrice });
      console.log(`[TP/SL] ğŸ›‘ Stop Loss TRIGGERED: ${position.pairId} @ ${currentPrice}`);
      broadcastTPSLTriggered(position, "sl", currentPrice);
    }
  }
}

/**
 * å¤„ç† TP/SL è§¦å‘é˜Ÿåˆ— (æ¯æ¬¡ Risk Check åè°ƒç”¨)
 */
async function processTPSLTriggerQueue(): Promise<void> {
  while (tpslTriggerQueue.length > 0) {
    const trigger = tpslTriggerQueue.shift()!;
    const { order, triggerType, triggerPrice } = trigger;

    // æŸ¥æ‰¾ä»“ä½
    let position: Position | null = null;
    for (const [trader, positions] of userPositions.entries()) {
      const found = positions.find(p => p.pairId === order.pairId);
      if (found) {
        position = found;
        break;
      }
    }

    if (!position) {
      console.error(`[TP/SL] Position not found for execution: ${order.pairId}`);
      order.executionStatus = "failed";
      continue;
    }

    try {
      order.executionStatus = "executing";

      // æ‰§è¡Œå…¨é¢å¹³ä»“
      const currentSize = BigInt(position.size);
      const currentPrice = triggerPrice;

      // è®¡ç®— PnL
      const pnl = calculateUnrealizedPnL(
        currentSize,
        BigInt(position.entryPrice),
        currentPrice,
        position.isLong
      );

      // è®¡ç®—å¹³ä»“æ‰‹ç»­è´¹ (0.05%)
      const positionValue = (currentSize * currentPrice) / (10n ** 24n);
      const closeFee = (positionValue * 5n) / 10000n;

      // æ›´æ–°è®¢å•çŠ¶æ€
      order.executedAt = Date.now();
      order.executionPrice = currentPrice;
      order.executionPnL = pnl;
      order.executionStatus = "executed";

      // ä»ç”¨æˆ·ä»“ä½åˆ—è¡¨ä¸­ç§»é™¤
      const normalizedTrader = position.trader.toLowerCase() as Address;
      const positions = userPositions.get(normalizedTrader) || [];
      const updatedPositions = positions.filter(p => p.pairId !== order.pairId);
      userPositions.set(normalizedTrader, updatedPositions);

      // ç§»é™¤ TP/SL è®¢å•
      tpslOrders.delete(order.pairId);

      // å¹¿æ’­æ‰§è¡Œäº‹ä»¶
      broadcastTPSLExecuted(position, triggerType, currentPrice, pnl, closeFee);

      console.log(`[TP/SL] âœ… Executed ${triggerType.toUpperCase()}: ${order.pairId} PnL=$${Number(pnl) / 1e6}`);

    } catch (e) {
      console.error(`[TP/SL] Execution failed: ${order.pairId}`, e);
      order.executionStatus = "failed";
    }
  }
}

/**
 * å¹¿æ’­ TP/SL è§¦å‘äº‹ä»¶
 */
function broadcastTPSLTriggered(
  position: Position,
  triggerType: "tp" | "sl",
  triggerPrice: bigint
): void {
  const message = JSON.stringify({
    type: "tpsl_triggered",
    pairId: position.pairId,
    trader: position.trader,
    token: position.token,
    isLong: position.isLong,
    triggerType,
    triggerPrice: triggerPrice.toString(),
    timestamp: Date.now(),
  });

  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  }
}

/**
 * å¹¿æ’­ TP/SL æ‰§è¡Œäº‹ä»¶
 */
function broadcastTPSLExecuted(
  position: Position,
  triggerType: "tp" | "sl",
  executionPrice: bigint,
  pnl: bigint,
  fee: bigint
): void {
  const message = JSON.stringify({
    type: "tpsl_executed",
    pairId: position.pairId,
    trader: position.trader,
    token: position.token,
    isLong: position.isLong,
    triggerType,
    executionPrice: executionPrice.toString(),
    realizedPnL: pnl.toString(),
    closeFee: fee.toString(),
    timestamp: Date.now(),
  });

  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  }
}

// ============================================================
// Trailing Stop (ç§»åŠ¨æ­¢æŸ) - Meme Perp P2 åŠŸèƒ½
// ============================================================

/**
 * Trailing Stop è®¢å•
 *
 * ç‰¹ç‚¹:
 * 1. æ­¢æŸä»·æ ¼è·Ÿéšå¸‚åœºä»·æ ¼ç§»åŠ¨
 * 2. åªå‘æœ‰åˆ©æ–¹å‘è°ƒæ•´ï¼ˆå¤šå¤´å‘ä¸Šï¼Œç©ºå¤´å‘ä¸‹ï¼‰
 * 3. æ”¯æŒå›ºå®šè·ç¦»å’Œç™¾åˆ†æ¯”ä¸¤ç§æ¨¡å¼
 */
interface TrailingStopOrder {
  pairId: string;
  trader: Address;
  token: Address;
  isLong: boolean;

  // è§¦å‘æ¨¡å¼
  mode: "distance" | "percentage";
  // è·ç¦»æ¨¡å¼: å›ºå®šä»·æ ¼è·ç¦» (1e12)
  trailDistance: bigint | null;
  // ç™¾åˆ†æ¯”æ¨¡å¼: å›æ’¤ç™¾åˆ†æ¯” (basis points, 100 = 1%)
  trailPercentage: number | null;

  // æ¿€æ´»ä»·æ ¼ (å¿…é¡»å…ˆè¾¾åˆ°æ­¤ä»·æ ¼æ‰å¼€å§‹è¿½è¸ª)
  activationPrice: bigint | null;
  isActivated: boolean;

  // å½“å‰è¿½è¸ªçŠ¶æ€
  peakPrice: bigint;               // æœ€é«˜/æœ€ä½ä»·æ ¼ (å¤šå¤´æœ€é«˜/ç©ºå¤´æœ€ä½)
  currentStopPrice: bigint;        // å½“å‰æ­¢æŸä»·æ ¼
  triggered: boolean;

  // æ‰§è¡ŒçŠ¶æ€
  executionStatus: "pending" | "executing" | "executed" | "failed";
  executedAt: number | null;
  executionPrice: bigint | null;
  executionPnL: bigint | null;

  createdAt: number;
  updatedAt: number;
}

// Trailing Stop è®¢å•å­˜å‚¨ (æŒ‰ pairId)
const trailingStopOrders = new Map<string, TrailingStopOrder>();

// Trailing Stop è§¦å‘é˜Ÿåˆ—
const trailingStopTriggerQueue: { order: TrailingStopOrder; triggerPrice: bigint }[] = [];

/**
 * è®¾ç½® Trailing Stop
 */
function setTrailingStop(
  pairId: string,
  mode: "distance" | "percentage",
  trailValue: bigint | number,
  activationPrice?: bigint
): TrailingStopOrder | null {
  // æŸ¥æ‰¾ä»“ä½
  let position: Position | null = null;
  for (const [trader, positions] of userPositions.entries()) {
    const found = positions.find(p => p.pairId === pairId);
    if (found) {
      position = found;
      break;
    }
  }

  if (!position) {
    console.error(`[TrailingStop] Position not found: ${pairId}`);
    return null;
  }

  const currentPrice = BigInt(position.markPrice);
  const now = Date.now();

  // åˆ›å»ºè®¢å•
  const order: TrailingStopOrder = {
    pairId,
    trader: position.trader,
    token: position.token,
    isLong: position.isLong,
    mode,
    trailDistance: mode === "distance" ? (trailValue as bigint) : null,
    trailPercentage: mode === "percentage" ? (trailValue as number) : null,
    activationPrice: activationPrice || null,
    isActivated: activationPrice ? false : true, // æ— æ¿€æ´»ä»·åˆ™ç«‹å³æ¿€æ´»
    peakPrice: currentPrice,
    currentStopPrice: calculateTrailingStopPrice(currentPrice, position.isLong, mode, trailValue),
    triggered: false,
    executionStatus: "pending",
    executedAt: null,
    executionPrice: null,
    executionPnL: null,
    createdAt: now,
    updatedAt: now,
  };

  // éªŒè¯æ­¢æŸä»·æ ¼åˆç†æ€§
  const entryPrice = BigInt(position.entryPrice);
  const liqPrice = BigInt(position.liquidationPrice);

  if (position.isLong) {
    // å¤šå¤´: æ­¢æŸä»·ä¸èƒ½é«˜äºå…¥åœºä»·æˆ–ä½äºå¼ºå¹³ä»·
    if (order.currentStopPrice >= entryPrice) {
      console.error(`[TrailingStop] Invalid for LONG: stop ${order.currentStopPrice} >= entry ${entryPrice}`);
      return null;
    }
    if (order.currentStopPrice <= liqPrice) {
      console.error(`[TrailingStop] Invalid for LONG: stop ${order.currentStopPrice} <= liq ${liqPrice}`);
      return null;
    }
  } else {
    // ç©ºå¤´: æ­¢æŸä»·ä¸èƒ½ä½äºå…¥åœºä»·æˆ–é«˜äºå¼ºå¹³ä»·
    if (order.currentStopPrice <= entryPrice) {
      console.error(`[TrailingStop] Invalid for SHORT: stop ${order.currentStopPrice} <= entry ${entryPrice}`);
      return null;
    }
    if (order.currentStopPrice >= liqPrice) {
      console.error(`[TrailingStop] Invalid for SHORT: stop ${order.currentStopPrice} >= liq ${liqPrice}`);
      return null;
    }
  }

  trailingStopOrders.set(pairId, order);

  console.log(`[TrailingStop] Set for ${pairId}: mode=${mode} trail=${trailValue} stop=$${Number(order.currentStopPrice) / 1e12}`);

  return order;
}

/**
 * è®¡ç®— Trailing Stop ä»·æ ¼
 */
function calculateTrailingStopPrice(
  peakPrice: bigint,
  isLong: boolean,
  mode: "distance" | "percentage",
  trailValue: bigint | number
): bigint {
  if (mode === "distance") {
    const distance = trailValue as bigint;
    return isLong ? peakPrice - distance : peakPrice + distance;
  } else {
    const percentage = trailValue as number; // basis points
    const delta = (peakPrice * BigInt(percentage)) / 10000n;
    return isLong ? peakPrice - delta : peakPrice + delta;
  }
}

/**
 * æ›´æ–° Trailing Stop (åœ¨ Risk Engine ä¸­è°ƒç”¨)
 */
function updateTrailingStop(position: Position, currentPrice: bigint): void {
  const order = trailingStopOrders.get(position.pairId);
  if (!order || order.executionStatus !== "pending") return;

  // æ£€æŸ¥æ˜¯å¦éœ€è¦æ¿€æ´»
  if (!order.isActivated && order.activationPrice) {
    const activated = position.isLong
      ? currentPrice >= order.activationPrice
      : currentPrice <= order.activationPrice;

    if (activated) {
      order.isActivated = true;
      order.peakPrice = currentPrice;
      console.log(`[TrailingStop] Activated: ${position.pairId} @ ${currentPrice}`);
      broadcastTrailingStopActivated(position, currentPrice);
    }
    return;
  }

  // æ›´æ–°å³°å€¼ä»·æ ¼ (åªå‘æœ‰åˆ©æ–¹å‘ç§»åŠ¨)
  let peakUpdated = false;
  if (position.isLong && currentPrice > order.peakPrice) {
    order.peakPrice = currentPrice;
    peakUpdated = true;
  } else if (!position.isLong && currentPrice < order.peakPrice) {
    order.peakPrice = currentPrice;
    peakUpdated = true;
  }

  // å¦‚æœå³°å€¼æ›´æ–°ï¼Œé‡æ–°è®¡ç®—æ­¢æŸä»·æ ¼
  if (peakUpdated) {
    const trailValue = order.mode === "distance" ? order.trailDistance! : order.trailPercentage!;
    order.currentStopPrice = calculateTrailingStopPrice(order.peakPrice, position.isLong, order.mode, trailValue);
    order.updatedAt = Date.now();

    console.log(`[TrailingStop] Updated: ${position.pairId} peak=$${Number(order.peakPrice) / 1e12} stop=$${Number(order.currentStopPrice) / 1e12}`);
    broadcastTrailingStopUpdated(position, order);
  }

  // æ£€æŸ¥æ˜¯å¦è§¦å‘
  const triggered = position.isLong
    ? currentPrice <= order.currentStopPrice
    : currentPrice >= order.currentStopPrice;

  if (triggered && !order.triggered) {
    order.triggered = true;
    trailingStopTriggerQueue.push({ order, triggerPrice: currentPrice });
    console.log(`[TrailingStop] ğŸ›‘ TRIGGERED: ${position.pairId} @ ${currentPrice}`);
    broadcastTrailingStopTriggered(position, currentPrice);
  }
}

/**
 * å¤„ç† Trailing Stop è§¦å‘é˜Ÿåˆ—
 */
async function processTrailingStopTriggerQueue(): Promise<void> {
  while (trailingStopTriggerQueue.length > 0) {
    const trigger = trailingStopTriggerQueue.shift()!;
    const { order, triggerPrice } = trigger;

    // æŸ¥æ‰¾ä»“ä½
    let position: Position | null = null;
    for (const [trader, positions] of userPositions.entries()) {
      const found = positions.find(p => p.pairId === order.pairId);
      if (found) {
        position = found;
        break;
      }
    }

    if (!position) {
      order.executionStatus = "failed";
      continue;
    }

    try {
      order.executionStatus = "executing";

      // æ‰§è¡Œå…¨é¢å¹³ä»“
      const currentSize = BigInt(position.size);
      const pnl = calculateUnrealizedPnL(
        currentSize,
        BigInt(position.entryPrice),
        triggerPrice,
        position.isLong
      );

      const positionValue = (currentSize * triggerPrice) / (10n ** 24n);
      const closeFee = (positionValue * 5n) / 10000n;

      order.executedAt = Date.now();
      order.executionPrice = triggerPrice;
      order.executionPnL = pnl;
      order.executionStatus = "executed";

      // ç§»é™¤ä»“ä½
      const normalizedTrader = position.trader.toLowerCase() as Address;
      const positions = userPositions.get(normalizedTrader) || [];
      userPositions.set(normalizedTrader, positions.filter(p => p.pairId !== order.pairId));

      // æ¸…ç†ç›¸å…³è®¢å•
      trailingStopOrders.delete(order.pairId);
      tpslOrders.delete(order.pairId);

      broadcastTrailingStopExecuted(position, triggerPrice, pnl, closeFee);

      console.log(`[TrailingStop] âœ… Executed: ${order.pairId} PnL=$${Number(pnl) / 1e6}`);
    } catch (e) {
      console.error(`[TrailingStop] Execution failed: ${order.pairId}`, e);
      order.executionStatus = "failed";
    }
  }
}

/**
 * å–æ¶ˆ Trailing Stop
 */
function cancelTrailingStop(pairId: string): boolean {
  const deleted = trailingStopOrders.delete(pairId);
  if (deleted) {
    console.log(`[TrailingStop] Cancelled: ${pairId}`);
  }
  return deleted;
}

// Trailing Stop å¹¿æ’­å‡½æ•°
function broadcastTrailingStopActivated(position: Position, price: bigint): void {
  broadcast("trailing_stop_activated", { pairId: position.pairId, trader: position.trader, activationPrice: price.toString() });
}

function broadcastTrailingStopUpdated(position: Position, order: TrailingStopOrder): void {
  broadcast("trailing_stop_updated", {
    pairId: position.pairId,
    trader: position.trader,
    peakPrice: order.peakPrice.toString(),
    currentStopPrice: order.currentStopPrice.toString(),
  });
}

function broadcastTrailingStopTriggered(position: Position, price: bigint): void {
  broadcast("trailing_stop_triggered", { pairId: position.pairId, trader: position.trader, triggerPrice: price.toString() });
}

function broadcastTrailingStopExecuted(position: Position, price: bigint, pnl: bigint, fee: bigint): void {
  broadcast("trailing_stop_executed", {
    pairId: position.pairId,
    trader: position.trader,
    executionPrice: price.toString(),
    realizedPnL: pnl.toString(),
    closeFee: fee.toString(),
  });
}

function broadcast(type: string, data: Record<string, unknown>): void {
  const message = JSON.stringify({ type, ...data, timestamp: Date.now() });
  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) client.send(message);
  }
}

// ============================================================
// P3: Conditional Orders (æ¡ä»¶å•)
// ============================================================

/**
 * æ¡ä»¶å•ç±»å‹
 * - STOP_MARKET: è§¦åŠä»·æ ¼æ—¶ä»¥å¸‚ä»·æ‰§è¡Œ
 * - STOP_LIMIT: è§¦åŠä»·æ ¼æ—¶ä»¥é™ä»·æ‰§è¡Œ
 * - TRIGGER_MARKET: å½“ä»·æ ¼çªç ´è§¦å‘ä»·æ—¶ä»¥å¸‚ä»·æ‰§è¡Œ
 * - TRIGGER_LIMIT: å½“ä»·æ ¼çªç ´è§¦å‘ä»·æ—¶ä»¥é™ä»·æ‰§è¡Œ
 */
type ConditionalOrderType = "STOP_MARKET" | "STOP_LIMIT" | "TRIGGER_MARKET" | "TRIGGER_LIMIT";

/**
 * è§¦å‘æ–¹å‘
 * - ABOVE: å½“ä»·æ ¼é«˜äºè§¦å‘ä»·æ—¶è§¦å‘ (ç”¨äºçªç ´ä¹°å…¥/æ­¢æŸå–å‡º)
 * - BELOW: å½“ä»·æ ¼ä½äºè§¦å‘ä»·æ—¶è§¦å‘ (ç”¨äºçªç ´å–å‡º/æ­¢æŸä¹°å…¥)
 */
type TriggerDirection = "ABOVE" | "BELOW";

interface ConditionalOrder {
  id: string;
  trader: Address;
  token: Address;

  // è§¦å‘æ¡ä»¶
  triggerPrice: bigint;           // è§¦å‘ä»·æ ¼
  triggerDirection: TriggerDirection; // è§¦å‘æ–¹å‘

  // è®¢å•å‚æ•°
  orderType: ConditionalOrderType;
  isLong: boolean;                // å¼€å¤š/å¼€ç©º
  size: bigint;                   // ä»“ä½å¤§å°
  leverage: bigint;               // æ æ†
  limitPrice: bigint | null;      // é™ä»· (ä»…é™ä»·å•éœ€è¦)

  // çŠ¶æ€
  status: "pending" | "triggered" | "executed" | "cancelled" | "failed";
  triggered: boolean;
  triggeredAt: number | null;
  executedAt: number | null;
  executionPrice: bigint | null;
  failReason: string | null;

  // é™„åŠ é€‰é¡¹
  reduceOnly: boolean;            // æ˜¯å¦åªå‡ä»“
  postOnly: boolean;              // æ˜¯å¦åªæŒ‚å•

  createdAt: number;
  updatedAt: number;
}

// æ¡ä»¶å•å­˜å‚¨
const conditionalOrders = new Map<string, ConditionalOrder>();
let conditionalOrderIdCounter = 0;

// å¾…æ‰§è¡Œçš„æ¡ä»¶å•è§¦å‘é˜Ÿåˆ—
const conditionalTriggerQueue: { order: ConditionalOrder; triggerPrice: bigint }[] = [];

/**
 * åˆ›å»ºæ¡ä»¶å•
 */
function createConditionalOrder(
  trader: Address,
  token: Address,
  triggerPrice: bigint,
  triggerDirection: TriggerDirection,
  orderType: ConditionalOrderType,
  isLong: boolean,
  size: bigint,
  leverage: bigint,
  limitPrice?: bigint,
  options?: {
    reduceOnly?: boolean;
    postOnly?: boolean;
  }
): ConditionalOrder | { error: string } {
  const now = Date.now();

  // éªŒè¯è§¦å‘æ–¹å‘ä¸è®¢å•æ–¹å‘çš„åˆç†æ€§
  // ä¾‹å¦‚: åšå¤šçš„æ­¢æŸå•åº”è¯¥æ˜¯ BELOW (ä»·æ ¼ä¸‹è·Œè§¦å‘)
  // åšç©ºçš„æ­¢æŸå•åº”è¯¥æ˜¯ ABOVE (ä»·æ ¼ä¸Šæ¶¨è§¦å‘)
  const currentPrice = engine.getOrderBook(token).getCurrentPrice();

  // éªŒè¯é™ä»·å•å¿…é¡»æœ‰é™ä»·
  if ((orderType === "STOP_LIMIT" || orderType === "TRIGGER_LIMIT") && !limitPrice) {
    return { error: "Limit price required for limit orders" };
  }

  // éªŒè¯ Post-Only ä¸èƒ½ç”¨äºå¸‚ä»·æ¡ä»¶å•
  if (options?.postOnly && (orderType === "STOP_MARKET" || orderType === "TRIGGER_MARKET")) {
    return { error: "Post-Only cannot be used with market orders" };
  }

  // éªŒè¯è§¦å‘ä»·æ ¼åˆç†æ€§
  if (triggerDirection === "ABOVE" && currentPrice > 0n && triggerPrice <= currentPrice) {
    return { error: `Trigger price ${triggerPrice} must be above current price ${currentPrice}` };
  }
  if (triggerDirection === "BELOW" && currentPrice > 0n && triggerPrice >= currentPrice) {
    return { error: `Trigger price ${triggerPrice} must be below current price ${currentPrice}` };
  }

  const orderId = `cond_${++conditionalOrderIdCounter}_${now}`;

  const order: ConditionalOrder = {
    id: orderId,
    trader,
    token,
    triggerPrice,
    triggerDirection,
    orderType,
    isLong,
    size,
    leverage,
    limitPrice: limitPrice || null,
    status: "pending",
    triggered: false,
    triggeredAt: null,
    executedAt: null,
    executionPrice: null,
    failReason: null,
    reduceOnly: options?.reduceOnly || false,
    postOnly: options?.postOnly || false,
    createdAt: now,
    updatedAt: now,
  };

  conditionalOrders.set(orderId, order);

  console.log(`[ConditionalOrder] Created ${orderId}: ${orderType} ${isLong ? "LONG" : "SHORT"} trigger=${triggerPrice} dir=${triggerDirection}`);

  broadcastConditionalOrderCreated(order);

  return order;
}

/**
 * å–æ¶ˆæ¡ä»¶å•
 */
function cancelConditionalOrder(orderId: string, trader: Address): boolean {
  const order = conditionalOrders.get(orderId);
  if (!order) {
    return false;
  }

  if (order.trader.toLowerCase() !== trader.toLowerCase()) {
    return false;
  }

  if (order.status !== "pending") {
    return false;
  }

  order.status = "cancelled";
  order.updatedAt = Date.now();

  console.log(`[ConditionalOrder] Cancelled ${orderId}`);

  broadcastConditionalOrderCancelled(order);

  return true;
}

/**
 * æ£€æŸ¥æ¡ä»¶å•è§¦å‘ (åœ¨ Risk Engine ä¸­è°ƒç”¨)
 */
function checkConditionalOrders(token: Address, currentPrice: bigint): void {
  const normalizedToken = token.toLowerCase() as Address;

  for (const [orderId, order] of conditionalOrders.entries()) {
    if (order.token.toLowerCase() !== normalizedToken) continue;
    if (order.status !== "pending") continue;

    // æ£€æŸ¥æ˜¯å¦è§¦å‘
    let triggered = false;
    if (order.triggerDirection === "ABOVE") {
      triggered = currentPrice >= order.triggerPrice;
    } else {
      triggered = currentPrice <= order.triggerPrice;
    }

    if (triggered) {
      order.triggered = true;
      order.triggeredAt = Date.now();
      conditionalTriggerQueue.push({ order, triggerPrice: currentPrice });
      console.log(`[ConditionalOrder] ğŸ”” TRIGGERED: ${orderId} @ ${currentPrice}`);
      broadcastConditionalOrderTriggered(order, currentPrice);
    }
  }
}

/**
 * å¤„ç†æ¡ä»¶å•è§¦å‘é˜Ÿåˆ—
 */
async function processConditionalTriggerQueue(): Promise<void> {
  while (conditionalTriggerQueue.length > 0) {
    const trigger = conditionalTriggerQueue.shift()!;
    const { order, triggerPrice } = trigger;

    try {
      order.status = "triggered";

      // ç¡®å®šæ‰§è¡Œä»·æ ¼
      let executePrice: bigint;
      if (order.orderType === "STOP_MARKET" || order.orderType === "TRIGGER_MARKET") {
        // å¸‚ä»·å•: ä»¥å½“å‰ä»·æ ¼æ‰§è¡Œ
        executePrice = triggerPrice;
      } else {
        // é™ä»·å•: æ£€æŸ¥é™ä»·æ˜¯å¦å¯è¡Œ
        executePrice = order.limitPrice!;

        // å¯¹äºé™ä»·å•ï¼Œå¦‚æœè§¦å‘ä»·æ ¼å·²ç»æ¯”é™ä»·æ›´å¥½ï¼Œä½¿ç”¨è§¦å‘ä»·æ ¼
        if (order.isLong) {
          // åšå¤š: æƒ³è¦æ›´ä½ä»·æ ¼
          if (triggerPrice < executePrice) {
            executePrice = triggerPrice;
          }
        } else {
          // åšç©º: æƒ³è¦æ›´é«˜ä»·æ ¼
          if (triggerPrice > executePrice) {
            executePrice = triggerPrice;
          }
        }
      }

      // éªŒè¯ Reduce-Only
      if (order.reduceOnly) {
        const validation = validateReduceOnlyOrder(
          order.trader,
          order.token,
          order.isLong,
          order.size
        );
        if (!validation.valid) {
          order.status = "failed";
          order.failReason = validation.reason || "Reduce-only validation failed";
          console.log(`[ConditionalOrder] âŒ Reduce-only validation failed: ${order.id}`);
          broadcastConditionalOrderFailed(order);
          continue;
        }
      }

      // åˆ›å»ºå¹¶æäº¤è®¢å•
      // æ³¨æ„: è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥èµ°å®Œæ•´çš„è®¢å•æµç¨‹
      const result = engine.submitOrder(
        order.trader,
        order.token,
        order.isLong,
        order.size,
        order.leverage,
        order.orderType.includes("LIMIT") ? order.limitPrice! : 0n,
        BigInt(Math.floor(Date.now() / 1000) + 3600), // 1å°æ—¶æœ‰æ•ˆ
        BigInt(Date.now()),
        order.orderType.includes("MARKET") ? OrderType.MARKET : OrderType.LIMIT,
        "0x" as Hex, // æ¡ä»¶å•å·²éªŒè¯ï¼Œæ— éœ€å†æ¬¡ç­¾å
        {
          reduceOnly: order.reduceOnly,
          postOnly: order.postOnly,
        }
      );

      if (result.rejected) {
        order.status = "failed";
        order.failReason = result.rejectReason || "Order rejected";
        console.log(`[ConditionalOrder] âŒ Rejected: ${order.id} - ${result.rejectReason}`);
        broadcastConditionalOrderFailed(order);
        continue;
      }

      order.status = "executed";
      order.executedAt = Date.now();
      order.executionPrice = result.matches.length > 0 ? result.matches[0].matchPrice : executePrice;
      order.updatedAt = Date.now();

      console.log(`[ConditionalOrder] âœ… Executed: ${order.id} @ ${order.executionPrice}`);
      broadcastConditionalOrderExecuted(order);

      // P3: å¤„ç† OCO å…³è” (å¦‚æœæ˜¯ OCO çš„ä¸€éƒ¨åˆ†ï¼Œå–æ¶ˆå¦ä¸€ä¸ªè®¢å•)
      handleOCOOrderExecuted(order.id);

    } catch (e) {
      console.error(`[ConditionalOrder] Execution failed: ${order.id}`, e);
      order.status = "failed";
      order.failReason = e instanceof Error ? e.message : "Unknown error";
      broadcastConditionalOrderFailed(order);
    }
  }
}

/**
 * è·å–ç”¨æˆ·çš„æ¡ä»¶å•
 */
function getUserConditionalOrders(trader: Address): ConditionalOrder[] {
  const normalizedTrader = trader.toLowerCase();
  return Array.from(conditionalOrders.values())
    .filter(o => o.trader.toLowerCase() === normalizedTrader);
}

/**
 * è·å–ä»£å¸çš„æ¡ä»¶å•
 */
function getTokenConditionalOrders(token: Address): ConditionalOrder[] {
  const normalizedToken = token.toLowerCase();
  return Array.from(conditionalOrders.values())
    .filter(o => o.token.toLowerCase() === normalizedToken && o.status === "pending");
}

// æ¡ä»¶å•å¹¿æ’­å‡½æ•°
function broadcastConditionalOrderCreated(order: ConditionalOrder): void {
  broadcast("conditional_order_created", {
    orderId: order.id,
    trader: order.trader,
    token: order.token,
    triggerPrice: order.triggerPrice.toString(),
    triggerDirection: order.triggerDirection,
    orderType: order.orderType,
    isLong: order.isLong,
    size: order.size.toString(),
  });
}

function broadcastConditionalOrderCancelled(order: ConditionalOrder): void {
  broadcast("conditional_order_cancelled", { orderId: order.id, trader: order.trader });
}

function broadcastConditionalOrderTriggered(order: ConditionalOrder, price: bigint): void {
  broadcast("conditional_order_triggered", { orderId: order.id, trader: order.trader, triggerPrice: price.toString() });
}

function broadcastConditionalOrderExecuted(order: ConditionalOrder): void {
  broadcast("conditional_order_executed", {
    orderId: order.id,
    trader: order.trader,
    executionPrice: order.executionPrice?.toString(),
  });
}

function broadcastConditionalOrderFailed(order: ConditionalOrder): void {
  broadcast("conditional_order_failed", {
    orderId: order.id,
    trader: order.trader,
    reason: order.failReason,
  });
}

// ============================================================
// P3: Bracket Orders (æ‹¬å·å•/OCO)
// ============================================================

/**
 * OCO (One Cancels Other) è®¢å•
 * ä¸¤ä¸ªå…³è”çš„æ¡ä»¶å•ï¼Œä¸€ä¸ªæ‰§è¡Œåè‡ªåŠ¨å–æ¶ˆå¦ä¸€ä¸ª
 * å¸¸è§ç”¨ä¾‹:
 * - TP + SL: ä¸€ä¸ªæ­¢ç›ˆæ¡ä»¶å• + ä¸€ä¸ªæ­¢æŸæ¡ä»¶å•
 * - çªç ´ä¹°/å–: å‘ä¸Šçªç ´ä¹°å…¥ + å‘ä¸‹çªç ´å–å‡º
 */
interface OCOOrder {
  id: string;
  trader: Address;
  token: Address;

  // ä¸¤ä¸ªå…³è”çš„è®¢å•
  order1: {
    orderId: string;
    triggerPrice: bigint;
    triggerDirection: TriggerDirection;
    orderType: ConditionalOrderType;
    isLong: boolean;
    size: bigint;
    leverage: bigint;
    limitPrice: bigint | null;
  };

  order2: {
    orderId: string;
    triggerPrice: bigint;
    triggerDirection: TriggerDirection;
    orderType: ConditionalOrderType;
    isLong: boolean;
    size: bigint;
    leverage: bigint;
    limitPrice: bigint | null;
  };

  // çŠ¶æ€
  status: "pending" | "partial" | "completed" | "cancelled";
  executedOrderId: string | null;     // è¢«æ‰§è¡Œçš„è®¢å•ID
  cancelledOrderId: string | null;    // è¢«å–æ¶ˆçš„è®¢å•ID

  createdAt: number;
  updatedAt: number;
}

/**
 * Bracket Order (æ‹¬å·å•)
 * ä¸€ä¸ªå…¥åœºè®¢å• + TP + SLï¼Œä¸‰è€…å…³è”
 * - å…¥åœºæˆäº¤åï¼ŒTP/SL æ¿€æ´»
 * - TP æ‰§è¡Œåå–æ¶ˆ SL
 * - SL æ‰§è¡Œåå–æ¶ˆ TP
 */
interface BracketOrder {
  id: string;
  trader: Address;
  token: Address;

  // å…¥åœºè®¢å•
  entryOrder: {
    orderId: string;
    isLong: boolean;
    size: bigint;
    leverage: bigint;
    price: bigint;           // 0 = å¸‚ä»·
    orderType: OrderType;
  };

  // æ­¢ç›ˆæ¡ä»¶å• (å…¥åœºæˆäº¤åæ¿€æ´»)
  takeProfitOrder: {
    orderId: string | null;  // å…¥åœºååˆ›å»º
    triggerPrice: bigint;
    orderType: ConditionalOrderType;
    limitPrice: bigint | null;
  } | null;

  // æ­¢æŸæ¡ä»¶å• (å…¥åœºæˆäº¤åæ¿€æ´»)
  stopLossOrder: {
    orderId: string | null;  // å…¥åœºååˆ›å»º
    triggerPrice: bigint;
    orderType: ConditionalOrderType;
    limitPrice: bigint | null;
  } | null;

  // çŠ¶æ€
  status: "pending_entry" | "active" | "tp_executed" | "sl_executed" | "cancelled" | "failed";
  entryFilled: boolean;
  entryPrice: bigint | null;
  pairId: string | null;             // å…¥åœºæˆäº¤åçš„ä»“ä½ID

  createdAt: number;
  updatedAt: number;
}

// OCO è®¢å•å­˜å‚¨
const ocoOrders = new Map<string, OCOOrder>();
let ocoIdCounter = 0;

// Bracket è®¢å•å­˜å‚¨
const bracketOrders = new Map<string, BracketOrder>();
let bracketIdCounter = 0;

// OCO æ¡ä»¶å•å…³è” (æ¡ä»¶å•ID -> OCO ID)
const conditionalToOCO = new Map<string, string>();

/**
 * åˆ›å»º OCO è®¢å•
 */
function createOCOOrder(
  trader: Address,
  token: Address,
  order1Config: {
    triggerPrice: bigint;
    triggerDirection: TriggerDirection;
    orderType: ConditionalOrderType;
    isLong: boolean;
    size: bigint;
    leverage: bigint;
    limitPrice?: bigint;
  },
  order2Config: {
    triggerPrice: bigint;
    triggerDirection: TriggerDirection;
    orderType: ConditionalOrderType;
    isLong: boolean;
    size: bigint;
    leverage: bigint;
    limitPrice?: bigint;
  }
): OCOOrder | { error: string } {
  const now = Date.now();

  // åˆ›å»ºä¸¤ä¸ªæ¡ä»¶å•
  const cond1 = createConditionalOrder(
    trader,
    token,
    order1Config.triggerPrice,
    order1Config.triggerDirection,
    order1Config.orderType,
    order1Config.isLong,
    order1Config.size,
    order1Config.leverage,
    order1Config.limitPrice
  );

  if ("error" in cond1) {
    return { error: `Order 1: ${cond1.error}` };
  }

  const cond2 = createConditionalOrder(
    trader,
    token,
    order2Config.triggerPrice,
    order2Config.triggerDirection,
    order2Config.orderType,
    order2Config.isLong,
    order2Config.size,
    order2Config.leverage,
    order2Config.limitPrice
  );

  if ("error" in cond2) {
    // å›æ»šç¬¬ä¸€ä¸ªè®¢å•
    cancelConditionalOrder(cond1.id, trader);
    return { error: `Order 2: ${cond2.error}` };
  }

  const ocoId = `oco_${++ocoIdCounter}_${now}`;

  const oco: OCOOrder = {
    id: ocoId,
    trader,
    token,
    order1: {
      orderId: cond1.id,
      triggerPrice: order1Config.triggerPrice,
      triggerDirection: order1Config.triggerDirection,
      orderType: order1Config.orderType,
      isLong: order1Config.isLong,
      size: order1Config.size,
      leverage: order1Config.leverage,
      limitPrice: order1Config.limitPrice || null,
    },
    order2: {
      orderId: cond2.id,
      triggerPrice: order2Config.triggerPrice,
      triggerDirection: order2Config.triggerDirection,
      orderType: order2Config.orderType,
      isLong: order2Config.isLong,
      size: order2Config.size,
      leverage: order2Config.leverage,
      limitPrice: order2Config.limitPrice || null,
    },
    status: "pending",
    executedOrderId: null,
    cancelledOrderId: null,
    createdAt: now,
    updatedAt: now,
  };

  ocoOrders.set(ocoId, oco);

  // å»ºç«‹å…³è”
  conditionalToOCO.set(cond1.id, ocoId);
  conditionalToOCO.set(cond2.id, ocoId);

  console.log(`[OCO] Created ${ocoId}: order1=${cond1.id}, order2=${cond2.id}`);

  broadcastOCOCreated(oco);

  return oco;
}

/**
 * å¤„ç† OCO ä¸­ä¸€ä¸ªè®¢å•è§¦å‘/æ‰§è¡Œåçš„å¦ä¸€ä¸ªè®¢å•å–æ¶ˆ
 * åœ¨æ¡ä»¶å•æ‰§è¡Œåè°ƒç”¨
 */
function handleOCOOrderExecuted(conditionalOrderId: string): void {
  const ocoId = conditionalToOCO.get(conditionalOrderId);
  if (!ocoId) return;

  const oco = ocoOrders.get(ocoId);
  if (!oco || oco.status !== "pending") return;

  // ç¡®å®šå“ªä¸ªè®¢å•è¢«æ‰§è¡Œäº†
  const otherOrderId = oco.order1.orderId === conditionalOrderId
    ? oco.order2.orderId
    : oco.order1.orderId;

  // å–æ¶ˆå¦ä¸€ä¸ªè®¢å•
  cancelConditionalOrder(otherOrderId, oco.trader);

  oco.status = "completed";
  oco.executedOrderId = conditionalOrderId;
  oco.cancelledOrderId = otherOrderId;
  oco.updatedAt = Date.now();

  console.log(`[OCO] Completed ${ocoId}: executed=${conditionalOrderId}, cancelled=${otherOrderId}`);

  broadcastOCOCompleted(oco);
}

/**
 * å–æ¶ˆ OCO è®¢å•
 */
function cancelOCOOrder(ocoId: string, trader: Address): boolean {
  const oco = ocoOrders.get(ocoId);
  if (!oco) return false;
  if (oco.trader.toLowerCase() !== trader.toLowerCase()) return false;
  if (oco.status !== "pending") return false;

  // å–æ¶ˆä¸¤ä¸ªæ¡ä»¶å•
  cancelConditionalOrder(oco.order1.orderId, trader);
  cancelConditionalOrder(oco.order2.orderId, trader);

  oco.status = "cancelled";
  oco.updatedAt = Date.now();

  // æ¸…ç†å…³è”
  conditionalToOCO.delete(oco.order1.orderId);
  conditionalToOCO.delete(oco.order2.orderId);

  console.log(`[OCO] Cancelled ${ocoId}`);

  broadcastOCOCancelled(oco);

  return true;
}

/**
 * åˆ›å»º Bracket è®¢å•
 */
function createBracketOrder(
  trader: Address,
  token: Address,
  entryConfig: {
    isLong: boolean;
    size: bigint;
    leverage: bigint;
    price: bigint;  // 0 = å¸‚ä»·
  },
  takeProfitPrice: bigint | null,
  stopLossPrice: bigint | null,
  options?: {
    tpOrderType?: ConditionalOrderType;
    slOrderType?: ConditionalOrderType;
    tpLimitPrice?: bigint;
    slLimitPrice?: bigint;
  }
): BracketOrder | { error: string } {
  const now = Date.now();

  // è‡³å°‘éœ€è¦ä¸€ä¸ª TP æˆ– SL
  if (!takeProfitPrice && !stopLossPrice) {
    return { error: "At least one of Take Profit or Stop Loss is required" };
  }

  // éªŒè¯ TP/SL ä»·æ ¼
  const entryPrice = entryConfig.price > 0n ? entryConfig.price : engine.getOrderBook(token).getCurrentPrice();

  if (takeProfitPrice) {
    if (entryConfig.isLong && takeProfitPrice <= entryPrice) {
      return { error: "Take Profit must be above entry price for LONG" };
    }
    if (!entryConfig.isLong && takeProfitPrice >= entryPrice) {
      return { error: "Take Profit must be below entry price for SHORT" };
    }
  }

  if (stopLossPrice) {
    if (entryConfig.isLong && stopLossPrice >= entryPrice) {
      return { error: "Stop Loss must be below entry price for LONG" };
    }
    if (!entryConfig.isLong && stopLossPrice <= entryPrice) {
      return { error: "Stop Loss must be above entry price for SHORT" };
    }
  }

  const bracketId = `bracket_${++bracketIdCounter}_${now}`;
  const entryOrderId = `bracket_entry_${bracketIdCounter}_${now}`;

  const bracket: BracketOrder = {
    id: bracketId,
    trader,
    token,
    entryOrder: {
      orderId: entryOrderId,
      isLong: entryConfig.isLong,
      size: entryConfig.size,
      leverage: entryConfig.leverage,
      price: entryConfig.price,
      orderType: entryConfig.price === 0n ? OrderType.MARKET : OrderType.LIMIT,
    },
    takeProfitOrder: takeProfitPrice ? {
      orderId: null, // å…¥åœºååˆ›å»º
      triggerPrice: takeProfitPrice,
      orderType: options?.tpOrderType || "TRIGGER_MARKET",
      limitPrice: options?.tpLimitPrice || null,
    } : null,
    stopLossOrder: stopLossPrice ? {
      orderId: null, // å…¥åœºååˆ›å»º
      triggerPrice: stopLossPrice,
      orderType: options?.slOrderType || "STOP_MARKET",
      limitPrice: options?.slLimitPrice || null,
    } : null,
    status: "pending_entry",
    entryFilled: false,
    entryPrice: null,
    pairId: null,
    createdAt: now,
    updatedAt: now,
  };

  bracketOrders.set(bracketId, bracket);

  console.log(`[Bracket] Created ${bracketId}: ${entryConfig.isLong ? "LONG" : "SHORT"} @ ${entryConfig.price}, TP=${takeProfitPrice}, SL=${stopLossPrice}`);

  broadcastBracketCreated(bracket);

  return bracket;
}

/**
 * å¤„ç† Bracket è®¢å•å…¥åœºæˆäº¤
 */
function handleBracketEntryFilled(bracketId: string, entryPrice: bigint, pairId: string): void {
  const bracket = bracketOrders.get(bracketId);
  if (!bracket || bracket.status !== "pending_entry") return;

  bracket.entryFilled = true;
  bracket.entryPrice = entryPrice;
  bracket.pairId = pairId;
  bracket.status = "active";
  bracket.updatedAt = Date.now();

  // åˆ›å»º TP æ¡ä»¶å• (åå‘å¹³ä»“)
  if (bracket.takeProfitOrder) {
    const tpCond = createConditionalOrder(
      bracket.trader,
      bracket.token,
      bracket.takeProfitOrder.triggerPrice,
      bracket.entryOrder.isLong ? "ABOVE" : "BELOW", // å¤šå¤´ TP æ˜¯ä»·æ ¼ä¸Šæ¶¨, ç©ºå¤´ TP æ˜¯ä»·æ ¼ä¸‹è·Œ
      bracket.takeProfitOrder.orderType,
      !bracket.entryOrder.isLong, // åå‘å¹³ä»“
      bracket.entryOrder.size,
      bracket.entryOrder.leverage,
      bracket.takeProfitOrder.limitPrice || undefined,
      { reduceOnly: true }
    );

    if (!("error" in tpCond)) {
      bracket.takeProfitOrder.orderId = tpCond.id;
      console.log(`[Bracket] TP created: ${tpCond.id}`);
    }
  }

  // åˆ›å»º SL æ¡ä»¶å• (åå‘å¹³ä»“)
  if (bracket.stopLossOrder) {
    const slCond = createConditionalOrder(
      bracket.trader,
      bracket.token,
      bracket.stopLossOrder.triggerPrice,
      bracket.entryOrder.isLong ? "BELOW" : "ABOVE", // å¤šå¤´ SL æ˜¯ä»·æ ¼ä¸‹è·Œ, ç©ºå¤´ SL æ˜¯ä»·æ ¼ä¸Šæ¶¨
      bracket.stopLossOrder.orderType,
      !bracket.entryOrder.isLong, // åå‘å¹³ä»“
      bracket.entryOrder.size,
      bracket.entryOrder.leverage,
      bracket.stopLossOrder.limitPrice || undefined,
      { reduceOnly: true }
    );

    if (!("error" in slCond)) {
      bracket.stopLossOrder.orderId = slCond.id;
      console.log(`[Bracket] SL created: ${slCond.id}`);
    }
  }

  // å¦‚æœåŒæ—¶æœ‰ TP å’Œ SLï¼Œåˆ›å»º OCO å…³è”
  if (bracket.takeProfitOrder?.orderId && bracket.stopLossOrder?.orderId) {
    // ç®€åŒ–å¤„ç†: æ‰‹åŠ¨å»ºç«‹ OCO å…³è”
    const ocoId = `bracket_oco_${bracketId}`;
    conditionalToOCO.set(bracket.takeProfitOrder.orderId, ocoId);
    conditionalToOCO.set(bracket.stopLossOrder.orderId, ocoId);

    // åˆ›å»ºè™šæ‹Ÿ OCO è®°å½•
    const oco: OCOOrder = {
      id: ocoId,
      trader: bracket.trader,
      token: bracket.token,
      order1: {
        orderId: bracket.takeProfitOrder.orderId,
        triggerPrice: bracket.takeProfitOrder.triggerPrice,
        triggerDirection: bracket.entryOrder.isLong ? "ABOVE" : "BELOW",
        orderType: bracket.takeProfitOrder.orderType,
        isLong: !bracket.entryOrder.isLong,
        size: bracket.entryOrder.size,
        leverage: bracket.entryOrder.leverage,
        limitPrice: bracket.takeProfitOrder.limitPrice,
      },
      order2: {
        orderId: bracket.stopLossOrder.orderId,
        triggerPrice: bracket.stopLossOrder.triggerPrice,
        triggerDirection: bracket.entryOrder.isLong ? "BELOW" : "ABOVE",
        orderType: bracket.stopLossOrder.orderType,
        isLong: !bracket.entryOrder.isLong,
        size: bracket.entryOrder.size,
        leverage: bracket.entryOrder.leverage,
        limitPrice: bracket.stopLossOrder.limitPrice,
      },
      status: "pending",
      executedOrderId: null,
      cancelledOrderId: null,
      createdAt: Date.now(),
      updatedAt: Date.now(),
    };
    ocoOrders.set(ocoId, oco);
  }

  console.log(`[Bracket] Activated ${bracketId}: entry filled @ ${entryPrice}`);

  broadcastBracketActivated(bracket);
}

/**
 * è·å–ç”¨æˆ·çš„ OCO è®¢å•
 */
function getUserOCOOrders(trader: Address): OCOOrder[] {
  const normalizedTrader = trader.toLowerCase();
  return Array.from(ocoOrders.values())
    .filter(o => o.trader.toLowerCase() === normalizedTrader);
}

/**
 * è·å–ç”¨æˆ·çš„ Bracket è®¢å•
 */
function getUserBracketOrders(trader: Address): BracketOrder[] {
  const normalizedTrader = trader.toLowerCase();
  return Array.from(bracketOrders.values())
    .filter(o => o.trader.toLowerCase() === normalizedTrader);
}

// OCO å¹¿æ’­å‡½æ•°
function broadcastOCOCreated(oco: OCOOrder): void {
  broadcast("oco_created", {
    ocoId: oco.id,
    trader: oco.trader,
    order1: oco.order1.orderId,
    order2: oco.order2.orderId,
  });
}

function broadcastOCOCompleted(oco: OCOOrder): void {
  broadcast("oco_completed", {
    ocoId: oco.id,
    trader: oco.trader,
    executedOrderId: oco.executedOrderId,
    cancelledOrderId: oco.cancelledOrderId,
  });
}

function broadcastOCOCancelled(oco: OCOOrder): void {
  broadcast("oco_cancelled", { ocoId: oco.id, trader: oco.trader });
}

// Bracket å¹¿æ’­å‡½æ•°
function broadcastBracketCreated(bracket: BracketOrder): void {
  broadcast("bracket_created", {
    bracketId: bracket.id,
    trader: bracket.trader,
    token: bracket.token,
    isLong: bracket.entryOrder.isLong,
    size: bracket.entryOrder.size.toString(),
    entryPrice: bracket.entryOrder.price.toString(),
    takeProfitPrice: bracket.takeProfitOrder?.triggerPrice.toString() || null,
    stopLossPrice: bracket.stopLossOrder?.triggerPrice.toString() || null,
  });
}

function broadcastBracketActivated(bracket: BracketOrder): void {
  broadcast("bracket_activated", {
    bracketId: bracket.id,
    trader: bracket.trader,
    entryPrice: bracket.entryPrice?.toString(),
    pairId: bracket.pairId,
    tpOrderId: bracket.takeProfitOrder?.orderId,
    slOrderId: bracket.stopLossOrder?.orderId,
  });
}

// ============================================================
// P4: Sub-accounts (å­è´¦æˆ·ç³»ç»Ÿ)
// ============================================================

/**
 * å­è´¦æˆ·
 * - ä¸»è´¦æˆ·å¯åˆ›å»ºå¤šä¸ªå­è´¦æˆ·
 * - æ¯ä¸ªå­è´¦æˆ·æœ‰ç‹¬ç«‹çš„ä¿è¯é‡‘å’Œä»“ä½
 * - å­è´¦æˆ·ä¹‹é—´èµ„é‡‘éš”ç¦»ï¼Œé£é™©éš”ç¦»
 */
interface SubAccount {
  id: string;                      // å­è´¦æˆ·ID
  masterAccount: Address;          // ä¸»è´¦æˆ·åœ°å€
  name: string;                    // å­è´¦æˆ·åç§°
  type: "isolated" | "cross";      // ä¿è¯é‡‘æ¨¡å¼ (é»˜è®¤é€ä»“)
  positionMode: "one_way" | "hedge"; // æŒä»“æ¨¡å¼ (P4.3)

  // èµ„é‡‘ä¿¡æ¯
  balance: bigint;                 // å¯ç”¨ä½™é¢ (USDT, 1e6)
  lockedBalance: bigint;           // é”å®šä½™é¢ (ç”¨äºä¿è¯é‡‘)
  totalEquity: bigint;             // æ€»æƒç›Š = ä½™é¢ + æœªå®ç°ç›ˆäº

  // é£æ§é™åˆ¶
  maxLeverage: number;             // æœ€å¤§æ æ†
  maxPositionValue: bigint;        // æœ€å¤§æŒä»“ä»·å€¼
  maxDrawdown: number;             // æœ€å¤§å›æ’¤é™åˆ¶ (basis points)

  // ç»Ÿè®¡
  totalPnL: bigint;                // ç´¯è®¡ç›ˆäº
  winCount: number;                // ç›ˆåˆ©æ¬¡æ•°
  lossCount: number;               // äºæŸæ¬¡æ•°

  // çŠ¶æ€
  status: "active" | "frozen" | "liquidating" | "closed";
  createdAt: number;
  updatedAt: number;
}

/**
 * å­è´¦æˆ·è½¬è´¦è®°å½•
 */
interface SubAccountTransfer {
  id: string;
  fromAccount: string;             // "master" æˆ–å­è´¦æˆ·ID
  toAccount: string;               // "master" æˆ–å­è´¦æˆ·ID
  amount: bigint;
  timestamp: number;
  status: "pending" | "completed" | "failed";
}

// å­è´¦æˆ·å­˜å‚¨: masterAccount => subAccountId => SubAccount
const subAccounts = new Map<Address, Map<string, SubAccount>>();
let subAccountIdCounter = 0;

// è½¬è´¦è®°å½•
const subAccountTransfers: SubAccountTransfer[] = [];

// å­è´¦æˆ·ä»“ä½æ˜ å°„: subAccountId => Position[]
const subAccountPositions = new Map<string, Position[]>();

/**
 * åˆ›å»ºå­è´¦æˆ·
 */
function createSubAccount(
  masterAccount: Address,
  name: string,
  options?: {
    type?: "isolated" | "cross";
    positionMode?: "one_way" | "hedge";
    maxLeverage?: number;
    maxPositionValue?: bigint;
    maxDrawdown?: number;
  }
): SubAccount {
  const now = Date.now();
  const normalizedMaster = masterAccount.toLowerCase() as Address;

  // è·å–æˆ–åˆ›å»ºä¸»è´¦æˆ·çš„å­è´¦æˆ·æ˜ å°„
  if (!subAccounts.has(normalizedMaster)) {
    subAccounts.set(normalizedMaster, new Map());
  }
  const masterSubAccounts = subAccounts.get(normalizedMaster)!;

  // é™åˆ¶æ¯ä¸ªä¸»è´¦æˆ·æœ€å¤š 20 ä¸ªå­è´¦æˆ·
  if (masterSubAccounts.size >= 20) {
    throw new Error("Maximum sub-accounts limit reached (20)");
  }

  const subAccountId = `sub_${++subAccountIdCounter}_${now}`;

  const subAccount: SubAccount = {
    id: subAccountId,
    masterAccount: normalizedMaster,
    name,
    type: options?.type || "isolated",
    positionMode: options?.positionMode || "one_way",
    balance: 0n,
    lockedBalance: 0n,
    totalEquity: 0n,
    maxLeverage: options?.maxLeverage || 100,
    maxPositionValue: options?.maxPositionValue || BigInt(1000000) * BigInt(1e6), // é»˜è®¤ 100ä¸‡ USDT
    maxDrawdown: options?.maxDrawdown || 5000, // 50%
    totalPnL: 0n,
    winCount: 0,
    lossCount: 0,
    status: "active",
    createdAt: now,
    updatedAt: now,
  };

  masterSubAccounts.set(subAccountId, subAccount);
  subAccountPositions.set(subAccountId, []);

  console.log(`[SubAccount] Created ${subAccountId} for ${normalizedMaster.slice(0, 10)}: ${name}`);

  broadcastSubAccountCreated(subAccount);

  return subAccount;
}

/**
 * è·å–å­è´¦æˆ·
 */
function getSubAccount(subAccountId: string): SubAccount | null {
  for (const [master, accounts] of subAccounts.entries()) {
    if (accounts.has(subAccountId)) {
      return accounts.get(subAccountId)!;
    }
  }
  return null;
}

/**
 * è·å–ä¸»è´¦æˆ·çš„æ‰€æœ‰å­è´¦æˆ·
 */
function getMasterSubAccounts(masterAccount: Address): SubAccount[] {
  const normalizedMaster = masterAccount.toLowerCase() as Address;
  const accounts = subAccounts.get(normalizedMaster);
  return accounts ? Array.from(accounts.values()) : [];
}

/**
 * å­è´¦æˆ·è½¬è´¦ (ä¸»è´¦æˆ· <-> å­è´¦æˆ·)
 */
function transferToSubAccount(
  masterAccount: Address,
  subAccountId: string,
  amount: bigint,
  direction: "deposit" | "withdraw"
): SubAccountTransfer | { error: string } {
  const normalizedMaster = masterAccount.toLowerCase() as Address;
  const subAccount = getSubAccount(subAccountId);

  if (!subAccount) {
    return { error: "Sub-account not found" };
  }

  if (subAccount.masterAccount !== normalizedMaster) {
    return { error: "Sub-account does not belong to this master account" };
  }

  if (subAccount.status !== "active") {
    return { error: `Sub-account is ${subAccount.status}` };
  }

  if (amount <= 0n) {
    return { error: "Amount must be positive" };
  }

  const now = Date.now();
  const transferId = `transfer_${now}_${Math.random().toString(36).slice(2)}`;

  if (direction === "deposit") {
    // ä»ä¸»è´¦æˆ·è½¬å…¥å­è´¦æˆ·
    // æ³¨æ„: å®é™…åº”è¯¥æ£€æŸ¥ä¸»è´¦æˆ·ä½™é¢ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†
    subAccount.balance += amount;
    subAccount.totalEquity += amount;
  } else {
    // ä»å­è´¦æˆ·è½¬å‡ºåˆ°ä¸»è´¦æˆ·
    const availableBalance = subAccount.balance - subAccount.lockedBalance;
    if (amount > availableBalance) {
      return { error: `Insufficient available balance. Available: ${availableBalance}` };
    }
    subAccount.balance -= amount;
    subAccount.totalEquity -= amount;
  }

  subAccount.updatedAt = now;

  const transfer: SubAccountTransfer = {
    id: transferId,
    fromAccount: direction === "deposit" ? "master" : subAccountId,
    toAccount: direction === "deposit" ? subAccountId : "master",
    amount,
    timestamp: now,
    status: "completed",
  };

  subAccountTransfers.push(transfer);

  // ä¿ç•™æœ€è¿‘ 1000 æ¡è½¬è´¦è®°å½•
  if (subAccountTransfers.length > 1000) {
    subAccountTransfers.shift();
  }

  console.log(`[SubAccount] Transfer ${direction}: ${amount} to/from ${subAccountId}`);

  broadcastSubAccountTransfer(subAccount, transfer);

  return transfer;
}

/**
 * æ›´æ–°å­è´¦æˆ·è®¾ç½®
 */
function updateSubAccountSettings(
  subAccountId: string,
  masterAccount: Address,
  settings: {
    name?: string;
    type?: "isolated" | "cross";
    positionMode?: "one_way" | "hedge";
    maxLeverage?: number;
    maxPositionValue?: bigint;
    maxDrawdown?: number;
  }
): SubAccount | { error: string } {
  const normalizedMaster = masterAccount.toLowerCase() as Address;
  const subAccount = getSubAccount(subAccountId);

  if (!subAccount) {
    return { error: "Sub-account not found" };
  }

  if (subAccount.masterAccount !== normalizedMaster) {
    return { error: "Sub-account does not belong to this master account" };
  }

  // æ£€æŸ¥æ˜¯å¦æœ‰æŒä»“ï¼Œæœ‰æŒä»“æ—¶ä¸èƒ½åˆ‡æ¢ä¿è¯é‡‘æ¨¡å¼
  const positions = subAccountPositions.get(subAccountId) || [];
  if (positions.length > 0 && settings.type && settings.type !== subAccount.type) {
    return { error: "Cannot change margin mode while having open positions" };
  }

  // æ›´æ–°è®¾ç½®
  if (settings.name) subAccount.name = settings.name;
  if (settings.type) subAccount.type = settings.type;
  if (settings.positionMode) subAccount.positionMode = settings.positionMode;
  if (settings.maxLeverage) subAccount.maxLeverage = settings.maxLeverage;
  if (settings.maxPositionValue) subAccount.maxPositionValue = settings.maxPositionValue;
  if (settings.maxDrawdown) subAccount.maxDrawdown = settings.maxDrawdown;

  subAccount.updatedAt = Date.now();

  console.log(`[SubAccount] Updated settings for ${subAccountId}`);

  return subAccount;
}

/**
 * å†»ç»“å­è´¦æˆ·
 */
function freezeSubAccount(subAccountId: string, masterAccount: Address): boolean {
  const normalizedMaster = masterAccount.toLowerCase() as Address;
  const subAccount = getSubAccount(subAccountId);

  if (!subAccount || subAccount.masterAccount !== normalizedMaster) {
    return false;
  }

  subAccount.status = "frozen";
  subAccount.updatedAt = Date.now();

  console.log(`[SubAccount] Frozen: ${subAccountId}`);

  return true;
}

/**
 * è§£å†»å­è´¦æˆ·
 */
function unfreezeSubAccount(subAccountId: string, masterAccount: Address): boolean {
  const normalizedMaster = masterAccount.toLowerCase() as Address;
  const subAccount = getSubAccount(subAccountId);

  if (!subAccount || subAccount.masterAccount !== normalizedMaster) {
    return false;
  }

  if (subAccount.status !== "frozen") {
    return false;
  }

  subAccount.status = "active";
  subAccount.updatedAt = Date.now();

  console.log(`[SubAccount] Unfrozen: ${subAccountId}`);

  return true;
}

/**
 * å…³é—­å­è´¦æˆ· (å¿…é¡»æ— ä»“ä½ä¸”ä½™é¢ä¸º 0)
 */
function closeSubAccount(subAccountId: string, masterAccount: Address): boolean | { error: string } {
  const normalizedMaster = masterAccount.toLowerCase() as Address;
  const subAccount = getSubAccount(subAccountId);

  if (!subAccount || subAccount.masterAccount !== normalizedMaster) {
    return { error: "Sub-account not found or not owned" };
  }

  const positions = subAccountPositions.get(subAccountId) || [];
  if (positions.length > 0) {
    return { error: "Cannot close sub-account with open positions" };
  }

  if (subAccount.balance > 0n) {
    return { error: "Please withdraw all balance before closing" };
  }

  subAccount.status = "closed";
  subAccount.updatedAt = Date.now();

  // ç§»é™¤å­è´¦æˆ·
  const masterSubAccounts = subAccounts.get(normalizedMaster);
  if (masterSubAccounts) {
    masterSubAccounts.delete(subAccountId);
  }
  subAccountPositions.delete(subAccountId);

  console.log(`[SubAccount] Closed: ${subAccountId}`);

  return true;
}

/**
 * è·å–å­è´¦æˆ·ç»Ÿè®¡ä¿¡æ¯
 */
function getSubAccountStats(subAccountId: string): {
  balance: bigint;
  lockedBalance: bigint;
  availableBalance: bigint;
  totalEquity: bigint;
  unrealizedPnL: bigint;
  totalPnL: bigint;
  positionCount: number;
  marginUsage: number; // ä¿è¯é‡‘ä½¿ç”¨ç‡ (basis points)
  winRate: number;     // èƒœç‡ (basis points)
} | null {
  const subAccount = getSubAccount(subAccountId);
  if (!subAccount) return null;

  const positions = subAccountPositions.get(subAccountId) || [];

  // è®¡ç®—æœªå®ç°ç›ˆäº
  let unrealizedPnL = 0n;
  for (const pos of positions) {
    unrealizedPnL += BigInt(pos.unrealizedPnL || "0");
  }

  const totalEquity = subAccount.balance + unrealizedPnL;
  const availableBalance = subAccount.balance - subAccount.lockedBalance;
  const marginUsage = subAccount.balance > 0n
    ? Number((subAccount.lockedBalance * 10000n) / subAccount.balance)
    : 0;

  const totalTrades = subAccount.winCount + subAccount.lossCount;
  const winRate = totalTrades > 0
    ? Math.floor((subAccount.winCount * 10000) / totalTrades)
    : 0;

  return {
    balance: subAccount.balance,
    lockedBalance: subAccount.lockedBalance,
    availableBalance,
    totalEquity,
    unrealizedPnL,
    totalPnL: subAccount.totalPnL,
    positionCount: positions.length,
    marginUsage,
    winRate,
  };
}

// å­è´¦æˆ·å¹¿æ’­å‡½æ•°
function broadcastSubAccountCreated(subAccount: SubAccount): void {
  broadcast("sub_account_created", {
    subAccountId: subAccount.id,
    masterAccount: subAccount.masterAccount,
    name: subAccount.name,
    type: subAccount.type,
  });
}

function broadcastSubAccountTransfer(subAccount: SubAccount, transfer: SubAccountTransfer): void {
  broadcast("sub_account_transfer", {
    subAccountId: subAccount.id,
    masterAccount: subAccount.masterAccount,
    transferId: transfer.id,
    fromAccount: transfer.fromAccount,
    toAccount: transfer.toAccount,
    amount: transfer.amount.toString(),
    newBalance: subAccount.balance.toString(),
  });
}

// ============================================================
// P4: Cross-Margin Mode (å…¨ä»“ä¿è¯é‡‘æ¨¡å¼)
// ============================================================

/**
 * å…¨ä»“ä¿è¯é‡‘æ¨¡å¼
 * - é€ä»“æ¨¡å¼ (isolated): æ¯ä¸ªä»“ä½ç‹¬ç«‹ä¿è¯é‡‘ï¼Œäº’ä¸å½±å“
 * - å…¨ä»“æ¨¡å¼ (cross): è´¦æˆ·æ‰€æœ‰å¯ç”¨ä½™é¢å…±äº«ä½œä¸ºä¿è¯é‡‘
 *
 * å…¨ä»“æ¨¡å¼ä¼˜åŠ¿:
 * - ç›ˆåˆ©ä»“ä½å¯ä»¥ä¸ºäºæŸä»“ä½æä¾›ä¿è¯é‡‘
 * - æ›´é«˜çš„èµ„é‡‘åˆ©ç”¨ç‡
 * - é™ä½å•ä¸€ä»“ä½è¢«å¼ºå¹³çš„é£é™©
 *
 * å…¨ä»“æ¨¡å¼é£é™©:
 * - ä¸€ä¸ªä»“ä½çˆ†ä»“å¯èƒ½è¿å¸¦æ‰€æœ‰ä»“ä½
 */

// ç”¨æˆ·ä¿è¯é‡‘æ¨¡å¼è®¾ç½®: trader => margin mode
const userMarginMode = new Map<Address, "isolated" | "cross">();

// ç”¨æˆ·å…¨ä»“ä½™é¢: trader => balance info
interface CrossMarginAccount {
  trader: Address;
  walletBalance: bigint;        // é’±åŒ…ä½™é¢ (USDT, 1e6)
  unrealizedPnL: bigint;        // æœªå®ç°ç›ˆäº
  availableBalance: bigint;     // å¯ç”¨ä½™é¢ (å¯å¼€ä»“)
  marginBalance: bigint;        // ä¿è¯é‡‘ä½™é¢ = é’±åŒ…ä½™é¢ + æœªå®ç°ç›ˆäº
  initialMargin: bigint;        // åˆå§‹ä¿è¯é‡‘ (æ‰€æœ‰ä»“ä½)
  maintenanceMargin: bigint;    // ç»´æŒä¿è¯é‡‘ (æ‰€æœ‰ä»“ä½)
  marginRatio: number;          // ä¿è¯é‡‘ç‡ (basis points)
  updatedAt: number;
}

const crossMarginAccounts = new Map<Address, CrossMarginAccount>();

/**
 * è·å–ç”¨æˆ·ä¿è¯é‡‘æ¨¡å¼
 */
function getUserMarginMode(trader: Address): "isolated" | "cross" {
  const normalizedTrader = trader.toLowerCase() as Address;
  return userMarginMode.get(normalizedTrader) || "isolated";
}

/**
 * è®¾ç½®ç”¨æˆ·ä¿è¯é‡‘æ¨¡å¼
 * æ³¨æ„: åˆ‡æ¢æ¨¡å¼æ—¶å¿…é¡»æ²¡æœ‰æŒä»“
 */
function setUserMarginMode(
  trader: Address,
  mode: "isolated" | "cross"
): { success: boolean; error?: string } {
  const normalizedTrader = trader.toLowerCase() as Address;

  // æ£€æŸ¥æ˜¯å¦æœ‰æŒä»“
  const positions = userPositions.get(normalizedTrader) || [];
  if (positions.length > 0) {
    return { success: false, error: "Cannot change margin mode while having open positions" };
  }

  userMarginMode.set(normalizedTrader, mode);

  // å¦‚æœåˆ‡æ¢åˆ°å…¨ä»“æ¨¡å¼ï¼Œåˆå§‹åŒ–å…¨ä»“è´¦æˆ·
  if (mode === "cross" && !crossMarginAccounts.has(normalizedTrader)) {
    crossMarginAccounts.set(normalizedTrader, {
      trader: normalizedTrader,
      walletBalance: 0n,
      unrealizedPnL: 0n,
      availableBalance: 0n,
      marginBalance: 0n,
      initialMargin: 0n,
      maintenanceMargin: 0n,
      marginRatio: 10000,
      updatedAt: Date.now(),
    });
  }

  console.log(`[MarginMode] ${normalizedTrader.slice(0, 10)} set to ${mode}`);

  broadcastMarginModeChanged(normalizedTrader, mode);

  return { success: true };
}

/**
 * æ›´æ–°å…¨ä»“è´¦æˆ·ä½™é¢
 */
function updateCrossMarginBalance(trader: Address, amount: bigint, action: "deposit" | "withdraw"): boolean {
  const normalizedTrader = trader.toLowerCase() as Address;

  if (getUserMarginMode(normalizedTrader) !== "cross") {
    return false;
  }

  let account = crossMarginAccounts.get(normalizedTrader);
  if (!account) {
    account = {
      trader: normalizedTrader,
      walletBalance: 0n,
      unrealizedPnL: 0n,
      availableBalance: 0n,
      marginBalance: 0n,
      initialMargin: 0n,
      maintenanceMargin: 0n,
      marginRatio: 10000,
      updatedAt: Date.now(),
    };
    crossMarginAccounts.set(normalizedTrader, account);
  }

  if (action === "deposit") {
    account.walletBalance += amount;
  } else {
    if (amount > account.availableBalance) {
      return false; // æç°é‡‘é¢è¶…è¿‡å¯ç”¨ä½™é¢
    }
    account.walletBalance -= amount;
  }

  // é‡æ–°è®¡ç®—
  updateCrossMarginMetrics(normalizedTrader);

  return true;
}

/**
 * æ›´æ–°å…¨ä»“è´¦æˆ·æŒ‡æ ‡ (åœ¨ Risk Engine ä¸­è°ƒç”¨)
 */
function updateCrossMarginMetrics(trader: Address): void {
  const normalizedTrader = trader.toLowerCase() as Address;

  if (getUserMarginMode(normalizedTrader) !== "cross") {
    return;
  }

  let account = crossMarginAccounts.get(normalizedTrader);
  if (!account) return;

  const positions = userPositions.get(normalizedTrader) || [];

  // è®¡ç®—æœªå®ç°ç›ˆäº
  let totalUnrealizedPnL = 0n;
  let totalInitialMargin = 0n;
  let totalMaintenanceMargin = 0n;

  for (const pos of positions) {
    totalUnrealizedPnL += BigInt(pos.unrealizedPnL || "0");
    totalInitialMargin += BigInt(pos.collateral || "0");
    totalMaintenanceMargin += BigInt(pos.maintenanceMargin || "0");
  }

  account.unrealizedPnL = totalUnrealizedPnL;
  account.marginBalance = account.walletBalance + totalUnrealizedPnL;
  account.initialMargin = totalInitialMargin;
  account.maintenanceMargin = totalMaintenanceMargin;

  // å¯ç”¨ä½™é¢ = ä¿è¯é‡‘ä½™é¢ - åˆå§‹ä¿è¯é‡‘
  // ä½†å¯ç”¨ä½™é¢ä¸èƒ½ä¸ºè´Ÿ
  const availableRaw = account.marginBalance - account.initialMargin;
  account.availableBalance = availableRaw > 0n ? availableRaw : 0n;

  // ä¿è¯é‡‘ç‡ = ç»´æŒä¿è¯é‡‘ / ä¿è¯é‡‘ä½™é¢ * 10000
  // å½“ä¿è¯é‡‘ç‡ >= 10000 (100%) æ—¶è§¦å‘å¼ºå¹³
  if (account.marginBalance > 0n) {
    account.marginRatio = Number((account.maintenanceMargin * 10000n) / account.marginBalance);
  } else if (positions.length > 0) {
    account.marginRatio = 99999; // æ²¡æœ‰ä¿è¯é‡‘ä½†æœ‰ä»“ä½ = æåº¦å±é™©
  } else {
    account.marginRatio = 0; // æ²¡æœ‰ä»“ä½
  }

  account.updatedAt = Date.now();
}

/**
 * æ£€æŸ¥å…¨ä»“è´¦æˆ·æ˜¯å¦å¯è¢«å¼ºå¹³
 */
function isCrossMarginLiquidatable(trader: Address): {
  liquidatable: boolean;
  marginRatio: number;
  deficit: bigint;
} {
  const normalizedTrader = trader.toLowerCase() as Address;
  const account = crossMarginAccounts.get(normalizedTrader);

  if (!account) {
    return { liquidatable: false, marginRatio: 0, deficit: 0n };
  }

  // å…¨ä»“æ¨¡å¼ä¸‹ï¼Œå½“ä¿è¯é‡‘ç‡ >= 100% æ—¶è§¦å‘å¼ºå¹³
  // å³ ç»´æŒä¿è¯é‡‘ >= ä¿è¯é‡‘ä½™é¢
  const liquidatable = account.marginRatio >= 10000;
  const deficit = account.maintenanceMargin - account.marginBalance;

  return {
    liquidatable,
    marginRatio: account.marginRatio,
    deficit: deficit > 0n ? deficit : 0n,
  };
}

/**
 * å…¨ä»“æ¨¡å¼ä¸‹çš„ä»“ä½ä¿è¯é‡‘è®¡ç®—
 * å…¨ä»“æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰ä»“ä½å…±äº«è´¦æˆ·ä¿è¯é‡‘
 */
function calculateCrossMarginForPosition(
  trader: Address,
  positionValue: bigint,
  leverage: bigint
): { initialMargin: bigint; canOpen: boolean; reason?: string } {
  const normalizedTrader = trader.toLowerCase() as Address;
  const account = crossMarginAccounts.get(normalizedTrader);

  if (!account) {
    return { initialMargin: 0n, canOpen: false, reason: "Cross margin account not found" };
  }

  // è®¡ç®—æ‰€éœ€åˆå§‹ä¿è¯é‡‘
  // åˆå§‹ä¿è¯é‡‘ = ä»“ä½ä»·å€¼ / æ æ†
  const initialMargin = positionValue * 10000n / leverage;

  // æ£€æŸ¥å¯ç”¨ä½™é¢æ˜¯å¦è¶³å¤Ÿ
  if (initialMargin > account.availableBalance) {
    return {
      initialMargin,
      canOpen: false,
      reason: `Insufficient available balance. Required: ${initialMargin}, Available: ${account.availableBalance}`
    };
  }

  return { initialMargin, canOpen: true };
}

/**
 * è·å–å…¨ä»“è´¦æˆ·ä¿¡æ¯
 */
function getCrossMarginAccount(trader: Address): CrossMarginAccount | null {
  const normalizedTrader = trader.toLowerCase() as Address;
  return crossMarginAccounts.get(normalizedTrader) || null;
}

/**
 * å…¨ä»“æ¨¡å¼å¼ºå¹³å¤„ç†
 * æŒ‰ ADL è¯„åˆ†é¡ºåºå¹³ä»“ï¼Œç›´åˆ°ä¿è¯é‡‘ç‡æ¢å¤å¥åº·
 */
async function processCrossMarginLiquidation(trader: Address): Promise<void> {
  const normalizedTrader = trader.toLowerCase() as Address;
  const account = crossMarginAccounts.get(normalizedTrader);

  if (!account) return;

  const checkResult = isCrossMarginLiquidatable(normalizedTrader);
  if (!checkResult.liquidatable) return;

  console.log(`[CrossMargin] Liquidation triggered for ${normalizedTrader.slice(0, 10)}: marginRatio=${checkResult.marginRatio}bp`);

  const positions = userPositions.get(normalizedTrader) || [];
  if (positions.length === 0) return;

  // æŒ‰äºæŸç¨‹åº¦æ’åº (äºæŸæœ€å¤šçš„å…ˆå¹³)
  const sortedPositions = [...positions].sort((a, b) => {
    const pnlA = BigInt(a.unrealizedPnL || "0");
    const pnlB = BigInt(b.unrealizedPnL || "0");
    return Number(pnlA - pnlB); // äºæŸæœ€å¤šçš„åœ¨å‰é¢
  });

  // é€ä¸ªå¹³ä»“ç›´åˆ°ä¿è¯é‡‘ç‡æ¢å¤
  for (const pos of sortedPositions) {
    const stillLiquidatable = isCrossMarginLiquidatable(normalizedTrader);
    if (!stillLiquidatable.liquidatable) {
      console.log(`[CrossMargin] Margin ratio recovered: ${stillLiquidatable.marginRatio}bp`);
      break;
    }

    console.log(`[CrossMargin] Liquidating position ${pos.pairId}: unrealizedPnL=${pos.unrealizedPnL}`);

    // æ ‡è®°ä»“ä½ä¸ºå¼ºå¹³
    pos.status = "liquidating";

    // æ¨¡æ‹Ÿå¹³ä»“ (å®é™…åº”è¯¥èµ°å®Œæ•´å¹³ä»“æµç¨‹)
    const currentPrice = BigInt(pos.markPrice);
    const pnl = BigInt(pos.unrealizedPnL || "0");

    // æ›´æ–°è´¦æˆ·
    account.walletBalance += pnl; // äºæŸæ‰£é™¤
    if (account.walletBalance < 0n) account.walletBalance = 0n;

    // ç§»é™¤ä»“ä½
    const remainingPositions = positions.filter(p => p.pairId !== pos.pairId);
    userPositions.set(normalizedTrader, remainingPositions);

    // é‡æ–°è®¡ç®—æŒ‡æ ‡
    updateCrossMarginMetrics(normalizedTrader);

    broadcastCrossMarginLiquidation(normalizedTrader, pos, currentPrice, pnl);
  }
}

// å…¨ä»“æ¨¡å¼å¹¿æ’­å‡½æ•°
function broadcastMarginModeChanged(trader: Address, mode: "isolated" | "cross"): void {
  broadcast("margin_mode_changed", { trader, mode });
}

function broadcastCrossMarginLiquidation(trader: Address, position: Position, price: bigint, pnl: bigint): void {
  broadcast("cross_margin_liquidation", {
    trader,
    pairId: position.pairId,
    token: position.token,
    isLong: position.isLong,
    size: position.size,
    liquidationPrice: price.toString(),
    realizedPnL: pnl.toString(),
  });
}

// ============================================================
// P4: Position Mode (æŒä»“æ¨¡å¼)
// ============================================================

/**
 * æŒä»“æ¨¡å¼
 * - å•å‘æ¨¡å¼ (one_way): åŒä¸€ä»£å¸åªèƒ½æœ‰ä¸€ä¸ªæ–¹å‘çš„ä»“ä½
 *   å¼€åå‘ä»“ä½ä¼šå…ˆå¹³æ‰åŸä»“ä½
 * - å¯¹å†²æ¨¡å¼ (hedge): åŒä¸€ä»£å¸å¯ä»¥åŒæ—¶æŒæœ‰å¤šç©ºä»“ä½
 *   æ”¯æŒé”ä»“ç­–ç•¥
 */

// ç”¨æˆ·æŒä»“æ¨¡å¼: trader => position mode
const userPositionMode = new Map<Address, "one_way" | "hedge">();

/**
 * è·å–ç”¨æˆ·æŒä»“æ¨¡å¼
 */
function getUserPositionMode(trader: Address): "one_way" | "hedge" {
  const normalizedTrader = trader.toLowerCase() as Address;
  return userPositionMode.get(normalizedTrader) || "one_way";
}

/**
 * è®¾ç½®ç”¨æˆ·æŒä»“æ¨¡å¼
 */
function setUserPositionMode(
  trader: Address,
  mode: "one_way" | "hedge"
): { success: boolean; error?: string } {
  const normalizedTrader = trader.toLowerCase() as Address;

  // æ£€æŸ¥æ˜¯å¦æœ‰æŒä»“
  const positions = userPositions.get(normalizedTrader) || [];
  if (positions.length > 0) {
    return { success: false, error: "Cannot change position mode while having open positions" };
  }

  userPositionMode.set(normalizedTrader, mode);

  console.log(`[PositionMode] ${normalizedTrader.slice(0, 10)} set to ${mode}`);

  broadcastPositionModeChanged(normalizedTrader, mode);

  return { success: true };
}

/**
 * æ£€æŸ¥å¼€ä»“æ˜¯å¦ç¬¦åˆæŒä»“æ¨¡å¼
 */
function validatePositionModeForOpen(
  trader: Address,
  token: Address,
  isLong: boolean
): { valid: boolean; existingPosition?: Position; action?: "open" | "close_and_open" | "add" } {
  const normalizedTrader = trader.toLowerCase() as Address;
  const normalizedToken = token.toLowerCase() as Address;
  const mode = getUserPositionMode(normalizedTrader);

  const positions = userPositions.get(normalizedTrader) || [];
  const existingPosition = positions.find(p =>
    p.token.toLowerCase() === normalizedToken
  );

  if (!existingPosition) {
    // æ²¡æœ‰ç°æœ‰ä»“ä½ï¼Œå¯ä»¥å¼€ä»“
    return { valid: true, action: "open" };
  }

  if (mode === "hedge") {
    // å¯¹å†²æ¨¡å¼: æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒæ–¹å‘ä»“ä½
    const sameDirectionPosition = positions.find(p =>
      p.token.toLowerCase() === normalizedToken && p.isLong === isLong
    );

    if (sameDirectionPosition) {
      // åŒæ–¹å‘åŠ ä»“
      return { valid: true, existingPosition: sameDirectionPosition, action: "add" };
    } else {
      // åå‘å¼€ä»“ (å¯¹å†²)
      return { valid: true, action: "open" };
    }
  } else {
    // å•å‘æ¨¡å¼
    if (existingPosition.isLong === isLong) {
      // åŒæ–¹å‘åŠ ä»“
      return { valid: true, existingPosition, action: "add" };
    } else {
      // åå‘å¼€ä»“ = å…ˆå¹³ä»“å†å¼€åå‘
      return { valid: true, existingPosition, action: "close_and_open" };
    }
  }
}

/**
 * è·å–ç”¨æˆ·åœ¨æŒ‡å®šä»£å¸ä¸Šçš„æ‰€æœ‰ä»“ä½ (å¯¹å†²æ¨¡å¼ä¸‹å¯èƒ½æœ‰å¤šä¸ª)
 */
function getUserTokenPositions(trader: Address, token: Address): Position[] {
  const normalizedTrader = trader.toLowerCase() as Address;
  const normalizedToken = token.toLowerCase() as Address;

  const positions = userPositions.get(normalizedTrader) || [];
  return positions.filter(p => p.token.toLowerCase() === normalizedToken);
}

/**
 * å¯¹å†²æ¨¡å¼ä¸‹è·å–å‡€ä»“ä½
 */
function getNetPosition(trader: Address, token: Address): {
  netSize: bigint;
  netDirection: "long" | "short" | "neutral";
  longSize: bigint;
  shortSize: bigint;
} {
  const positions = getUserTokenPositions(trader, token);

  let longSize = 0n;
  let shortSize = 0n;

  for (const pos of positions) {
    if (pos.isLong) {
      longSize += BigInt(pos.size);
    } else {
      shortSize += BigInt(pos.size);
    }
  }

  const netSize = longSize - shortSize;
  let netDirection: "long" | "short" | "neutral";

  if (netSize > 0n) {
    netDirection = "long";
  } else if (netSize < 0n) {
    netDirection = "short";
  } else {
    netDirection = "neutral";
  }

  return {
    netSize: netSize > 0n ? netSize : -netSize,
    netDirection,
    longSize,
    shortSize,
  };
}

function broadcastPositionModeChanged(trader: Address, mode: "one_way" | "hedge"): void {
  broadcast("position_mode_changed", { trader, mode });
}

// ============================================================
// P4: TWAP Orders (æ—¶é—´åŠ æƒå¹³å‡ä»·æ ¼è®¢å•)
// ============================================================

/**
 * TWAP è®¢å• (Time-Weighted Average Price)
 * å°†å¤§é¢è®¢å•æ‹†åˆ†æˆå¤šä¸ªå°è®¢å•ï¼Œåœ¨æŒ‡å®šæ—¶é—´å†…å‡åŒ€æ‰§è¡Œ
 * å‡å°‘å¸‚åœºå†²å‡»ï¼Œè·å¾—æ›´å¥½çš„å¹³å‡æˆäº¤ä»·æ ¼
 */
interface TWAPOrder {
  id: string;
  trader: Address;
  token: Address;

  // è®¢å•å‚æ•°
  isLong: boolean;
  totalSize: bigint;            // æ€»æ•°é‡
  leverage: bigint;
  priceLimit: bigint | null;    // ä»·æ ¼é™åˆ¶ (0=æ— é™åˆ¶)

  // TWAP å‚æ•°
  duration: number;             // æ‰§è¡Œæ—¶é•¿ (æ¯«ç§’)
  intervals: number;            // æ‹†åˆ†æ¬¡æ•°
  intervalMs: number;           // æ¯æ¬¡é—´éš” (æ¯«ç§’)
  sizePerInterval: bigint;      // æ¯æ¬¡æ‰§è¡Œæ•°é‡
  randomize: boolean;           // æ˜¯å¦éšæœºåŒ–æ‰§è¡Œæ—¶é—´ (Â±10%)

  // æ‰§è¡ŒçŠ¶æ€
  status: "pending" | "running" | "paused" | "completed" | "cancelled" | "failed";
  startTime: number | null;
  endTime: number | null;
  nextExecutionTime: number | null;

  // æ‰§è¡Œè¿›åº¦
  executedSize: bigint;         // å·²æ‰§è¡Œæ•°é‡
  executedCount: number;        // å·²æ‰§è¡Œæ¬¡æ•°
  avgExecutionPrice: bigint;    // å¹³å‡æ‰§è¡Œä»·æ ¼
  totalValue: bigint;           // ç´¯è®¡æˆäº¤é‡‘é¢

  // æ‰§è¡Œå†å²
  executions: {
    timestamp: number;
    size: bigint;
    price: bigint;
    success: boolean;
    error?: string;
  }[];

  // é™„åŠ é€‰é¡¹
  reduceOnly: boolean;
  postOnly: boolean;

  createdAt: number;
  updatedAt: number;
}

// TWAP è®¢å•å­˜å‚¨
const twapOrders = new Map<string, TWAPOrder>();
let twapOrderIdCounter = 0;

// TWAP æ‰§è¡Œå®šæ—¶å™¨
const twapTimers = new Map<string, NodeJS.Timeout>();

/**
 * åˆ›å»º TWAP è®¢å•
 */
function createTWAPOrder(
  trader: Address,
  token: Address,
  isLong: boolean,
  totalSize: bigint,
  leverage: bigint,
  duration: number,            // æ‰§è¡Œæ—¶é•¿ (ç§’)
  intervals: number,           // æ‹†åˆ†æ¬¡æ•°
  options?: {
    priceLimit?: bigint;
    randomize?: boolean;
    reduceOnly?: boolean;
    postOnly?: boolean;
    startImmediately?: boolean;
  }
): TWAPOrder | { error: string } {
  const now = Date.now();

  // éªŒè¯å‚æ•°
  if (intervals < 2 || intervals > 100) {
    return { error: "Intervals must be between 2 and 100" };
  }

  if (duration < 60 || duration > 86400) {
    return { error: "Duration must be between 60 seconds and 24 hours" };
  }

  const durationMs = duration * 1000;
  const intervalMs = Math.floor(durationMs / intervals);
  const sizePerInterval = totalSize / BigInt(intervals);

  // æ¯æ¬¡æ‰§è¡Œæ•°é‡ä¸èƒ½å¤ªå°
  if (sizePerInterval < 10n ** 15n) {
    return { error: "Size per interval too small (minimum 0.001 tokens)" };
  }

  const orderId = `twap_${++twapOrderIdCounter}_${now}`;

  const order: TWAPOrder = {
    id: orderId,
    trader,
    token,
    isLong,
    totalSize,
    leverage,
    priceLimit: options?.priceLimit || null,
    duration: durationMs,
    intervals,
    intervalMs,
    sizePerInterval,
    randomize: options?.randomize ?? true,
    status: "pending",
    startTime: null,
    endTime: null,
    nextExecutionTime: null,
    executedSize: 0n,
    executedCount: 0,
    avgExecutionPrice: 0n,
    totalValue: 0n,
    executions: [],
    reduceOnly: options?.reduceOnly || false,
    postOnly: options?.postOnly || false,
    createdAt: now,
    updatedAt: now,
  };

  twapOrders.set(orderId, order);

  console.log(`[TWAP] Created ${orderId}: ${isLong ? "LONG" : "SHORT"} ${totalSize} over ${duration}s in ${intervals} intervals`);

  // å¦‚æœç«‹å³å¼€å§‹
  if (options?.startImmediately !== false) {
    startTWAPOrder(orderId);
  }

  broadcastTWAPCreated(order);

  return order;
}

/**
 * å¼€å§‹æ‰§è¡Œ TWAP è®¢å•
 */
function startTWAPOrder(orderId: string): boolean {
  const order = twapOrders.get(orderId);
  if (!order) return false;

  if (order.status !== "pending" && order.status !== "paused") {
    return false;
  }

  const now = Date.now();
  order.status = "running";
  order.startTime = order.startTime || now;
  order.updatedAt = now;

  // è®¡ç®—ä¸‹ä¸€æ¬¡æ‰§è¡Œæ—¶é—´
  scheduleNextTWAPExecution(order);

  console.log(`[TWAP] Started ${orderId}`);

  broadcastTWAPStarted(order);

  return true;
}

/**
 * æš‚åœ TWAP è®¢å•
 */
function pauseTWAPOrder(orderId: string): boolean {
  const order = twapOrders.get(orderId);
  if (!order || order.status !== "running") return false;

  order.status = "paused";
  order.updatedAt = Date.now();

  // å–æ¶ˆå®šæ—¶å™¨
  const timer = twapTimers.get(orderId);
  if (timer) {
    clearTimeout(timer);
    twapTimers.delete(orderId);
  }

  console.log(`[TWAP] Paused ${orderId}`);

  broadcastTWAPPaused(order);

  return true;
}

/**
 * å–æ¶ˆ TWAP è®¢å•
 */
function cancelTWAPOrder(orderId: string, trader: Address): boolean {
  const order = twapOrders.get(orderId);
  if (!order) return false;

  if (order.trader.toLowerCase() !== trader.toLowerCase()) {
    return false;
  }

  if (order.status === "completed" || order.status === "cancelled") {
    return false;
  }

  order.status = "cancelled";
  order.endTime = Date.now();
  order.updatedAt = Date.now();

  // å–æ¶ˆå®šæ—¶å™¨
  const timer = twapTimers.get(orderId);
  if (timer) {
    clearTimeout(timer);
    twapTimers.delete(orderId);
  }

  console.log(`[TWAP] Cancelled ${orderId}: executed ${order.executedCount}/${order.intervals}`);

  broadcastTWAPCancelled(order);

  return true;
}

/**
 * è°ƒåº¦ä¸‹ä¸€æ¬¡ TWAP æ‰§è¡Œ
 */
function scheduleNextTWAPExecution(order: TWAPOrder): void {
  if (order.status !== "running") return;

  // æ£€æŸ¥æ˜¯å¦å·²å®Œæˆ
  if (order.executedCount >= order.intervals) {
    completeTWAPOrder(order);
    return;
  }

  // è®¡ç®—ä¸‹ä¸€æ¬¡æ‰§è¡Œæ—¶é—´
  let delay = order.intervalMs;

  // éšæœºåŒ–æ‰§è¡Œæ—¶é—´ (Â±10%)
  if (order.randomize) {
    const variance = delay * 0.1;
    delay = delay + Math.floor((Math.random() - 0.5) * 2 * variance);
  }

  order.nextExecutionTime = Date.now() + delay;

  // è®¾ç½®å®šæ—¶å™¨
  const timer = setTimeout(() => {
    executeTWAPSlice(order);
  }, delay);

  twapTimers.set(order.id, timer);
}

/**
 * æ‰§è¡Œ TWAP å•æ¬¡åˆ‡ç‰‡
 */
async function executeTWAPSlice(order: TWAPOrder): Promise<void> {
  if (order.status !== "running") return;

  const now = Date.now();
  const execution: TWAPOrder["executions"][0] = {
    timestamp: now,
    size: order.sizePerInterval,
    price: 0n,
    success: false,
  };

  try {
    // è·å–å½“å‰ä»·æ ¼
    const orderBook = engine.getOrderBook(order.token);
    const currentPrice = orderBook.getCurrentPrice();

    // æ£€æŸ¥ä»·æ ¼é™åˆ¶
    if (order.priceLimit && order.priceLimit > 0n) {
      if (order.isLong && currentPrice > order.priceLimit) {
        execution.error = "Price above limit";
        console.log(`[TWAP] ${order.id} slice skipped: price ${currentPrice} > limit ${order.priceLimit}`);
      } else if (!order.isLong && currentPrice < order.priceLimit) {
        execution.error = "Price below limit";
        console.log(`[TWAP] ${order.id} slice skipped: price ${currentPrice} < limit ${order.priceLimit}`);
      }
    }

    if (!execution.error) {
      // è®¡ç®—æœ¬æ¬¡æ‰§è¡Œçš„å®é™…æ•°é‡ (æœ€åä¸€æ¬¡æ‰§è¡Œå‰©ä½™å…¨éƒ¨)
      const remainingSize = order.totalSize - order.executedSize;
      const sliceSize = order.executedCount === order.intervals - 1
        ? remainingSize
        : order.sizePerInterval;

      // æ‰§è¡Œè®¢å•
      const result = engine.submitOrder(
        order.trader,
        order.token,
        order.isLong,
        sliceSize,
        order.leverage,
        0n, // å¸‚ä»·
        BigInt(Math.floor(Date.now() / 1000) + 3600),
        BigInt(Date.now()),
        OrderType.MARKET,
        "0x" as Hex,
        {
          reduceOnly: order.reduceOnly,
          postOnly: order.postOnly,
        }
      );

      if (result.rejected) {
        execution.error = result.rejectReason || "Order rejected";
      } else {
        execution.success = true;
        execution.price = result.matches.length > 0 ? result.matches[0].matchPrice : currentPrice;
        execution.size = result.order.filledSize;

        // æ›´æ–°è®¢å•ç»Ÿè®¡
        order.executedSize += execution.size;
        order.executedCount++;
        order.totalValue += execution.size * execution.price / (10n ** 18n);

        // æ›´æ–°å¹³å‡ä»·æ ¼
        if (order.executedSize > 0n) {
          order.avgExecutionPrice = order.totalValue * (10n ** 18n) / order.executedSize;
        }

        console.log(`[TWAP] ${order.id} slice ${order.executedCount}/${order.intervals}: ${execution.size} @ ${execution.price}`);
      }
    }
  } catch (e) {
    execution.error = e instanceof Error ? e.message : "Unknown error";
    console.error(`[TWAP] ${order.id} slice failed:`, e);
  }

  order.executions.push(execution);
  order.updatedAt = now;

  broadcastTWAPExecution(order, execution);

  // è°ƒåº¦ä¸‹ä¸€æ¬¡æ‰§è¡Œ
  scheduleNextTWAPExecution(order);
}

/**
 * å®Œæˆ TWAP è®¢å•
 */
function completeTWAPOrder(order: TWAPOrder): void {
  order.status = "completed";
  order.endTime = Date.now();
  order.updatedAt = Date.now();

  // æ¸…ç†å®šæ—¶å™¨
  const timer = twapTimers.get(order.id);
  if (timer) {
    clearTimeout(timer);
    twapTimers.delete(order.id);
  }

  const successfulExecutions = order.executions.filter(e => e.success).length;
  console.log(`[TWAP] Completed ${order.id}: ${successfulExecutions}/${order.intervals} successful, avg price: ${order.avgExecutionPrice}`);

  broadcastTWAPCompleted(order);
}

/**
 * è·å–ç”¨æˆ·çš„ TWAP è®¢å•
 */
function getUserTWAPOrders(trader: Address): TWAPOrder[] {
  const normalizedTrader = trader.toLowerCase();
  return Array.from(twapOrders.values())
    .filter(o => o.trader.toLowerCase() === normalizedTrader);
}

/**
 * è·å– TWAP è®¢å•
 */
function getTWAPOrder(orderId: string): TWAPOrder | null {
  return twapOrders.get(orderId) || null;
}

// TWAP å¹¿æ’­å‡½æ•°
function broadcastTWAPCreated(order: TWAPOrder): void {
  broadcast("twap_created", {
    orderId: order.id,
    trader: order.trader,
    token: order.token,
    isLong: order.isLong,
    totalSize: order.totalSize.toString(),
    duration: order.duration,
    intervals: order.intervals,
  });
}

function broadcastTWAPStarted(order: TWAPOrder): void {
  broadcast("twap_started", { orderId: order.id, trader: order.trader, startTime: order.startTime });
}

function broadcastTWAPPaused(order: TWAPOrder): void {
  broadcast("twap_paused", { orderId: order.id, trader: order.trader });
}

function broadcastTWAPCancelled(order: TWAPOrder): void {
  broadcast("twap_cancelled", {
    orderId: order.id,
    trader: order.trader,
    executedSize: order.executedSize.toString(),
    executedCount: order.executedCount,
  });
}

function broadcastTWAPExecution(order: TWAPOrder, execution: TWAPOrder["executions"][0]): void {
  broadcast("twap_execution", {
    orderId: order.id,
    trader: order.trader,
    executionNumber: order.executedCount,
    totalExecutions: order.intervals,
    size: execution.size.toString(),
    price: execution.price.toString(),
    success: execution.success,
    error: execution.error,
    progress: `${order.executedCount}/${order.intervals}`,
  });
}

function broadcastTWAPCompleted(order: TWAPOrder): void {
  broadcast("twap_completed", {
    orderId: order.id,
    trader: order.trader,
    totalSize: order.totalSize.toString(),
    executedSize: order.executedSize.toString(),
    avgPrice: order.avgExecutionPrice.toString(),
    duration: order.endTime! - order.startTime!,
  });
}

// ============================================================
// P5: Referral System (æ¨èè¿”ä½£ç³»ç»Ÿ)
// ============================================================

/**
 * æ¨èè¿”ä½£ç³»ç»Ÿ
 * - ç”¨æˆ·å¯ç”Ÿæˆé‚€è¯·ç é‚€è¯·æ–°ç”¨æˆ·
 * - è¢«é‚€è¯·ç”¨æˆ·äº¤æ˜“æ—¶ï¼Œé‚€è¯·äººè·å¾—æ‰‹ç»­è´¹è¿”ä½£
 * - æ”¯æŒå¤šçº§è¿”ä½£ (æœ€å¤š 2 çº§)
 * - è¿”ä½£æ¯”ä¾‹å¯é…ç½®
 */

// è¿”ä½£é…ç½®
const REFERRAL_CONFIG = {
  // ä¸€çº§è¿”ä½£: ç›´æ¥é‚€è¯·äººè·å¾—è¢«é‚€è¯·äººæ‰‹ç»­è´¹çš„ 30%
  level1Rate: 3000,  // 30% (basis points)
  // äºŒçº§è¿”ä½£: é‚€è¯·äººçš„é‚€è¯·äººè·å¾— 10%
  level2Rate: 1000,  // 10% (basis points)
  // æœ€ä½æç°é‡‘é¢ (USDT, 1e6)
  minWithdrawAmount: 10n * 10n ** 6n,  // $10
  // é‚€è¯·ç é•¿åº¦
  codeLength: 8,
};

/**
 * æ¨èäººä¿¡æ¯
 */
interface Referrer {
  address: Address;
  code: string;                      // é‚€è¯·ç 
  level1Referrals: Address[];        // ç›´æ¥é‚€è¯·çš„ç”¨æˆ·
  level2Referrals: Address[];        // äºŒçº§é‚€è¯·çš„ç”¨æˆ·

  // è¿”ä½£ç»Ÿè®¡
  totalEarnings: bigint;             // ç´¯è®¡è¿”ä½£æ”¶å…¥
  pendingEarnings: bigint;           // å¾…æå–è¿”ä½£
  withdrawnEarnings: bigint;         // å·²æå–è¿”ä½£

  // æ˜ç»†
  level1Earnings: bigint;            // ä¸€çº§è¿”ä½£æ”¶å…¥
  level2Earnings: bigint;            // äºŒçº§è¿”ä½£æ”¶å…¥

  // ç»Ÿè®¡
  totalTradesReferred: number;       // è¢«é‚€è¯·ç”¨æˆ·æ€»äº¤æ˜“æ¬¡æ•°
  totalVolumeReferred: bigint;       // è¢«é‚€è¯·ç”¨æˆ·æ€»äº¤æ˜“é¢

  createdAt: number;
  updatedAt: number;
}

/**
 * è¢«é‚€è¯·äººä¿¡æ¯
 */
interface Referee {
  address: Address;
  referrerCode: string;              // ä½¿ç”¨çš„é‚€è¯·ç 
  referrer: Address;                 // ç›´æ¥é‚€è¯·äºº
  level2Referrer: Address | null;    // äºŒçº§é‚€è¯·äºº (é‚€è¯·äººçš„é‚€è¯·äºº)

  // è´¡çŒ®ç»Ÿè®¡
  totalFeesPaid: bigint;             // ç´¯è®¡æ”¯ä»˜æ‰‹ç»­è´¹
  totalCommissionGenerated: bigint;  // ç´¯è®¡äº§ç”Ÿçš„è¿”ä½£

  joinedAt: number;
}

/**
 * è¿”ä½£è®°å½•
 */
interface ReferralCommission {
  id: string;
  referrer: Address;                 // è·å¾—è¿”ä½£çš„äºº
  referee: Address;                  // äº§ç”Ÿè¿”ä½£çš„äº¤æ˜“è€…
  level: 1 | 2;                      // è¿”ä½£çº§åˆ«
  tradeId: string;                   // å…³è”çš„äº¤æ˜“ID
  tradeFee: bigint;                  // åŸå§‹äº¤æ˜“æ‰‹ç»­è´¹
  commissionAmount: bigint;          // è¿”ä½£é‡‘é¢
  commissionRate: number;            // è¿”ä½£æ¯”ä¾‹ (basis points)
  timestamp: number;
  status: "pending" | "credited" | "withdrawn";
}

// æ¨èäººå­˜å‚¨: address => Referrer
const referrers = new Map<Address, Referrer>();

// é‚€è¯·ç æ˜ å°„: code => address
const referralCodes = new Map<string, Address>();

// è¢«é‚€è¯·äººå­˜å‚¨: address => Referee
const referees = new Map<Address, Referee>();

// è¿”ä½£è®°å½•
const referralCommissions: ReferralCommission[] = [];
let commissionIdCounter = 0;

/**
 * ç”Ÿæˆé‚€è¯·ç 
 */
function generateReferralCode(): string {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let code = "";
  for (let i = 0; i < REFERRAL_CONFIG.codeLength; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

/**
 * æ³¨å†Œæˆä¸ºæ¨èäºº (è·å–é‚€è¯·ç )
 */
function registerAsReferrer(address: Address): Referrer | { error: string } {
  const normalizedAddress = address.toLowerCase() as Address;

  // æ£€æŸ¥æ˜¯å¦å·²æ³¨å†Œ
  if (referrers.has(normalizedAddress)) {
    return referrers.get(normalizedAddress)!;
  }

  // ç”Ÿæˆå”¯ä¸€é‚€è¯·ç 
  let code: string;
  do {
    code = generateReferralCode();
  } while (referralCodes.has(code));

  const now = Date.now();

  const referrer: Referrer = {
    address: normalizedAddress,
    code,
    level1Referrals: [],
    level2Referrals: [],
    totalEarnings: 0n,
    pendingEarnings: 0n,
    withdrawnEarnings: 0n,
    level1Earnings: 0n,
    level2Earnings: 0n,
    totalTradesReferred: 0,
    totalVolumeReferred: 0n,
    createdAt: now,
    updatedAt: now,
  };

  referrers.set(normalizedAddress, referrer);
  referralCodes.set(code, normalizedAddress);

  console.log(`[Referral] Registered referrer ${normalizedAddress.slice(0, 10)} with code ${code}`);

  return referrer;
}

/**
 * ä½¿ç”¨é‚€è¯·ç ç»‘å®šæ¨èå…³ç³»
 */
function bindReferral(
  newUserAddress: Address,
  referralCode: string
): { success: boolean; error?: string } {
  const normalizedAddress = newUserAddress.toLowerCase() as Address;
  const upperCode = referralCode.toUpperCase();

  // æ£€æŸ¥æ˜¯å¦å·²è¢«é‚€è¯·
  if (referees.has(normalizedAddress)) {
    return { success: false, error: "Already bound to a referrer" };
  }

  // æ£€æŸ¥é‚€è¯·ç æ˜¯å¦å­˜åœ¨
  const referrerAddress = referralCodes.get(upperCode);
  if (!referrerAddress) {
    return { success: false, error: "Invalid referral code" };
  }

  // ä¸èƒ½é‚€è¯·è‡ªå·±
  if (referrerAddress === normalizedAddress) {
    return { success: false, error: "Cannot refer yourself" };
  }

  const referrer = referrers.get(referrerAddress);
  if (!referrer) {
    return { success: false, error: "Referrer not found" };
  }

  // è·å–äºŒçº§é‚€è¯·äºº (é‚€è¯·äººçš„é‚€è¯·äºº)
  const referrerAsReferee = referees.get(referrerAddress);
  const level2Referrer = referrerAsReferee?.referrer || null;

  // åˆ›å»ºè¢«é‚€è¯·äººè®°å½•
  const referee: Referee = {
    address: normalizedAddress,
    referrerCode: upperCode,
    referrer: referrerAddress,
    level2Referrer,
    totalFeesPaid: 0n,
    totalCommissionGenerated: 0n,
    joinedAt: Date.now(),
  };

  referees.set(normalizedAddress, referee);

  // æ›´æ–°æ¨èäººçš„é‚€è¯·åˆ—è¡¨
  referrer.level1Referrals.push(normalizedAddress);
  referrer.updatedAt = Date.now();

  // æ›´æ–°äºŒçº§æ¨èäººçš„é‚€è¯·åˆ—è¡¨
  if (level2Referrer) {
    const level2ReferrerData = referrers.get(level2Referrer);
    if (level2ReferrerData) {
      level2ReferrerData.level2Referrals.push(normalizedAddress);
      level2ReferrerData.updatedAt = Date.now();
    }
  }

  console.log(`[Referral] ${normalizedAddress.slice(0, 10)} bound to referrer ${referrerAddress.slice(0, 10)} (code: ${upperCode})`);

  broadcastReferralBound(normalizedAddress, referrerAddress, upperCode);

  return { success: true };
}

/**
 * è®¡ç®—å¹¶è®°å½•äº¤æ˜“è¿”ä½£
 * åœ¨æ¯ç¬”äº¤æ˜“å®Œæˆåè°ƒç”¨
 */
function processTradeCommission(
  trader: Address,
  tradeId: string,
  tradeFee: bigint,
  tradeVolume: bigint
): void {
  const normalizedTrader = trader.toLowerCase() as Address;

  // æ£€æŸ¥æ˜¯å¦æ˜¯è¢«é‚€è¯·ç”¨æˆ·
  const referee = referees.get(normalizedTrader);
  if (!referee) return;

  // æ›´æ–°è¢«é‚€è¯·äººç»Ÿè®¡
  referee.totalFeesPaid += tradeFee;

  const now = Date.now();

  // ä¸€çº§è¿”ä½£
  const level1Referrer = referrers.get(referee.referrer);
  if (level1Referrer) {
    const level1Commission = (tradeFee * BigInt(REFERRAL_CONFIG.level1Rate)) / 10000n;

    if (level1Commission > 0n) {
      const commission: ReferralCommission = {
        id: `comm_${++commissionIdCounter}_${now}`,
        referrer: level1Referrer.address,
        referee: normalizedTrader,
        level: 1,
        tradeId,
        tradeFee,
        commissionAmount: level1Commission,
        commissionRate: REFERRAL_CONFIG.level1Rate,
        timestamp: now,
        status: "credited",
      };

      referralCommissions.push(commission);

      // æ›´æ–°æ¨èäººæ”¶ç›Š
      level1Referrer.totalEarnings += level1Commission;
      level1Referrer.pendingEarnings += level1Commission;
      level1Referrer.level1Earnings += level1Commission;
      level1Referrer.totalTradesReferred++;
      level1Referrer.totalVolumeReferred += tradeVolume;
      level1Referrer.updatedAt = now;

      referee.totalCommissionGenerated += level1Commission;

      console.log(`[Referral] L1 commission: ${level1Referrer.address.slice(0, 10)} earned $${Number(level1Commission) / 1e6} from ${normalizedTrader.slice(0, 10)}`);

      broadcastCommissionEarned(level1Referrer.address, level1Commission, 1, normalizedTrader);
    }
  }

  // äºŒçº§è¿”ä½£
  if (referee.level2Referrer) {
    const level2Referrer = referrers.get(referee.level2Referrer);
    if (level2Referrer) {
      const level2Commission = (tradeFee * BigInt(REFERRAL_CONFIG.level2Rate)) / 10000n;

      if (level2Commission > 0n) {
        const commission: ReferralCommission = {
          id: `comm_${++commissionIdCounter}_${now}`,
          referrer: level2Referrer.address,
          referee: normalizedTrader,
          level: 2,
          tradeId,
          tradeFee,
          commissionAmount: level2Commission,
          commissionRate: REFERRAL_CONFIG.level2Rate,
          timestamp: now,
          status: "credited",
        };

        referralCommissions.push(commission);

        // æ›´æ–°æ¨èäººæ”¶ç›Š
        level2Referrer.totalEarnings += level2Commission;
        level2Referrer.pendingEarnings += level2Commission;
        level2Referrer.level2Earnings += level2Commission;
        level2Referrer.updatedAt = now;

        referee.totalCommissionGenerated += level2Commission;

        console.log(`[Referral] L2 commission: ${level2Referrer.address.slice(0, 10)} earned $${Number(level2Commission) / 1e6} from ${normalizedTrader.slice(0, 10)}`);

        broadcastCommissionEarned(level2Referrer.address, level2Commission, 2, normalizedTrader);
      }
    }
  }

  // ä¿ç•™æœ€è¿‘ 10000 æ¡è¿”ä½£è®°å½•
  if (referralCommissions.length > 10000) {
    referralCommissions.splice(0, referralCommissions.length - 10000);
  }
}

/**
 * æå–è¿”ä½£
 */
function withdrawCommission(
  referrerAddress: Address,
  amount?: bigint
): { success: boolean; withdrawnAmount?: bigint; error?: string } {
  const normalizedAddress = referrerAddress.toLowerCase() as Address;
  const referrer = referrers.get(normalizedAddress);

  if (!referrer) {
    return { success: false, error: "Not a registered referrer" };
  }

  const withdrawAmount = amount || referrer.pendingEarnings;

  if (withdrawAmount <= 0n) {
    return { success: false, error: "No earnings to withdraw" };
  }

  if (withdrawAmount > referrer.pendingEarnings) {
    return { success: false, error: "Insufficient pending earnings" };
  }

  if (withdrawAmount < REFERRAL_CONFIG.minWithdrawAmount) {
    return {
      success: false,
      error: `Minimum withdrawal amount is $${Number(REFERRAL_CONFIG.minWithdrawAmount) / 1e6}`
    };
  }

  // æ‰£é™¤å¾…æå–ï¼Œå¢åŠ å·²æå–
  referrer.pendingEarnings -= withdrawAmount;
  referrer.withdrawnEarnings += withdrawAmount;
  referrer.updatedAt = Date.now();

  // TODO: å®é™…è½¬è´¦é€»è¾‘ (è°ƒç”¨åˆçº¦æˆ–æ›´æ–°ç”¨æˆ·ä½™é¢)

  console.log(`[Referral] Withdrawal: ${normalizedAddress.slice(0, 10)} withdrew $${Number(withdrawAmount) / 1e6}`);

  broadcastCommissionWithdrawn(normalizedAddress, withdrawAmount);

  return { success: true, withdrawnAmount };
}

/**
 * è·å–æ¨èäººä¿¡æ¯
 */
function getReferrerInfo(address: Address): Referrer | null {
  const normalizedAddress = address.toLowerCase() as Address;
  return referrers.get(normalizedAddress) || null;
}

/**
 * è·å–è¢«é‚€è¯·äººä¿¡æ¯
 */
function getRefereeInfo(address: Address): Referee | null {
  const normalizedAddress = address.toLowerCase() as Address;
  return referees.get(normalizedAddress) || null;
}

/**
 * è·å–æ¨èäººçš„è¿”ä½£è®°å½•
 */
function getReferrerCommissions(
  address: Address,
  limit: number = 50
): ReferralCommission[] {
  const normalizedAddress = address.toLowerCase() as Address;
  return referralCommissions
    .filter(c => c.referrer === normalizedAddress)
    .slice(-limit)
    .reverse();
}

/**
 * è·å–å…¨å±€æ¨èç»Ÿè®¡
 */
function getReferralStats(): {
  totalReferrers: number;
  totalReferees: number;
  totalCommissionsPaid: bigint;
  totalCommissionsPending: bigint;
} {
  let totalPaid = 0n;
  let totalPending = 0n;

  for (const referrer of referrers.values()) {
    totalPaid += referrer.withdrawnEarnings;
    totalPending += referrer.pendingEarnings;
  }

  return {
    totalReferrers: referrers.size,
    totalReferees: referees.size,
    totalCommissionsPaid: totalPaid,
    totalCommissionsPending: totalPending,
  };
}

/**
 * è·å–æ¨èæ’è¡Œæ¦œ
 */
function getReferralLeaderboard(limit: number = 20): {
  address: Address;
  code: string;
  referralCount: number;
  totalEarnings: bigint;
}[] {
  return Array.from(referrers.values())
    .sort((a, b) => Number(b.totalEarnings - a.totalEarnings))
    .slice(0, limit)
    .map(r => ({
      address: r.address,
      code: r.code,
      referralCount: r.level1Referrals.length,
      totalEarnings: r.totalEarnings,
    }));
}

// æ¨èç³»ç»Ÿå¹¿æ’­å‡½æ•°
function broadcastReferralBound(referee: Address, referrer: Address, code: string): void {
  broadcast("referral_bound", { referee, referrer, code });
}

function broadcastCommissionEarned(referrer: Address, amount: bigint, level: number, from: Address): void {
  broadcast("commission_earned", {
    referrer,
    amount: amount.toString(),
    level,
    from,
    display: `$${(Number(amount) / 1e6).toFixed(4)}`,
  });
}

function broadcastCommissionWithdrawn(referrer: Address, amount: bigint): void {
  broadcast("commission_withdrawn", {
    referrer,
    amount: amount.toString(),
    display: `$${(Number(amount) / 1e6).toFixed(2)}`,
  });
}

// ============================================================
// Reduce-Only Orders (åªå‡ä»“è®¢å•) - Meme Perp P2 åŠŸèƒ½
// ============================================================

/**
 * Reduce-Only è®¢å•éªŒè¯ç»“æœ
 */
interface ReduceOnlyValidation {
  valid: boolean;
  reason?: string;
  maxSize?: bigint;         // æœ€å¤§å¯å¹³ä»“æ•°é‡
  existingPosition?: {
    pairId: string;
    size: string;
    isLong: boolean;
  };
}

/**
 * éªŒè¯ Reduce-Only è®¢å•
 *
 * è§„åˆ™:
 * 1. å¿…é¡»æœ‰å¯¹åº”æ–¹å‘çš„ç°æœ‰ä»“ä½
 * 2. è®¢å•å¤§å°ä¸èƒ½è¶…è¿‡ç°æœ‰ä»“ä½å¤§å°
 * 3. åªèƒ½å‡å°‘ä»“ä½ï¼Œä¸èƒ½å¼€æ–°ä»“æˆ–åå‘å¼€ä»“
 *
 * @param trader äº¤æ˜“è€…åœ°å€
 * @param token ä»£å¸åœ°å€
 * @param isLong è®¢å•æ–¹å‘ (true=å¤šå¤´å¹³ä»“éœ€è¦åšç©º, false=ç©ºå¤´å¹³ä»“éœ€è¦åšå¤š)
 * @param size è®¢å•å¤§å°
 */
function validateReduceOnlyOrder(
  trader: Address,
  token: Address,
  isLong: boolean,
  size: bigint
): ReduceOnlyValidation {
  const normalizedTrader = trader.toLowerCase() as Address;
  const normalizedToken = token.toLowerCase() as Address;

  // æŸ¥æ‰¾ç°æœ‰ä»“ä½
  const positions = userPositions.get(normalizedTrader) || [];
  const position = positions.find(
    p => (p.token.toLowerCase() as Address) === normalizedToken
  );

  if (!position) {
    return {
      valid: false,
      reason: "No existing position to reduce. Reduce-only orders require an open position.",
    };
  }

  // Reduce-only é€»è¾‘:
  // - åšå¤šè®¢å• (isLong=true) å¯ä»¥å¹³æ‰ç©ºå¤´ä»“ä½ (position.isLong=false)
  // - åšç©ºè®¢å• (isLong=false) å¯ä»¥å¹³æ‰å¤šå¤´ä»“ä½ (position.isLong=true)
  // ä¹Ÿå°±æ˜¯è¯´ï¼Œè®¢å•æ–¹å‘åº”è¯¥ä¸ä»“ä½æ–¹å‘ç›¸å
  if (isLong === position.isLong) {
    return {
      valid: false,
      reason: `Reduce-only order direction mismatch. You have a ${position.isLong ? "LONG" : "SHORT"} position, ` +
              `but submitted a ${isLong ? "LONG" : "SHORT"} reduce-only order. ` +
              `Submit a ${position.isLong ? "SHORT" : "LONG"} order to reduce your position.`,
    };
  }

  const positionSize = BigInt(position.size);

  // è®¢å•å¤§å°ä¸èƒ½è¶…è¿‡ä»“ä½å¤§å°
  if (size > positionSize) {
    return {
      valid: false,
      reason: `Reduce-only order size (${size}) exceeds position size (${positionSize}). Max allowed: ${positionSize}`,
      maxSize: positionSize,
      existingPosition: {
        pairId: position.pairId,
        size: position.size,
        isLong: position.isLong,
      },
    };
  }

  return {
    valid: true,
    maxSize: positionSize,
    existingPosition: {
      pairId: position.pairId,
      size: position.size,
      isLong: position.isLong,
    },
  };
}

/**
 * è·å–ç”¨æˆ·å¯å¹³ä»“ä¿¡æ¯
 */
function getReduceOnlyInfo(trader: Address, token: Address): ReduceOnlyValidation & { canReduce: boolean } {
  const normalizedTrader = trader.toLowerCase() as Address;
  const normalizedToken = token.toLowerCase() as Address;

  const positions = userPositions.get(normalizedTrader) || [];
  const position = positions.find(
    p => (p.token.toLowerCase() as Address) === normalizedToken
  );

  if (!position) {
    return {
      valid: false,
      canReduce: false,
      reason: "No position found for this token",
    };
  }

  return {
    valid: true,
    canReduce: true,
    maxSize: BigInt(position.size),
    existingPosition: {
      pairId: position.pairId,
      size: position.size,
      isLong: position.isLong,
    },
  };
}

// ============================================================
// ç”¨æˆ·ä½™é¢ç®¡ç† (è¡Œä¸šæ ‡å‡† - Binance/OKX)
// ============================================================

interface UserBalance {
  totalBalance: bigint;      // æ€»ä½™é¢ (å……å€¼é‡‘é¢), 1e6 ç²¾åº¦
  usedMargin: bigint;        // å·²ä½¿ç”¨ä¿è¯é‡‘ (æ‰€æœ‰ä»“ä½å ç”¨), 1e6 ç²¾åº¦
  availableBalance: bigint;  // å¯ç”¨ä½™é¢ = totalBalance - usedMargin, 1e6 ç²¾åº¦
  unrealizedPnL: bigint;     // æ‰€æœ‰ä»“ä½çš„æœªå®ç°ç›ˆäº, 1e6 ç²¾åº¦
  frozenMargin: bigint;      // å†»ç»“ä¿è¯é‡‘ (æŒ‚å•å ç”¨), 1e6 ç²¾åº¦
}

const userBalances = new Map<Address, UserBalance>();

/**
 * è·å–ç”¨æˆ·ä½™é¢ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºé»˜è®¤ä½™é¢
 */
function getUserBalance(trader: Address): UserBalance {
  const normalizedTrader = trader.toLowerCase() as Address;
  let balance = userBalances.get(normalizedTrader);
  if (!balance) {
    balance = {
      totalBalance: 0n,
      usedMargin: 0n,
      availableBalance: 0n,
      unrealizedPnL: 0n,
      frozenMargin: 0n,
    };
    userBalances.set(normalizedTrader, balance);
  }
  return balance;
}

/**
 * å……å€¼ (å¢åŠ æ€»ä½™é¢)
 */
function deposit(trader: Address, amount: bigint): void {
  const balance = getUserBalance(trader);
  balance.totalBalance += amount;
  balance.availableBalance += amount;
  console.log(`[Balance] Deposit: ${trader.slice(0, 10)} +$${Number(amount) / 1e6}, total: $${Number(balance.totalBalance) / 1e6}`);
}

/**
 * æç° (å‡å°‘æ€»ä½™é¢)
 */
function withdraw(trader: Address, amount: bigint): boolean {
  const balance = getUserBalance(trader);
  if (balance.availableBalance < amount) {
    console.log(`[Balance] Withdraw failed: ${trader.slice(0, 10)} insufficient available balance`);
    return false;
  }
  balance.totalBalance -= amount;
  balance.availableBalance -= amount;
  console.log(`[Balance] Withdraw: ${trader.slice(0, 10)} -$${Number(amount) / 1e6}, total: $${Number(balance.totalBalance) / 1e6}`);
  return true;
}

/**
 * å¼€ä»“æ—¶é”å®šä¿è¯é‡‘
 */
function lockMargin(trader: Address, margin: bigint): boolean {
  const balance = getUserBalance(trader);
  if (balance.availableBalance < margin) {
    console.log(`[Balance] Lock margin failed: ${trader.slice(0, 10)} needs $${Number(margin) / 1e6}, available: $${Number(balance.availableBalance) / 1e6}`);
    return false;
  }
  balance.usedMargin += margin;
  balance.availableBalance -= margin;
  console.log(`[Balance] Locked margin: ${trader.slice(0, 10)} $${Number(margin) / 1e6}, used: $${Number(balance.usedMargin) / 1e6}, available: $${Number(balance.availableBalance) / 1e6}`);
  return true;
}

/**
 * å¹³ä»“æ—¶é‡Šæ”¾ä¿è¯é‡‘å¹¶ç»“ç®—ç›ˆäº
 */
function releaseMargin(trader: Address, margin: bigint, realizedPnL: bigint): void {
  const balance = getUserBalance(trader);
  balance.usedMargin -= margin;
  // å¯ç”¨ä½™é¢ = é‡Šæ”¾çš„ä¿è¯é‡‘ + å·²å®ç°ç›ˆäº
  balance.availableBalance += margin + realizedPnL;
  // å¦‚æœç›ˆåˆ©ï¼Œæ€»ä½™é¢å¢åŠ 
  if (realizedPnL > 0n) {
    balance.totalBalance += realizedPnL;
  } else {
    // å¦‚æœäºæŸï¼Œæ€»ä½™é¢å‡å°‘
    balance.totalBalance += realizedPnL; // realizedPnL æ˜¯è´Ÿæ•°
  }
  console.log(`[Balance] Released margin: ${trader.slice(0, 10)} $${Number(margin) / 1e6}, PnL: $${Number(realizedPnL) / 1e6}, available: $${Number(balance.availableBalance) / 1e6}`);
}

/**
 * æ›´æ–°ç”¨æˆ·çš„æœªå®ç°ç›ˆäºï¼ˆæ ¹æ®æ‰€æœ‰ä»“ä½è®¡ç®—ï¼‰
 */
function updateUnrealizedPnL(trader: Address, currentPrices: Map<Address, bigint>): void {
  const normalizedTrader = trader.toLowerCase() as Address;
  const positions = userPositions.get(normalizedTrader) || [];
  const balance = getUserBalance(trader);

  let totalPnL = 0n;
  for (const pos of positions) {
    const currentPrice = currentPrices.get(pos.token.toLowerCase() as Address) || BigInt(pos.entryPrice);
    const pnl = calculateUnrealizedPnL(
      BigInt(pos.size),
      BigInt(pos.entryPrice),
      currentPrice,
      pos.isLong
    );
    totalPnL += pnl;
  }
  balance.unrealizedPnL = totalPnL;
}

/**
 * è®¡ç®—è´¦æˆ·æƒç›Š = å¯ç”¨ä½™é¢ + å·²ä½¿ç”¨ä¿è¯é‡‘ + æœªå®ç°ç›ˆäº
 */
function getEquity(trader: Address): bigint {
  const balance = getUserBalance(trader);
  return balance.availableBalance + balance.usedMargin + balance.unrealizedPnL;
}

// ============================================================
// é“¾ä¸Šä»“ä½åŒæ­¥
// ============================================================

/**
 * ä»é“¾ä¸Š Settlement åˆçº¦åŒæ­¥æ‰€æœ‰æ´»è·ƒä»“ä½
 * è§£å†³ P003: æŒä»“æ•°æ®æ¥æºæ··ä¹±é—®é¢˜
 */
async function syncPositionsFromChain(): Promise<void> {
  if (!SETTLEMENT_ADDRESS) {
    console.log("[Sync] No Settlement address configured, skipping position sync");
    return;
  }

  console.log("[Sync] Starting position sync from chain...");

  try {
    const publicClient = createPublicClient({
      chain: baseSepolia,
      transport: http(RPC_URL),
    });

    // è·å–ä¸‹ä¸€ä¸ª pairIdï¼ˆå³å½“å‰æœ€å¤§ pairId + 1ï¼‰
    const nextPairId = await publicClient.readContract({
      address: SETTLEMENT_ADDRESS,
      abi: SETTLEMENT_ABI,
      functionName: "nextPairId",
    }) as bigint;

    console.log(`[Sync] Total pairs on chain: ${nextPairId}`);

    if (nextPairId === 0n) {
      console.log("[Sync] No positions found on chain");
      return;
    }

    let syncedCount = 0;
    let activeCount = 0;

    // éå†æ‰€æœ‰ä»“ä½
    for (let pairId = 0n; pairId < nextPairId; pairId++) {
      try {
        const position = await publicClient.readContract({
          address: SETTLEMENT_ADDRESS,
          abi: SETTLEMENT_ABI,
          functionName: "getPairedPosition",
          args: [pairId],
        }) as any;

        // status: 0 = Active, 1 = Closed, 2 = Liquidated
        if (position.status !== 0) {
          continue; // è·³è¿‡éæ´»è·ƒä»“ä½
        }

        // è·³è¿‡ç©ºä»“ä½ï¼ˆsize ä¸º 0 æˆ–åœ°å€ä¸ºé›¶åœ°å€çš„ä»“ä½ï¼‰
        const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
        if (
          BigInt(position.size) === 0n ||
          position.longTrader === ZERO_ADDRESS ||
          position.shortTrader === ZERO_ADDRESS ||
          position.token === ZERO_ADDRESS
        ) {
          continue; // è·³è¿‡ç©º/æ— æ•ˆä»“ä½
        }

        activeCount++;

        // è®¡ç®—æ¸…ç®—ä»·æ ¼
        const entryPrice = BigInt(position.entryPrice);
        const longLeverage = BigInt(position.longLeverage);
        const shortLeverage = BigInt(position.shortLeverage);

        // leverage å­˜å‚¨ä¸ºåŸºç‚¹ (1x = 10000, 10x = 100000)
        // calculateLiquidationPrice æœŸæœ›ç²¾åº¦æ˜¯ 1e4ï¼Œç›´æ¥ä¼ å…¥
        const longLiqPrice = longLeverage > 0n ? calculateLiquidationPrice(entryPrice, longLeverage, true) : 0n;
        const shortLiqPrice = shortLeverage > 0n ? calculateLiquidationPrice(entryPrice, shortLeverage, false) : 0n;

        const now = Date.now();
        const entryPriceStr = position.entryPrice.toString();

        // è®¡ç®—ç›ˆäºå¹³è¡¡ä»·æ ¼ (å«0.05%æ‰‹ç»­è´¹)
        const feeRate = 0.0005;
        const breakEvenLong = entryPrice + BigInt(Math.floor(Number(entryPrice) * feeRate));
        const breakEvenShort = entryPrice - BigInt(Math.floor(Number(entryPrice) * feeRate));

        // è®¡ç®—ç»´æŒä¿è¯é‡‘ (0.5% of position value)
        const mmrRate = 0.005;
        const positionValue = BigInt(position.size) * entryPrice / (10n ** 18n);
        const maintenanceMargin = positionValue * BigInt(Math.floor(mmrRate * 10000)) / 10000n;

        // åˆ›å»º Long æ–¹ä»“ä½ (è¡Œä¸šæ ‡å‡†å­—æ®µ)
        const longPosition: Position = {
          // åŸºæœ¬æ ‡è¯†
          pairId: pairId.toString(),
          trader: position.longTrader as Address,
          token: position.token as Address,

          // ä»“ä½å‚æ•°
          isLong: true,
          size: position.size.toString(),
          entryPrice: entryPriceStr,
          leverage: (longLeverage / 10000n).toString(),

          // ä»·æ ¼ä¿¡æ¯
          markPrice: entryPriceStr, // åˆå§‹åŒ–ä¸ºå¼€ä»“ä»·ï¼Œåç»­æ›´æ–°
          liquidationPrice: longLiqPrice.toString(),
          breakEvenPrice: breakEvenLong.toString(),

          // ä¿è¯é‡‘ä¿¡æ¯
          collateral: position.longCollateral.toString(),
          margin: position.longCollateral.toString(),
          marginRatio: "10000", // åˆå§‹åŒ–ä¸º 100%
          maintenanceMargin: maintenanceMargin.toString(),

          // ç›ˆäºä¿¡æ¯
          unrealizedPnL: "0",
          realizedPnL: "0",
          roe: "0",
          fundingFee: "0",

          // æ­¢ç›ˆæ­¢æŸ
          takeProfitPrice: null,
          stopLossPrice: null,

          // ç³»ç»Ÿä¿¡æ¯
          counterparty: position.shortTrader as Address,
          createdAt: Number(position.openTime) * 1000,
          updatedAt: now,

          // é£é™©æŒ‡æ ‡
          adlRanking: 3, // é»˜è®¤ä¸­ç­‰
          riskLevel: "medium",
        };

        // åˆ›å»º Short æ–¹ä»“ä½ (è¡Œä¸šæ ‡å‡†å­—æ®µ)
        const shortPosition: Position = {
          // åŸºæœ¬æ ‡è¯†
          pairId: pairId.toString(),
          trader: position.shortTrader as Address,
          token: position.token as Address,

          // ä»“ä½å‚æ•°
          isLong: false,
          size: position.size.toString(),
          entryPrice: entryPriceStr,
          leverage: (shortLeverage / 10000n).toString(),

          // ä»·æ ¼ä¿¡æ¯
          markPrice: entryPriceStr,
          liquidationPrice: shortLiqPrice.toString(),
          breakEvenPrice: breakEvenShort.toString(),

          // ä¿è¯é‡‘ä¿¡æ¯
          collateral: position.shortCollateral.toString(),
          margin: position.shortCollateral.toString(),
          marginRatio: "10000",
          maintenanceMargin: maintenanceMargin.toString(),

          // ç›ˆäºä¿¡æ¯
          unrealizedPnL: "0",
          realizedPnL: "0",
          roe: "0",
          fundingFee: "0",

          // æ­¢ç›ˆæ­¢æŸ
          takeProfitPrice: null,
          stopLossPrice: null,

          // ç³»ç»Ÿä¿¡æ¯
          counterparty: position.longTrader as Address,
          createdAt: Number(position.openTime) * 1000,
          updatedAt: now,

          // é£é™©æŒ‡æ ‡
          adlRanking: 3,
          riskLevel: "medium",
        };

        // æ·»åŠ åˆ° userPositions Map
        addPositionToUser(longPosition);
        addPositionToUser(shortPosition);
        syncedCount += 2;

      } catch (e) {
        // å•ä¸ªä»“ä½è¯»å–å¤±è´¥ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
        console.error(`[Sync] Failed to read pair ${pairId}:`, e);
      }
    }

    console.log(`[Sync] Synced ${syncedCount} positions from ${activeCount} active pairs`);

  } catch (e) {
    console.error("[Sync] Failed to sync positions from chain:", e);
  }
}

/**
 * æ·»åŠ ä»“ä½åˆ°ç”¨æˆ·çš„ä»“ä½åˆ—è¡¨
 */
function addPositionToUser(position: Position): void {
  const normalizedTrader = position.trader.toLowerCase() as Address;
  const positions = userPositions.get(normalizedTrader) || [];

  // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé¿å…é‡å¤ï¼‰
  const existingIndex = positions.findIndex(
    (p) => p.pairId === position.pairId && p.isLong === position.isLong
  );

  if (existingIndex >= 0) {
    positions[existingIndex] = position; // æ›´æ–°
  } else {
    positions.push(position); // æ–°å¢
    console.log(`[Position] Added: ${normalizedTrader.slice(0, 10)} ${position.isLong ? 'LONG' : 'SHORT'} liqPrice=${position.liquidationPrice}`);
  }

  userPositions.set(normalizedTrader, positions);
}

// ============================================================
// é“¾ä¸Šäº‹ä»¶ç›‘å¬ (å®æ—¶åŒæ­¥é“¾ä¸ŠçŠ¶æ€å˜åŒ–)
// ============================================================

let eventWatcherUnwatch: (() => void) | null = null;

/**
 * å¯åŠ¨é“¾ä¸Šäº‹ä»¶ç›‘å¬
 * ç›‘å¬ Settlement åˆçº¦çš„å…³é”®äº‹ä»¶ï¼Œå®æ—¶åŒæ­¥é“¾ä¸ŠçŠ¶æ€åˆ°åç«¯
 */
async function startEventWatching(): Promise<void> {
  if (!SETTLEMENT_ADDRESS) {
    console.log("[Events] No Settlement address configured, skipping event watching");
    return;
  }

  console.log("[Events] Starting event watching for Settlement contract:", SETTLEMENT_ADDRESS);

  const publicClient = createPublicClient({
    chain: baseSepolia,
    transport: http(RPC_URL),
  });

  // ç›‘å¬ Deposited äº‹ä»¶ (ç”¨æˆ·ç›´æ¥å……å€¼)
  publicClient.watchContractEvent({
    address: SETTLEMENT_ADDRESS,
    abi: SETTLEMENT_ABI,
    eventName: "Deposited",
    onLogs: (logs) => {
      for (const log of logs) {
        const { user, amount } = log.args as { user: Address; amount: bigint };
        console.log(`[Events] Deposited: ${user.slice(0, 10)} +$${Number(amount) / 1e6}`);
        // é€šè¿‡ WebSocket é€šçŸ¥å‰ç«¯
        broadcastBalanceUpdate(user);
      }
    },
  });

  // ç›‘å¬ DepositedFor äº‹ä»¶ (ä¸»é’±åŒ…ä¸ºæ´¾ç”Ÿé’±åŒ…å……å€¼)
  publicClient.watchContractEvent({
    address: SETTLEMENT_ADDRESS,
    abi: SETTLEMENT_ABI,
    eventName: "DepositedFor",
    onLogs: (logs) => {
      for (const log of logs) {
        const { user, relayer, token, amount } = log.args as {
          user: Address;
          relayer: Address;
          token: Address;
          amount: bigint;
        };
        console.log(`[Events] DepositedFor: ${relayer.slice(0, 10)} â†’ ${user.slice(0, 10)} +$${Number(amount) / 1e6}`);
        // é€šè¿‡ WebSocket é€šçŸ¥å‰ç«¯
        broadcastBalanceUpdate(user);
      }
    },
  });

  // ç›‘å¬ Withdrawn äº‹ä»¶
  publicClient.watchContractEvent({
    address: SETTLEMENT_ADDRESS,
    abi: SETTLEMENT_ABI,
    eventName: "Withdrawn",
    onLogs: (logs) => {
      for (const log of logs) {
        const { user, amount } = log.args as { user: Address; amount: bigint };
        console.log(`[Events] Withdrawn: ${user.slice(0, 10)} -$${Number(amount) / 1e6}`);
        broadcastBalanceUpdate(user);
      }
    },
  });

  // ç›‘å¬ PairOpened äº‹ä»¶ (æ–°ä»“ä½å¼€ç«‹)
  publicClient.watchContractEvent({
    address: SETTLEMENT_ADDRESS,
    abi: SETTLEMENT_ABI,
    eventName: "PairOpened",
    onLogs: async (logs) => {
      for (const log of logs) {
        const { pairId, longTrader, shortTrader, token, size, entryPrice } = log.args as {
          pairId: bigint;
          longTrader: Address;
          shortTrader: Address;
          token: Address;
          size: bigint;
          entryPrice: bigint;
        };
        console.log(`[Events] PairOpened: #${pairId} ${longTrader.slice(0, 10)} vs ${shortTrader.slice(0, 10)}`);

        // ä»é“¾ä¸Šè¯»å–å®Œæ•´ä»“ä½ä¿¡æ¯
        try {
          const position = await publicClient.readContract({
            address: SETTLEMENT_ADDRESS,
            abi: SETTLEMENT_ABI,
            functionName: "getPairedPosition",
            args: [pairId],
          }) as any;

          // åˆ›å»º Long ä»“ä½
          syncPositionFromChainData(pairId, position, true);
          // åˆ›å»º Short ä»“ä½
          syncPositionFromChainData(pairId, position, false);

          // é€šçŸ¥å‰ç«¯
          broadcastBalanceUpdate(longTrader);
          broadcastBalanceUpdate(shortTrader);
          broadcastPositionUpdate(longTrader, token);
          broadcastPositionUpdate(shortTrader, token);
        } catch (e) {
          console.error(`[Events] Failed to sync position #${pairId}:`, e);
        }
      }
    },
  });

  // ç›‘å¬ PairClosed äº‹ä»¶ (ä»“ä½å¹³ä»“)
  publicClient.watchContractEvent({
    address: SETTLEMENT_ADDRESS,
    abi: SETTLEMENT_ABI,
    eventName: "PairClosed",
    onLogs: (logs) => {
      for (const log of logs) {
        const { pairId, exitPrice, longPnL, shortPnL } = log.args as {
          pairId: bigint;
          exitPrice: bigint;
          longPnL: bigint;
          shortPnL: bigint;
        };
        console.log(`[Events] PairClosed: #${pairId} longPnL=$${Number(longPnL) / 1e6} shortPnL=$${Number(shortPnL) / 1e6}`);

        // ä»åç«¯ä»“ä½è®°å½•ä¸­ç§»é™¤
        removePositionByPairId(pairId.toString());

        // åˆ·æ–°æ‰€æœ‰ä»“ä½
        syncPositionsFromChain().catch((e) => {
          console.error("[Events] Failed to sync after PairClosed:", e);
        });
      }
    },
  });

  // ç›‘å¬ Liquidated äº‹ä»¶ (å¼ºåˆ¶å¹³ä»“)
  publicClient.watchContractEvent({
    address: SETTLEMENT_ADDRESS,
    abi: SETTLEMENT_ABI,
    eventName: "Liquidated",
    onLogs: (logs) => {
      for (const log of logs) {
        const { pairId, liquidatedTrader, liquidator, reward } = log.args as {
          pairId: bigint;
          liquidatedTrader: Address;
          liquidator: Address;
          reward: bigint;
        };
        console.log(`[Events] Liquidated: #${pairId} trader=${liquidatedTrader.slice(0, 10)} reward=$${Number(reward) / 1e6}`);

        // ä»åç«¯ä»“ä½è®°å½•ä¸­ç§»é™¤
        removePositionByPairId(pairId.toString());

        // é€šçŸ¥å‰ç«¯
        broadcastBalanceUpdate(liquidatedTrader);
        broadcastBalanceUpdate(liquidator);
      }
    },
  });

  console.log("[Events] Event watching started successfully");
}

/**
 * ä»é“¾ä¸Šä»“ä½æ•°æ®åŒæ­¥åˆ°åç«¯
 */
function syncPositionFromChainData(pairId: bigint, chainPosition: any, isLong: boolean): void {
  const trader = isLong ? chainPosition.longTrader : chainPosition.shortTrader;
  const counterparty = isLong ? chainPosition.shortTrader : chainPosition.longTrader;
  const collateral = isLong ? chainPosition.longCollateral : chainPosition.shortCollateral;
  const leverage = isLong ? chainPosition.longLeverage : chainPosition.shortLeverage;

  const entryPrice = BigInt(chainPosition.entryPrice);
  const liquidationPrice = calculateLiquidationPrice(entryPrice, BigInt(leverage), isLong);

  const position: Position = {
    pairId: pairId.toString(),
    trader: trader as Address,
    token: chainPosition.token as Address,
    isLong,
    size: chainPosition.size.toString(),
    entryPrice: chainPosition.entryPrice.toString(),
    leverage: (BigInt(leverage) / 10000n).toString(),
    markPrice: chainPosition.entryPrice.toString(),
    liquidationPrice: liquidationPrice.toString(),
    breakEvenPrice: chainPosition.entryPrice.toString(),
    collateral: collateral.toString(),
    margin: collateral.toString(),
    marginRatio: "10000",
    maintenanceMargin: "0",
    unrealizedPnL: "0",
    realizedPnL: "0",
    roe: "0",
    fundingFee: "0",
    takeProfitPrice: null,
    stopLossPrice: null,
    counterparty: counterparty as Address,
    createdAt: Number(chainPosition.openTime) * 1000,
    updatedAt: Date.now(),
    adlRanking: 3,
    riskLevel: "low",
  };

  addPositionToUser(position);
}

/**
 * æ ¹æ® pairId ç§»é™¤ä»“ä½
 */
function removePositionByPairId(pairId: string): void {
  for (const [trader, positions] of userPositions.entries()) {
    const filteredPositions = positions.filter((p) => p.pairId !== pairId);
    if (filteredPositions.length !== positions.length) {
      console.log(`[Position] Removed pairId ${pairId} from ${trader.slice(0, 10)}`);
      userPositions.set(trader, filteredPositions);
    }
  }
}

/**
 * å¹¿æ’­ä½™é¢æ›´æ–°åˆ°å‰ç«¯
 */
function broadcastBalanceUpdate(user: Address): void {
  const message = JSON.stringify({
    type: "balance_update",
    user: user.toLowerCase(),
    timestamp: Date.now(),
  });

  for (const [client, subscriptions] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  }
}

/**
 * å¹¿æ’­ä»“ä½æ›´æ–°åˆ°å‰ç«¯
 */
function broadcastPositionUpdate(user: Address, token: Address): void {
  const normalizedToken = token.toLowerCase() as Address;
  const message = JSON.stringify({
    type: "position_update",
    user: user.toLowerCase(),
    token: normalizedToken,
    timestamp: Date.now(),
  });

  for (const [client, subscriptions] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN && subscriptions.has(normalizedToken)) {
      client.send(message);
    }
  }
}

// ============================================================
// çŒæ€åœºï¼šæ¸…ç®—è¿½è¸ªç³»ç»Ÿ
// ============================================================

interface LiquidationRecord {
  id: string;
  token: Address;
  liquidatedTrader: Address;
  liquidator: Address;
  isLong: boolean;
  size: string;
  entryPrice: string;
  liquidationPrice: string;
  collateralLost: string;
  timestamp: number;
}

interface HunterStats {
  address: Address;
  totalKills: number;
  totalProfitUSD: string;
  lastKillTime: number;
}

// æ¸…ç®—å†å²è®°å½•ï¼ˆæŒ‰ä»£å¸ï¼‰
const liquidationHistory = new Map<Address, LiquidationRecord[]>();

// çŒæ€è€…æ’è¡Œæ¦œ
const hunterStats = new Map<Address, HunterStats>();

// å…¨å±€æ¸…ç®—è®¡æ•°
let globalLiquidationCount = 0;

/**
 * åˆ›å»ºæˆ–æ›´æ–°æŒä»“è®°å½•
 */
function createOrUpdatePosition(
  trader: Address,
  token: Address,
  isLong: boolean,
  size: bigint,
  entryPrice: bigint,
  leverage: bigint,
  counterparty: Address
): void {
  const normalizedTrader = trader.toLowerCase() as Address;
  const normalizedToken = token.toLowerCase() as Address;
  const now = Date.now();

  // è°ƒè¯•ï¼šæ‰“å°è¾“å…¥å‚æ•°
  console.log(`[Position] Input: size=${size}, entryPrice=${entryPrice}, leverage=${leverage}`);

  // è®¡ç®—ä¿è¯é‡‘ (å‚è€ƒ GMX/Binance)
  // ç²¾åº¦è¯´æ˜:
  //   - size: 1e18 ç²¾åº¦ (ä»£å¸æ•°é‡)
  //   - entryPrice: 1e12 ç²¾åº¦ (USDä»·æ ¼ï¼Œæ¥è‡ªè®¢å•ç°¿ currentPrice)
  //   - leverage: 1e4 ç²¾åº¦ (10x = 100000)
  //   - collateral è¾“å‡º: 1e6 ç²¾åº¦ (USD)
  //
  // ä»“ä½ä»·å€¼ = size * entryPrice / (1e18 * 1e12) * 1e6 = size * entryPrice / 1e24
  const positionValue = (size * entryPrice) / (10n ** 24n); // USD, 1e6 ç²¾åº¦
  console.log(`[Position] positionValue (1e6 USD) = ${positionValue} ($${Number(positionValue) / 1e6})`);

  // ä¿è¯é‡‘ = ä»“ä½ä»·å€¼ / æ æ†å€æ•°
  // å› ä¸º leverage æ˜¯ 1e4 ç²¾åº¦, æ‰€ä»¥: collateral = positionValue * 1e4 / leverage
  const collateral = (positionValue * 10000n) / leverage; // USD, 1e6 ç²¾åº¦
  console.log(`[Position] collateral (1e6 USD) = ${collateral}, in USD = $${Number(collateral) / 1e6}`)

  // é”å®šä¿è¯é‡‘ (ä»å¯ç”¨ä½™é¢ä¸­æ‰£é™¤)
  const marginLocked = lockMargin(normalizedTrader, collateral);
  if (!marginLocked) {
    console.log(`[Position] Warning: Failed to lock margin for ${normalizedTrader.slice(0, 10)}, position created anyway (for testing)`);
    // åœ¨æµ‹è¯•ç¯å¢ƒä¸‹ä»ç„¶åˆ›å»ºä»“ä½ï¼Œä½†è®°å½•è­¦å‘Š
  }

  // è®¡ç®—æ¸…ç®—ä»·æ ¼
  const liquidationPrice = calculateLiquidationPrice(entryPrice, leverage, isLong);

  // åˆå§‹ä¿è¯é‡‘ç‡ = 1 / æ æ†å€æ•° = 1e4 / leverage * 1e4 = 1e8 / leverage
  // ä¾‹å¦‚ 10x: marginRatio = 1e8 / 100000 = 1000 (10%)
  const marginRatio = (10n ** 8n) / leverage;

  // è®¡ç®—å¼€ä»“æ‰‹ç»­è´¹ (0.05% of position value)
  // è¡Œä¸šæ ‡å‡†: åˆšå¼€ä»“æ—¶ä»·æ ¼æ²¡å˜ï¼Œæœªå®ç°ç›ˆäº = -æ‰‹ç»­è´¹
  const feeRate = 5n; // 0.05% = 5 / 10000
  const openFee = (positionValue * feeRate) / 10000n; // USD, 1e6 ç²¾åº¦

  // ç›ˆäºå¹³è¡¡ä»·æ ¼ = å¼€ä»“ä»· Â± æ‰‹ç»­è´¹å¯¹åº”çš„ä»·æ ¼å˜åŠ¨
  const breakEvenPrice = isLong
    ? entryPrice + (entryPrice * feeRate) / 10000n
    : entryPrice - (entryPrice * feeRate) / 10000n;

  // è®¡ç®—ç»´æŒä¿è¯é‡‘ (0.5% of position value)
  const maintenanceMargin = (positionValue * 50n) / 10000n; // USD, 1e6 ç²¾åº¦

  // åˆå§‹æœªå®ç°ç›ˆäº = -å¼€ä»“æ‰‹ç»­è´¹ (åˆšå¼€ä»“ä»·æ ¼æ²¡å˜å°±æ˜¯äºæ‰‹ç»­è´¹)
  const initialPnL = -openFee;

  // åˆå§‹ä¿è¯é‡‘ç‡ = ç»´æŒä¿è¯é‡‘ / (ä¿è¯é‡‘ + PnL)
  // è¡Œä¸šæ ‡å‡† (Binance): marginRatio = MM / Equity, è¶Šå¤§è¶Šå±é™©
  const equity = collateral + initialPnL;
  const initialMarginRatio = equity > 0n
    ? (maintenanceMargin * 10000n) / equity
    : 10000n;

  console.log(`[Position] openFee: $${Number(openFee) / 1e6}, initialPnL: $${Number(initialPnL) / 1e6}`);
  console.log(`[Position] equity: $${Number(equity) / 1e6}, marginRatio: ${Number(initialMarginRatio) / 100}%`);

  const position: Position = {
    // åŸºæœ¬æ ‡è¯†
    pairId: `${normalizedToken}_${normalizedTrader}_${now}`,
    trader: normalizedTrader,
    token: normalizedToken,

    // ä»“ä½å‚æ•°
    isLong,
    size: size.toString(),
    entryPrice: entryPrice.toString(),
    leverage: (leverage / 10000n).toString(), // è½¬æ¢ä¸ºäººç±»å¯è¯» (10x = "10")

    // ä»·æ ¼ä¿¡æ¯
    markPrice: entryPrice.toString(), // åˆå§‹åŒ–ä¸ºå¼€ä»“ä»·
    liquidationPrice: liquidationPrice.toString(),
    breakEvenPrice: breakEvenPrice.toString(),

    // ä¿è¯é‡‘ä¿¡æ¯
    collateral: collateral.toString(),
    margin: collateral.toString(),
    marginRatio: initialMarginRatio.toString(),
    maintenanceMargin: maintenanceMargin.toString(),

    // ç›ˆäºä¿¡æ¯ (åˆå§‹ä¸º -æ‰‹ç»­è´¹)
    unrealizedPnL: initialPnL.toString(),
    realizedPnL: "0",
    roe: ((initialPnL * 10000n) / collateral).toString(), // ROE% = PnL / ä¿è¯é‡‘ * 100
    fundingFee: "0",

    // æ­¢ç›ˆæ­¢æŸ
    takeProfitPrice: null,
    stopLossPrice: null,

    // ç³»ç»Ÿä¿¡æ¯
    counterparty,
    createdAt: now,
    updatedAt: now,

    // é£é™©æŒ‡æ ‡
    adlRanking: 3,
    riskLevel: "medium",
  };

  // è·å–ç”¨æˆ·ç°æœ‰æŒä»“
  const positions = userPositions.get(normalizedTrader) || [];

  // æŸ¥æ‰¾æ˜¯å¦æœ‰åŒæ–¹å‘åŒä»£å¸çš„æŒä»“
  const existingIndex = positions.findIndex(
    (p) => p.token === normalizedToken && p.isLong === isLong
  );

  if (existingIndex >= 0) {
    // åˆå¹¶æŒä»“ï¼ˆåŠ ä»“ï¼‰
    const existing = positions[existingIndex];
    const oldSize = BigInt(existing.size);
    const oldEntryPrice = BigInt(existing.entryPrice);
    const newSize = oldSize + size;

    // è®¡ç®—æ–°çš„å¹³å‡å…¥åœºä»·
    const newEntryPrice = (oldSize * oldEntryPrice + size * entryPrice) / newSize;
    const newCollateral = BigInt(existing.collateral) + collateral;
    const newLiquidationPrice = calculateLiquidationPrice(newEntryPrice, leverage, isLong);

    positions[existingIndex] = {
      ...existing,
      size: newSize.toString(),
      entryPrice: newEntryPrice.toString(),
      collateral: newCollateral.toString(),
      liquidationPrice: newLiquidationPrice.toString(),
      marginRatio: ((newCollateral * 10000n) / newSize).toString(),
    };
  } else {
    // æ–°å¼€ä»“ä½
    positions.push(position);
  }

  userPositions.set(normalizedTrader, positions);

  console.log(`[Position] ${isLong ? "Long" : "Short"} opened: ${trader.slice(0, 10)} size=${size} liq=${liquidationPrice}`);
}

// ============================================================
// Helpers
// ============================================================

function jsonResponse(data: object, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      "Content-Type": "application/json",
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    },
  });
}

function errorResponse(message: string, status = 400): Response {
  return jsonResponse({ success: false, error: message }, status);
}

async function verifyOrderSignature(
  trader: Address,
  token: Address,
  isLong: boolean,
  size: bigint,
  leverage: bigint,
  price: bigint,
  deadline: bigint,
  nonce: bigint,
  orderType: number,
  signature: Hex
): Promise<boolean> {
  try {
    console.log("[DEBUG] Verifying signature:");
    console.log("  trader:", trader);
    console.log("  token:", token);
    console.log("  isLong:", isLong, typeof isLong);
    console.log("  size:", size, typeof size);
    console.log("  leverage:", leverage, typeof leverage);
    console.log("  price:", price, typeof price);
    console.log("  deadline:", deadline, typeof deadline);
    console.log("  nonce:", nonce, typeof nonce);
    console.log("  orderType:", orderType, typeof orderType);
    console.log("  signature:", signature);
    console.log("  domain:", EIP712_DOMAIN);

    const isValid = await verifyTypedData({
      address: trader,
      domain: EIP712_DOMAIN,
      types: ORDER_TYPES,
      primaryType: "Order",
      message: {
        trader,
        token,
        isLong,
        size,
        leverage,
        price,
        deadline,
        nonce,
        orderType,
      },
      signature,
    });
    return isValid;
  } catch (e) {
    console.error("Signature verification failed:", e);
    return false;
  }
}

function getUserNonce(trader: Address): bigint {
  return userNonces.get(trader.toLowerCase() as Address) || 0n;
}

function incrementUserNonce(trader: Address): void {
  const current = getUserNonce(trader);
  userNonces.set(trader.toLowerCase() as Address, current + 1n);
}

// ============================================================
// API Handlers
// ============================================================

async function handleOrderSubmit(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const {
      trader,
      token,
      isLong,
      size,
      leverage,
      price,
      deadline,
      nonce,
      orderType,
      signature,
      reduceOnly = false,  // P2: åªå‡ä»“æ ‡å¿—
      postOnly = false,    // P3: åªæŒ‚å•æ¨¡å¼ (Maker Only)
      timeInForce = "GTC", // P3: è®¢å•æœ‰æ•ˆæœŸ (GTC/IOC/FOK/GTD)
    } = body;

    // Validate required fields
    if (!trader || !token || !signature) {
      return errorResponse("Missing required fields");
    }

    // Parse bigint values
    const sizeBigInt = BigInt(size);
    const leverageBigInt = BigInt(leverage);
    const priceBigInt = BigInt(price);
    const deadlineBigInt = BigInt(deadline);
    const nonceBigInt = BigInt(nonce);

    // Check deadline
    if (deadlineBigInt < BigInt(Math.floor(Date.now() / 1000))) {
      return errorResponse("Order expired");
    }

    // ============================================================
    // P2: Reduce-Only è®¢å•éªŒè¯
    // ============================================================
    if (reduceOnly) {
      const validation = validateReduceOnlyOrder(
        trader as Address,
        token as Address,
        isLong,
        sizeBigInt
      );

      if (!validation.valid) {
        return errorResponse(validation.reason || "Reduce-only validation failed");
      }
    }

    // Check nonce - ä¸å†ä¸¥æ ¼éªŒè¯ï¼Œè®©é“¾ä¸Šåˆçº¦å¤„ç†
    // åªè®°å½•nonceç”¨äºè®¢å•å»é‡
    const expectedNonce = getUserNonce(trader);
    if (!SYNC_NONCE_FROM_CHAIN && nonceBigInt < expectedNonce) {
      return errorResponse(`Invalid nonce. Expected >= ${expectedNonce}`);
    }

    // Verify signature
    const isValid = await verifyOrderSignature(
      trader as Address,
      token as Address,
      isLong,
      sizeBigInt,
      leverageBigInt,
      priceBigInt,
      deadlineBigInt,
      nonceBigInt,
      orderType,
      signature as Hex
    );

    if (!isValid) {
      return errorResponse("Invalid signature");
    }

    // ============================================================
    // P3: è§£æ timeInForce
    // ============================================================
    let tif: TimeInForce;
    switch (timeInForce.toUpperCase()) {
      case "IOC":
        tif = TimeInForce.IOC;
        break;
      case "FOK":
        tif = TimeInForce.FOK;
        break;
      case "GTD":
        tif = TimeInForce.GTD;
        break;
      default:
        tif = TimeInForce.GTC;
    }

    // ============================================================
    // P3: Post-Only å’Œå¸‚ä»·å•å†²çªæ£€æŸ¥
    // ============================================================
    if (postOnly && (orderType === OrderType.MARKET || priceBigInt === 0n)) {
      return errorResponse("Post-Only orders cannot be market orders");
    }

    // Submit to matching engine with P3 options
    const { order, matches, rejected, rejectReason } = engine.submitOrder(
      trader as Address,
      token as Address,
      isLong,
      sizeBigInt,
      leverageBigInt,
      priceBigInt,
      deadlineBigInt,
      nonceBigInt,
      orderType as OrderType,
      signature as Hex,
      {
        reduceOnly,
        postOnly,
        timeInForce: tif,
      }
    );

    // ============================================================
    // P3: å¤„ç†è¢«æ‹’ç»çš„è®¢å•
    // ============================================================
    if (rejected) {
      console.log(`[API] Order rejected: ${rejectReason}`);
      return jsonResponse({
        success: false,
        orderId: order.id,
        status: order.status,
        rejected: true,
        rejectReason,
      });
    }

    // Update nonce - åŸºäºæäº¤çš„nonceæ›´æ–°
    if (nonceBigInt >= getUserNonce(trader)) {
      userNonces.set(trader.toLowerCase() as Address, nonceBigInt + 1n);
    }

    console.log(`[API] Order submitted: ${order.id} (${matches.length} matches, postOnly=${postOnly}, timeInForce=${tif})`);

    // Broadcast orderbook update via WebSocket
    broadcastOrderBook(token.toLowerCase() as Address);

    // Broadcast trades via WebSocket and create positions
    for (const match of matches) {
      const trade: Trade = {
        id: `trade_${Date.now()}_${Math.random().toString(36).slice(2)}`,
        token: token as Address,
        price: match.matchPrice,
        size: match.matchSize,
        side: order.isLong ? "buy" : "sell",
        timestamp: match.timestamp,
        longTrader: match.longOrder.trader,
        shortTrader: match.shortOrder.trader,
      };
      broadcastTrade(trade);

      // åˆ›å»º/æ›´æ–°æŒä»“è®°å½•
      createOrUpdatePosition(
        match.longOrder.trader,
        token as Address,
        true, // isLong
        match.matchSize,
        match.matchPrice,
        match.longOrder.leverage,
        match.shortOrder.trader
      );
      createOrUpdatePosition(
        match.shortOrder.trader,
        token as Address,
        false, // isShort
        match.matchSize,
        match.matchPrice,
        match.shortOrder.leverage,
        match.longOrder.trader
      );

      // ============================================================
      // P5: å¤„ç†æ¨èè¿”ä½£
      // ============================================================
      // è®¡ç®—äº¤æ˜“æ‰‹ç»­è´¹ (0.05% of notional value)
      const tradeValue = (match.matchSize * match.matchPrice) / (10n ** 24n); // 1e6 ç²¾åº¦
      const tradeFee = (tradeValue * 5n) / 10000n; // 0.05%

      // å¤„ç†å¤šå¤´äº¤æ˜“è€…çš„è¿”ä½£
      processTradeCommission(
        match.longOrder.trader,
        trade.id,
        tradeFee,
        tradeValue
      );

      // å¤„ç†ç©ºå¤´äº¤æ˜“è€…çš„è¿”ä½£
      processTradeCommission(
        match.shortOrder.trader,
        trade.id,
        tradeFee,
        tradeValue
      );
    }

    return jsonResponse({
      success: true,
      orderId: order.id,
      status: order.status,
      filledSize: order.filledSize.toString(),
      matches: matches.map((m) => ({
        matchPrice: m.matchPrice.toString(),
        matchSize: m.matchSize.toString(),
        counterparty: order.isLong ? m.shortOrder.trader : m.longOrder.trader,
      })),
    });
  } catch (e) {
    console.error("[API] Order submit error:", e);
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

async function handleGetNonce(trader: string): Promise<Response> {
  const nonce = getUserNonce(trader as Address);
  return jsonResponse({ nonce: nonce.toString() });
}

async function handleGetOrderBook(token: string): Promise<Response> {
  const orderBook = engine.getOrderBook(token as Address);
  const depth = orderBook.getDepth(20);
  const currentPrice = orderBook.getCurrentPrice();

  return jsonResponse({
    longs: depth.longs.map((level) => ({
      price: level.price.toString(),
      size: level.totalSize.toString(),
      count: level.orders.length,
    })),
    shorts: depth.shorts.map((level) => ({
      price: level.price.toString(),
      size: level.totalSize.toString(),
      count: level.orders.length,
    })),
    lastPrice: currentPrice.toString(),
  });
}

async function handleGetTrades(token: string, url: URL): Promise<Response> {
  const limit = parseInt(url.searchParams.get("limit") || "100");
  const trades = engine.getRecentTrades(token as Address, limit);

  return jsonResponse({
    trades: trades.map((t) => ({
      id: t.id,
      token: t.token,
      price: t.price.toString(),
      size: t.size.toString(),
      side: t.side,
      timestamp: t.timestamp,
    })),
  });
}

async function handleGetUserOrders(trader: string): Promise<Response> {
  const orders = engine.getUserOrders(trader as Address);

  // è¿”å›å®Œæ•´çš„è®¢å•ä¿¡æ¯ (è¡Œä¸šæ ‡å‡† - å‚è€ƒ OKX/Binance)
  return jsonResponse(
    orders.map((o) => ({
      // === åŸºæœ¬æ ‡è¯† ===
      id: o.id,
      clientOrderId: o.clientOrderId || null,
      token: o.token,

      // === è®¢å•å‚æ•° ===
      isLong: o.isLong,
      size: o.size.toString(),
      leverage: o.leverage.toString(),
      price: o.price.toString(),
      orderType: o.orderType === 0 ? "MARKET" : "LIMIT",
      timeInForce: o.timeInForce || "GTC",
      reduceOnly: o.reduceOnly || false,

      // === æˆäº¤ä¿¡æ¯ ===
      status: o.status,
      filledSize: o.filledSize.toString(),
      avgFillPrice: (o.avgFillPrice || 0n).toString(),
      totalFillValue: (o.totalFillValue || 0n).toString(),

      // === è´¹ç”¨ä¿¡æ¯ ===
      fee: (o.fee || 0n).toString(),
      feeCurrency: o.feeCurrency || "USDT",

      // === ä¿è¯é‡‘ä¿¡æ¯ ===
      margin: (o.margin || 0n).toString(),
      collateral: (o.collateral || 0n).toString(),

      // === æ­¢ç›ˆæ­¢æŸ ===
      takeProfitPrice: o.takeProfitPrice ? o.takeProfitPrice.toString() : null,
      stopLossPrice: o.stopLossPrice ? o.stopLossPrice.toString() : null,

      // === æ—¶é—´æˆ³ ===
      createdAt: o.createdAt,
      updatedAt: o.updatedAt || o.createdAt,
      lastFillTime: o.lastFillTime || null,

      // === æ¥æº ===
      source: o.source || "API",

      // === æœ€åæˆäº¤æ˜ç»† ===
      lastFillPrice: o.lastFillPrice ? o.lastFillPrice.toString() : null,
      lastFillSize: o.lastFillSize ? o.lastFillSize.toString() : null,
      tradeId: o.tradeId || null,
    }))
  );
}

async function handleCancelOrder(req: Request, orderId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { trader, signature } = body;

    if (!trader || !signature) {
      return errorResponse("Missing required fields");
    }

    // å…ˆè·å–è®¢å•ä¿¡æ¯ï¼ˆç”¨äºå¹¿æ’­æ›´æ–°ï¼‰
    const order = engine.getOrder(orderId);
    if (!order) {
      return errorResponse("Order not found");
    }

    // TODO: Verify cancel signature
    const success = engine.cancelOrder(orderId, trader as Address);

    if (!success) {
      return errorResponse("Order not found or cannot be cancelled");
    }

    console.log(`[API] Order cancelled: ${orderId}`);

    // å¹¿æ’­è®¢å•ç°¿æ›´æ–°
    broadcastOrderBook(order.token.toLowerCase() as Address);

    return jsonResponse({ success: true });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * Get user's CURRENT positions (real-time state)
 *
 * RESPONSIBILITY: Returns active positions tracked in memory from recent matches.
 * This is the real-time view of open positions.
 *
 * For historical positions (closed, liquidated), use Go Backend:
 * GET /api/v1/account/positions-history
 */
async function handleGetUserPositions(trader: string): Promise<Response> {
  const normalizedTrader = trader.toLowerCase() as Address;
  const positions = userPositions.get(normalizedTrader) || [];
  return jsonResponse(positions);
}

/**
 * è·å–ç”¨æˆ·ä½™é¢ (ä»é“¾ä¸Šè¯»å– + åç«¯è®¡ç®— UPNL)
 * GET /api/user/:trader/balance
 *
 * æ•°æ®æ¥æºï¼š
 * - available, locked: ä»é“¾ä¸Š Settlement åˆçº¦è¯»å– (source of truth)
 * - unrealizedPnL: åç«¯å®æ—¶è®¡ç®— (åŸºäºå½“å‰ä»·æ ¼)
 */
async function handleGetUserBalance(trader: string): Promise<Response> {
  const normalizedTrader = trader.toLowerCase() as Address;

  // ========================================
  // 1. ä»é“¾ä¸Šè¯»å–ä½™é¢ (source of truth)
  // ========================================
  let availableBalance = 0n;
  let lockedBalance = 0n;

  try {
    const publicClient = createPublicClient({
      chain: baseSepolia,
      transport: http(RPC_URL),
    });

    if (SETTLEMENT_ADDRESS) {
      const [available, locked] = await publicClient.readContract({
        address: SETTLEMENT_ADDRESS,
        abi: SETTLEMENT_ABI,
        functionName: "getUserBalance",
        args: [normalizedTrader],
      }) as [bigint, bigint];

      availableBalance = available;
      lockedBalance = locked;
      console.log(`[Balance] Chain balance for ${normalizedTrader.slice(0, 10)}: available=$${Number(available) / 1e6}, locked=$${Number(locked) / 1e6}`);
    }
  } catch (e) {
    console.error(`[Balance] Failed to fetch chain balance for ${normalizedTrader}:`, e);
    // é“¾ä¸Šè¯»å–å¤±è´¥æ—¶ï¼Œä½¿ç”¨åç«¯ç¼“å­˜
    const cachedBalance = getUserBalance(normalizedTrader);
    availableBalance = cachedBalance.availableBalance;
    lockedBalance = cachedBalance.usedMargin;
  }

  // ========================================
  // 2. åç«¯è®¡ç®—æœªå®ç°ç›ˆäº (åŸºäºå®æ—¶ä»·æ ¼)
  // ========================================
  const positions = userPositions.get(normalizedTrader) || [];
  let totalPnL = 0n;

  for (const pos of positions) {
    const orderBook = engine.getOrderBook(pos.token as Address);
    const currentPrice = orderBook.getCurrentPrice();
    const pnl = calculateUnrealizedPnL(
      BigInt(pos.size),
      BigInt(pos.entryPrice),
      currentPrice,
      pos.isLong
    );
    totalPnL += pnl;
  }

  // ========================================
  // 3. è®¡ç®—è´¦æˆ·æƒç›Š
  // ========================================
  const totalBalance = availableBalance + lockedBalance;
  const equity = availableBalance + lockedBalance + totalPnL;

  return jsonResponse({
    // é“¾ä¸Šæ•°æ®
    totalBalance: totalBalance.toString(),
    availableBalance: availableBalance.toString(),
    usedMargin: lockedBalance.toString(),
    frozenMargin: "0", // é“¾ä¸Šæ²¡æœ‰å†»ç»“æ¦‚å¿µï¼Œæš‚æ—¶ä¸º 0
    // åç«¯è®¡ç®—æ•°æ®
    unrealizedPnL: totalPnL.toString(),
    equity: equity.toString(),
    positionCount: positions.length,
    // æ•°æ®æ¥æºæ ‡è®°
    source: "chain",
    // äººç±»å¯è¯»æ ¼å¼
    display: {
      totalBalance: `$${(Number(totalBalance) / 1e6).toFixed(2)}`,
      availableBalance: `$${(Number(availableBalance) / 1e6).toFixed(2)}`,
      usedMargin: `$${(Number(lockedBalance) / 1e6).toFixed(2)}`,
      unrealizedPnL: `$${(Number(totalPnL) / 1e6).toFixed(2)}`,
      equity: `$${(Number(equity) / 1e6).toFixed(2)}`,
    }
  });
}

/**
 * å……å€¼ (æµ‹è¯•ç”¨)
 * POST /api/user/:trader/deposit
 * Body: { amount: "1000000000" } // 1e6 ç²¾åº¦, 1000 USD
 */
async function handleDeposit(req: Request, trader: string): Promise<Response> {
  try {
    const body = await req.json();
    const { amount } = body;

    if (!amount) {
      return errorResponse("Missing amount");
    }

    const amountBigInt = BigInt(amount);
    if (amountBigInt <= 0n) {
      return errorResponse("Amount must be positive");
    }

    const normalizedTrader = trader.toLowerCase() as Address;
    deposit(normalizedTrader, amountBigInt);

    const balance = getUserBalance(normalizedTrader);
    return jsonResponse({
      success: true,
      message: `Deposited $${Number(amountBigInt) / 1e6}`,
      balance: {
        totalBalance: balance.totalBalance.toString(),
        availableBalance: balance.availableBalance.toString(),
      }
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * æç°
 * POST /api/user/:trader/withdraw
 * Body: { amount: "1000000000" } // 1e6 ç²¾åº¦
 */
async function handleWithdraw(req: Request, trader: string): Promise<Response> {
  try {
    const body = await req.json();
    const { amount } = body;

    if (!amount) {
      return errorResponse("Missing amount");
    }

    const amountBigInt = BigInt(amount);
    if (amountBigInt <= 0n) {
      return errorResponse("Amount must be positive");
    }

    const normalizedTrader = trader.toLowerCase() as Address;
    const success = withdraw(normalizedTrader, amountBigInt);

    if (!success) {
      return errorResponse("Insufficient available balance");
    }

    const balance = getUserBalance(normalizedTrader);
    return jsonResponse({
      success: true,
      message: `Withdrew $${Number(amountBigInt) / 1e6}`,
      balance: {
        totalBalance: balance.totalBalance.toString(),
        availableBalance: balance.availableBalance.toString(),
      }
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å¹³ä»“å¤„ç† (æ”¯æŒéƒ¨åˆ†å¹³ä»“)
 *
 * POST /api/position/:pairId/close
 * Body: {
 *   trader: Address,
 *   closeRatio?: number,  // 0-1, é»˜è®¤ 1 (å…¨éƒ¨å¹³ä»“)
 *   closeSize?: string,   // æˆ–ç›´æ¥æŒ‡å®šå¹³ä»“æ•°é‡
 * }
 */
async function handleClosePair(req: Request, pairId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { trader, closeRatio = 1, closeSize } = body;

    if (!trader) {
      return errorResponse("Missing trader address");
    }

    const normalizedTrader = trader.toLowerCase() as Address;

    // æŸ¥æ‰¾ä»“ä½
    const positions = userPositions.get(normalizedTrader) || [];
    const position = positions.find(p => p.pairId === pairId);

    if (!position) {
      return errorResponse("Position not found");
    }

    const currentSize = BigInt(position.size);
    const token = position.token.toLowerCase() as Address;
    const orderBook = engine.getOrderBook(token);
    const currentPrice = orderBook.getCurrentPrice();

    // è®¡ç®—å¹³ä»“æ•°é‡
    let sizeToClose: bigint;
    if (closeSize) {
      sizeToClose = BigInt(closeSize);
    } else {
      sizeToClose = (currentSize * BigInt(Math.floor(closeRatio * 10000))) / 10000n;
    }

    // éªŒè¯å¹³ä»“æ•°é‡
    if (sizeToClose <= 0n) {
      return errorResponse("Invalid close size");
    }
    if (sizeToClose > currentSize) {
      sizeToClose = currentSize;
    }

    const isFullClose = sizeToClose >= currentSize;
    const closeRatioActual = Number(sizeToClose) / Number(currentSize);

    console.log(`[Close] pairId=${pairId} trader=${normalizedTrader.slice(0, 10)} ratio=${(closeRatioActual * 100).toFixed(2)}% isFullClose=${isFullClose}`);

    // è®¡ç®—å¹³ä»“ PnL (æŒ‰æ¯”ä¾‹)
    const totalUpnl = BigInt(position.unrealizedPnL);
    const closePnL = (totalUpnl * sizeToClose) / currentSize;

    // è®¡ç®—é‡Šæ”¾çš„ä¿è¯é‡‘ (æŒ‰æ¯”ä¾‹)
    const totalCollateral = BigInt(position.collateral);
    const releasedCollateral = (totalCollateral * sizeToClose) / currentSize;

    // è®¡ç®—å¹³ä»“æ‰‹ç»­è´¹ (0.05%)
    const positionValue = (sizeToClose * currentPrice) / (10n ** 24n);
    const closeFee = (positionValue * 5n) / 10000n;

    // å®é™…è¿”è¿˜é‡‘é¢ = é‡Šæ”¾ä¿è¯é‡‘ + PnL - æ‰‹ç»­è´¹
    const returnAmount = releasedCollateral + closePnL - closeFee;

    console.log(`[Close] PnL=$${Number(closePnL) / 1e6} collateral=$${Number(releasedCollateral) / 1e6} fee=$${Number(closeFee) / 1e6} return=$${Number(returnAmount) / 1e6}`);

    if (isFullClose) {
      // å…¨éƒ¨å¹³ä»“ - æäº¤åˆ°é“¾ä¸Š
      if (submitter) {
        try {
          // è°ƒç”¨é“¾ä¸Š closePair
          const hash = await submitter.closePair(BigInt(pairId), currentPrice);
          console.log(`[Close] Submitted to chain: ${hash}`);
        } catch (e) {
          console.error(`[Close] Chain submission failed:`, e);
          // ç»§ç»­å¤„ç†ï¼Œåç«¯å…ˆæ›´æ–°
        }
      }

      // ä»ç”¨æˆ·ä»“ä½åˆ—è¡¨ä¸­ç§»é™¤
      const updatedPositions = positions.filter(p => p.pairId !== pairId);
      userPositions.set(normalizedTrader, updatedPositions);

      // å¹¿æ’­å¹³ä»“äº‹ä»¶
      broadcastPositionClosed(position, currentPrice, closePnL);

      return jsonResponse({
        success: true,
        type: "full_close",
        pairId,
        closedSize: sizeToClose.toString(),
        exitPrice: currentPrice.toString(),
        realizedPnL: closePnL.toString(),
        closeFee: closeFee.toString(),
        returnAmount: returnAmount.toString(),
      });
    } else {
      // éƒ¨åˆ†å¹³ä»“ - æ›´æ–°åç«¯ä»“ä½çŠ¶æ€
      const remainingSize = currentSize - sizeToClose;
      const remainingCollateral = totalCollateral - releasedCollateral;

      // æ›´æ–°ä»“ä½
      position.size = remainingSize.toString();
      position.collateral = remainingCollateral.toString();
      position.margin = remainingCollateral.toString();
      position.realizedPnL = (BigInt(position.realizedPnL || "0") + closePnL).toString();
      position.updatedAt = Date.now();

      // é‡æ–°è®¡ç®—å‰©ä½™ä»“ä½çš„æŒ‡æ ‡
      const newUpnl = totalUpnl - closePnL;
      position.unrealizedPnL = newUpnl.toString();

      // é‡æ–°è®¡ç®— ROE
      if (remainingCollateral > 0n) {
        position.roe = ((newUpnl * 10000n) / remainingCollateral).toString();
      }

      // å¹¿æ’­éƒ¨åˆ†å¹³ä»“äº‹ä»¶
      broadcastPartialClose(position, sizeToClose, currentPrice, closePnL);

      return jsonResponse({
        success: true,
        type: "partial_close",
        pairId,
        closedSize: sizeToClose.toString(),
        remainingSize: remainingSize.toString(),
        exitPrice: currentPrice.toString(),
        realizedPnL: closePnL.toString(),
        closeFee: closeFee.toString(),
        returnAmount: returnAmount.toString(),
      });
    }
  } catch (e) {
    console.error("[Close] Error:", e);
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å¹¿æ’­å…¨éƒ¨å¹³ä»“äº‹ä»¶
 */
function broadcastPositionClosed(position: Position, exitPrice: bigint, pnl: bigint): void {
  const message = JSON.stringify({
    type: "position_closed",
    pairId: position.pairId,
    trader: position.trader,
    token: position.token,
    isLong: position.isLong,
    exitPrice: exitPrice.toString(),
    realizedPnL: pnl.toString(),
    timestamp: Date.now(),
  });

  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  }
}

/**
 * å¹¿æ’­éƒ¨åˆ†å¹³ä»“äº‹ä»¶
 */
function broadcastPartialClose(position: Position, closedSize: bigint, exitPrice: bigint, pnl: bigint): void {
  const message = JSON.stringify({
    type: "partial_close",
    pairId: position.pairId,
    trader: position.trader,
    token: position.token,
    isLong: position.isLong,
    closedSize: closedSize.toString(),
    remainingSize: position.size,
    exitPrice: exitPrice.toString(),
    realizedPnL: pnl.toString(),
    timestamp: Date.now(),
  });

  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  }
}

async function handleUpdatePrice(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { token, price } = body;

    if (!token || !price) {
      return errorResponse("Missing token or price");
    }

    const priceBigInt = BigInt(price);
    engine.updatePrice(token as Address, priceBigInt);

    // Update on-chain if submitter is available
    if (submitter) {
      const hash = await submitter.updatePrice(token as Address, priceBigInt);
      console.log(`[API] Price updated on-chain: ${hash}`);
    }

    return jsonResponse({ success: true, price: priceBigInt.toString() });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * Get K-line (candlestick) data
 */
async function handleGetKlines(token: string, url: URL): Promise<Response> {
  const interval = url.searchParams.get("interval") || "1m";
  const limit = parseInt(url.searchParams.get("limit") || "100");

  const klines = engine.getKlines(token as Address, interval, limit);

  return jsonResponse({
    klines: klines.map(k => ({
      timestamp: k.timestamp,
      open: k.open.toString(),
      high: k.high.toString(),
      low: k.low.toString(),
      close: k.close.toString(),
      volume: k.volume.toString(),
      trades: k.trades,
    })),
  });
}

/**
 * Get token statistics
 */
async function handleGetStats(token: string): Promise<Response> {
  const stats = engine.getStats(token as Address);

  return jsonResponse({
    price: stats.price.toString(),
    priceChange24h: stats.priceChange24h.toString(),
    high24h: stats.high24h.toString(),
    low24h: stats.low24h.toString(),
    volume24h: stats.volume24h.toString(),
    trades24h: stats.trades24h,
    openInterest: stats.openInterest.toString(),
    fundingRate: stats.fundingRate.toString(),
    nextFundingTime: stats.nextFundingTime,
  });
}

/**
 * Get funding rate
 */
async function handleGetFundingRate(token: string): Promise<Response> {
  const { rate, nextFundingTime } = engine.getFundingRate(token as Address);

  return jsonResponse({
    rate: rate.toString(),
    nextFundingTime,
    interval: "8h",
  });
}

// ============================================================
// çŒæ€åœº API
// ============================================================

/**
 * è®¡ç®—æ¸…ç®—ä»·æ ¼
 * ä½¿ç”¨ Bybit è¡Œä¸šæ ‡å‡†å…¬å¼:
 * å¤šå¤´: liqPrice = entryPrice * (1 - 1/leverage + MMR)
 * ç©ºå¤´: liqPrice = entryPrice * (1 + 1/leverage - MMR)
 *
 * æ³¨æ„: leverage æ˜¯ 1e4 ç²¾åº¦ (10x = 100000)
 */
function calculateLiquidationPrice(
  entryPrice: bigint,
  leverage: bigint,  // 1e4 ç²¾åº¦ (10x = 100000)
  isLong: boolean,
  mmr: bigint = 200n // Meme é»˜è®¤ 2% ç»´æŒä¿è¯é‡‘ç‡ (1e4 ç²¾åº¦, 200 = 2%)
): bigint {
  const PRECISION = 10000n; // åŸºç‚¹ç²¾åº¦

  // leverage æ˜¯ 1e4 ç²¾åº¦, ç›´æ¥ç”¨äºè®¡ç®—
  // 1/leverage = PRECISION / (leverage / PRECISION) = PRECISION * PRECISION / leverage
  // ä¾‹å¦‚: 10x leverage = 100000, inverseLevel = 10000 * 10000 / 100000 = 1000 (è¡¨ç¤º 10%)
  const inverseLevel = (PRECISION * PRECISION) / leverage;

  if (isLong) {
    // å¤šå¤´: liqPrice = entryPrice * (1 - 1/leverage + MMR)
    // 10x å¤šå¤´ (MMR=2%): factor = 10000 - 1000 + 200 = 9200 (92%)
    const factor = PRECISION - inverseLevel + mmr;
    return (entryPrice * factor) / PRECISION;
  } else {
    // ç©ºå¤´: liqPrice = entryPrice * (1 + 1/leverage - MMR)
    // 10x ç©ºå¤´ (MMR=2%): factor = 10000 + 1000 - 200 = 10800 (108%)
    const factor = PRECISION + inverseLevel - mmr;
    return (entryPrice * factor) / PRECISION;
  }
}

/**
 * è®¡ç®—ç©¿ä»“ä»·æ ¼ (Bankruptcy Price)
 *
 * ç©¿ä»“ä»·æ ¼ = ä¿è¯é‡‘å®Œå…¨äºæŸçš„ä»·æ ¼ (MMR = 0)
 *
 * å¤šå¤´: bankruptcyPrice = entryPrice * (1 - 1/leverage)
 * ç©ºå¤´: bankruptcyPrice = entryPrice * (1 + 1/leverage)
 */
function calculateBankruptcyPrice(
  entryPrice: bigint,
  leverage: bigint,  // 1e4 ç²¾åº¦
  isLong: boolean
): bigint {
  const PRECISION = 10000n;
  const inverseLevel = (PRECISION * PRECISION) / leverage;

  if (isLong) {
    // å¤šå¤´ç©¿ä»“ä»· = entryPrice * (1 - 1/leverage)
    // 10x å¤šå¤´: factor = 10000 - 1000 = 9000 (90%)
    const factor = PRECISION - inverseLevel;
    return (entryPrice * factor) / PRECISION;
  } else {
    // ç©ºå¤´ç©¿ä»“ä»· = entryPrice * (1 + 1/leverage)
    // 10x ç©ºå¤´: factor = 10000 + 1000 = 11000 (110%)
    const factor = PRECISION + inverseLevel;
    return (entryPrice * factor) / PRECISION;
  }
}

/**
 * è®¡ç®—æœªå®ç°ç›ˆäº (è¡Œä¸šæ ‡å‡† - GMX/Binance)
 * å…¬å¼: PnL = Size Ã— Direction Ã— (MarkPrice - EntryPrice) - OpenFee
 *
 * å¼€ä»“åä»·æ ¼æ²¡å˜ â†’ PnL = -æ‰‹ç»­è´¹ (æµ®äº)
 *
 * ç²¾åº¦è¯´æ˜:
 * - size: 1e18 (ä»£å¸æ•°é‡)
 * - entryPrice/currentPrice: 1e12 (USDï¼Œæ¥è‡ªè®¢å•ç°¿)
 * - è¿”å›å€¼: 1e6 ç²¾åº¦ (USD)
 */
function calculateUnrealizedPnL(
  size: bigint,         // 1e18 ç²¾åº¦ (ä»£å¸æ•°é‡)
  entryPrice: bigint,   // 1e12 ç²¾åº¦ (æ¥è‡ªè®¢å•ç°¿)
  currentPrice: bigint, // 1e12 ç²¾åº¦ (æ¥è‡ªè®¢å•ç°¿)
  isLong: boolean
): bigint {
  // 1. è®¡ç®—ä»·æ ¼å˜åŠ¨å¸¦æ¥çš„ç›ˆäº
  // PnL = size * (currentPrice - entryPrice) * direction
  // å•ä½è½¬æ¢: size(1e18) * priceDiff(1e12) / 1e24 = 1e6 ç²¾åº¦
  let pricePnL: bigint;
  if (isLong) {
    pricePnL = (size * (currentPrice - entryPrice)) / (10n ** 24n);
  } else {
    pricePnL = (size * (entryPrice - currentPrice)) / (10n ** 24n);
  }

  // 2. è®¡ç®—å¼€ä»“æ‰‹ç»­è´¹ (0.05% of position value)
  // positionValue = size * entryPrice / 1e24 (USD, 1e6 ç²¾åº¦)
  const positionValue = (size * entryPrice) / (10n ** 24n);
  const openFee = (positionValue * 5n) / 10000n; // 0.05%

  // 3. æœªå®ç°ç›ˆäº = ä»·æ ¼ç›ˆäº - æ‰‹ç»­è´¹
  return pricePnL - openFee;
}

/**
 * è®¡ç®—ä¿è¯é‡‘ç‡ (è¡Œä¸šæ ‡å‡† - Binance/OKX)
 * å…¬å¼: ä¿è¯é‡‘ç‡ = ç»´æŒä¿è¯é‡‘ / è´¦æˆ·æƒç›Š
 *
 * è§¦å‘æ¡ä»¶: ä¿è¯é‡‘ç‡ >= 100% æ—¶è§¦å‘å¼ºå¹³
 * è¶Šå°è¶Šå®‰å…¨ï¼Œè¶Šå¤§è¶Šå±é™©
 *
 * ç²¾åº¦è¯´æ˜:
 * - collateral: 1e6 (USD)
 * - size: 1e18 (ä»£å¸æ•°é‡)
 * - entryPrice/currentPrice: 1e18 (USDï¼Œå‰ç«¯ç”¨ parseEther)
 * - è¿”å›å€¼: 1e4 ç²¾åº¦ (10000 = 100%)
 */
function calculateMarginRatio(
  collateral: bigint,   // 1e6 ç²¾åº¦ (USD) - åˆå§‹ä¿è¯é‡‘
  size: bigint,         // 1e18 ç²¾åº¦ (ä»£å¸æ•°é‡)
  entryPrice: bigint,   // 1e12 ç²¾åº¦ (æ¥è‡ªè®¢å•ç°¿)
  currentPrice: bigint, // 1e12 ç²¾åº¦ (æ¥è‡ªè®¢å•ç°¿)
  isLong: boolean,
  mmr: bigint = 50n     // ç»´æŒä¿è¯é‡‘ç‡ 0.5% (1e4 ç²¾åº¦, 50 = 0.5%)
): bigint {
  if (size === 0n || currentPrice === 0n) return 0n; // æ— ä»“ä½ï¼Œ0%é£é™©

  // è®¡ç®—ä»“ä½ä»·å€¼ (USD, 1e6 ç²¾åº¦)
  // size(1e18) * currentPrice(1e12) / 1e24 = 1e6 ç²¾åº¦
  const positionValue = (size * currentPrice) / (10n ** 24n);
  if (positionValue === 0n) return 0n;

  // è®¡ç®—ç»´æŒä¿è¯é‡‘ = ä»“ä½ä»·å€¼ * MMR
  // maintenanceMargin = positionValue * mmr / 10000
  const maintenanceMargin = (positionValue * mmr) / 10000n;

  // è®¡ç®—æœªå®ç°ç›ˆäº (è¡Œä¸šæ ‡å‡†)
  const pnl = calculateUnrealizedPnL(size, entryPrice, currentPrice, isLong);

  // è´¦æˆ·æƒç›Š = åˆå§‹ä¿è¯é‡‘ + æœªå®ç°ç›ˆäº
  const equity = collateral + pnl;
  if (equity <= 0n) return 100000n; // æƒç›Šä¸ºè´Ÿï¼Œè¿”å› 1000% (å·²çˆ†ä»“)

  // ä¿è¯é‡‘ç‡ = ç»´æŒä¿è¯é‡‘ / è´¦æˆ·æƒç›Š * 10000 (1e4 ç²¾åº¦)
  // è¶Šå°è¶Šå®‰å…¨ï¼Œ>= 10000 (100%) è§¦å‘å¼ºå¹³
  return (maintenanceMargin * 10000n) / equity;
}

/**
 * è·å–æ¸…ç®—åœ°å›¾
 * æ˜¾ç¤ºå„ä»·æ ¼ç‚¹çš„æ¸…ç®—é‡åˆ†å¸ƒ
 */
async function handleGetLiquidationMap(token: string): Promise<Response> {
  const normalizedToken = token.toLowerCase() as Address;
  const currentPrice = engine.getOrderBook(normalizedToken).getCurrentPrice();

  // æ”¶é›†æ‰€æœ‰æŒä»“çš„æ¸…ç®—ä»·æ ¼
  const longLiquidations: Map<string, { size: bigint; accounts: number }> = new Map();
  const shortLiquidations: Map<string, { size: bigint; accounts: number }> = new Map();

  for (const [trader, positions] of userPositions) {
    for (const pos of positions) {
      if (pos.token.toLowerCase() !== normalizedToken) continue;

      const liqPrice = pos.liquidationPrice;
      // æŒ‰ä»·æ ¼åˆ†ç»„ï¼ˆç²¾åº¦é™ä½ä»¥ä¾¿èšåˆï¼‰
      const priceKey = roundPrice(BigInt(liqPrice));

      if (pos.isLong) {
        const existing = longLiquidations.get(priceKey) || { size: 0n, accounts: 0 };
        longLiquidations.set(priceKey, {
          size: existing.size + BigInt(pos.size),
          accounts: existing.accounts + 1,
        });
      } else {
        const existing = shortLiquidations.get(priceKey) || { size: 0n, accounts: 0 };
        shortLiquidations.set(priceKey, {
          size: existing.size + BigInt(pos.size),
          accounts: existing.accounts + 1,
        });
      }
    }
  }

  // è½¬æ¢ä¸ºæ•°ç»„å¹¶æ’åº
  const longs = Array.from(longLiquidations.entries())
    .map(([price, data]) => ({
      price,
      size: data.size.toString(),
      accounts: data.accounts,
    }))
    .sort((a, b) => Number(BigInt(b.price) - BigInt(a.price))); // ä»é«˜åˆ°ä½

  const shorts = Array.from(shortLiquidations.entries())
    .map(([price, data]) => ({
      price,
      size: data.size.toString(),
      accounts: data.accounts,
    }))
    .sort((a, b) => Number(BigInt(a.price) - BigInt(b.price))); // ä»ä½åˆ°é«˜

  return jsonResponse({
    token: normalizedToken,
    currentPrice: currentPrice.toString(),
    longs, // å¤šå¤´æ¸…ç®—ç‚¹ï¼ˆä»·æ ¼ä½äºå½“å‰ä»·ï¼‰
    shorts, // ç©ºå¤´æ¸…ç®—ç‚¹ï¼ˆä»·æ ¼é«˜äºå½“å‰ä»·ï¼‰
    totalLongSize: longs.reduce((sum, l) => sum + BigInt(l.size), 0n).toString(),
    totalShortSize: shorts.reduce((sum, s) => sum + BigInt(s.size), 0n).toString(),
    totalLongAccounts: longs.reduce((sum, l) => sum + l.accounts, 0),
    totalShortAccounts: shorts.reduce((sum, s) => sum + s.accounts, 0),
  });
}

/**
 * ä»·æ ¼å››èˆäº”å…¥ï¼ˆç”¨äºèšåˆï¼‰
 */
function roundPrice(price: bigint): string {
  // æŒ‰ 1% ç²¾åº¦èšåˆ
  const precision = price / 100n;
  if (precision === 0n) return price.toString();
  return ((price / precision) * precision).toString();
}

/**
 * è·å–å…¨å±€æŒä»“åˆ—è¡¨
 * å…¬å¼€æ‰€æœ‰ç”¨æˆ·çš„æŒä»“ä¿¡æ¯
 */
async function handleGetAllPositions(token: string): Promise<Response> {
  const normalizedToken = token.toLowerCase() as Address;
  const currentPrice = engine.getOrderBook(normalizedToken).getCurrentPrice();

  const allPositions: Array<{
    trader: string;
    isLong: boolean;
    size: string;
    entryPrice: string;
    collateral: string;
    leverage: string;
    liquidationPrice: string;
    marginRatio: string;
    unrealizedPnL: string;
    riskLevel: string; // "safe" | "warning" | "danger"
  }> = [];

  for (const [trader, positions] of userPositions) {
    for (const pos of positions) {
      if (pos.token.toLowerCase() !== normalizedToken) continue;

      // è®¡ç®—å®æ—¶ä¿è¯é‡‘ç‡ (è¡Œä¸šæ ‡å‡†: ç»´æŒä¿è¯é‡‘/æƒç›Š, è¶Šå¤§è¶Šå±é™©)
      const marginRatio = calculateMarginRatio(
        BigInt(pos.collateral),
        BigInt(pos.size),
        BigInt(pos.entryPrice),
        currentPrice,
        pos.isLong
      );

      // è®¡ç®—æœªå®ç°ç›ˆäº (è¡Œä¸šæ ‡å‡†: Size Ã— (Mark - Entry))
      const pnl = calculateUnrealizedPnL(
        BigInt(pos.size),
        BigInt(pos.entryPrice),
        currentPrice,
        pos.isLong
      );

      // é£é™©ç­‰çº§ (ä¿è¯é‡‘ç‡è¶Šå¤§è¶Šå±é™©ï¼Œ>=100%å¼ºå¹³)
      let riskLevel: string;
      if (marginRatio < 5000n) {
        riskLevel = "safe"; // < 50%
      } else if (marginRatio < 8000n) {
        riskLevel = "warning"; // 50-80%
      } else {
        riskLevel = "danger"; // >= 80% (æ¥è¿‘å¼ºå¹³)
      }

      allPositions.push({
        trader: trader,
        isLong: pos.isLong,
        size: pos.size,
        entryPrice: pos.entryPrice,
        collateral: pos.collateral,
        leverage: pos.leverage,
        liquidationPrice: pos.liquidationPrice,
        marginRatio: marginRatio.toString(),
        unrealizedPnL: pnl.toString(),
        riskLevel,
      });
    }
  }

  // æŒ‰é£é™©ç­‰çº§æ’åºï¼ˆdanger ä¼˜å…ˆï¼‰
  allPositions.sort((a, b) => {
    const riskOrder = { danger: 0, warning: 1, safe: 2 };
    return riskOrder[a.riskLevel as keyof typeof riskOrder] - riskOrder[b.riskLevel as keyof typeof riskOrder];
  });

  return jsonResponse({
    token: normalizedToken,
    currentPrice: currentPrice.toString(),
    positions: allPositions,
    totalPositions: allPositions.length,
    dangerCount: allPositions.filter(p => p.riskLevel === "danger").length,
    warningCount: allPositions.filter(p => p.riskLevel === "warning").length,
  });
}

/**
 * è·å–æ¸…ç®—å†å²
 */
async function handleGetLiquidations(token: string, url: URL): Promise<Response> {
  const normalizedToken = token.toLowerCase() as Address;
  const limit = parseInt(url.searchParams.get("limit") || "50");

  const history = liquidationHistory.get(normalizedToken) || [];
  const recentHistory = history.slice(-limit).reverse(); // æœ€æ–°çš„åœ¨å‰

  return jsonResponse({
    token: normalizedToken,
    liquidations: recentHistory,
    total: history.length,
  });
}

/**
 * è·å–çŒæ€æ’è¡Œæ¦œ
 */
async function handleGetHunterLeaderboard(url: URL): Promise<Response> {
  const period = url.searchParams.get("period") || "all"; // "24h" | "7d" | "all"
  const limit = parseInt(url.searchParams.get("limit") || "20");

  let hunters = Array.from(hunterStats.values());

  // æŒ‰æ—¶é—´ç­›é€‰
  if (period !== "all") {
    const now = Date.now();
    const cutoff = period === "24h" ? now - 24 * 60 * 60 * 1000 : now - 7 * 24 * 60 * 60 * 1000;
    hunters = hunters.filter(h => h.lastKillTime >= cutoff);
  }

  // æŒ‰çŒæ€æ•°é‡æ’åº
  hunters.sort((a, b) => b.totalKills - a.totalKills);

  return jsonResponse({
    period,
    hunters: hunters.slice(0, limit).map((h, index) => ({
      rank: index + 1,
      address: h.address,
      kills: h.totalKills,
      profit: h.totalProfitUSD,
      lastKill: h.lastKillTime,
    })),
    totalHunters: hunterStats.size,
    totalLiquidations: globalLiquidationCount,
  });
}

/**
 * è®°å½•æ¸…ç®—äº‹ä»¶
 */
function recordLiquidation(
  token: Address,
  liquidatedTrader: Address,
  liquidator: Address,
  position: Position,
  liquidationPrice: bigint
): void {
  const record: LiquidationRecord = {
    id: `liq_${Date.now()}_${globalLiquidationCount++}`,
    token,
    liquidatedTrader,
    liquidator,
    isLong: position.isLong,
    size: position.size,
    entryPrice: position.entryPrice,
    liquidationPrice: liquidationPrice.toString(),
    collateralLost: position.collateral,
    timestamp: Date.now(),
  };

  // æ·»åŠ åˆ°å†å²è®°å½•
  const history = liquidationHistory.get(token) || [];
  history.push(record);
  if (history.length > 1000) history.shift(); // ä¿ç•™æœ€è¿‘ 1000 æ¡
  liquidationHistory.set(token, history);

  // æ›´æ–°çŒæ€è€…ç»Ÿè®¡
  const hunter = hunterStats.get(liquidator) || {
    address: liquidator,
    totalKills: 0,
    totalProfitUSD: "0",
    lastKillTime: 0,
  };
  hunter.totalKills += 1;
  hunter.totalProfitUSD = (BigInt(hunter.totalProfitUSD) + BigInt(position.collateral) / 10n).toString(); // å‡è®¾è·å¾— 10% å¥–åŠ±
  hunter.lastKillTime = Date.now();
  hunterStats.set(liquidator, hunter);

  // å¹¿æ’­æ¸…ç®—äº‹ä»¶
  broadcastLiquidation(token, record);

  console.log(`[Liquidation] ğŸ”¥ ${liquidatedTrader.slice(0, 10)} was liquidated by ${liquidator.slice(0, 10)}`);
}

/**
 * å¹¿æ’­æ¸…ç®—äº‹ä»¶åˆ° WebSocket
 */
function broadcastLiquidation(token: Address, record: LiquidationRecord): void {
  if (!wss) return;

  const message = JSON.stringify({
    type: "liquidation",
    token,
    data: record,
  });

  for (const [ws, tokens] of wsClients) {
    if (tokens.has(token.toLowerCase() as Address) && ws.readyState === WebSocket.OPEN) {
      ws.send(message);
    }
  }
}

// ============================================================
// ä¿é™©åŸºé‡‘ & Oracle API Handlers (P1)
// ============================================================

/**
 * è·å–å…¨å±€ä¿é™©åŸºé‡‘çŠ¶æ€
 * GET /api/insurance-fund
 */
async function handleGetInsuranceFund(): Promise<Response> {
  return jsonResponse({
    balance: insuranceFund.balance.toString(),
    totalContributions: insuranceFund.totalContributions.toString(),
    totalPayouts: insuranceFund.totalPayouts.toString(),
    lastUpdated: insuranceFund.lastUpdated,
    display: {
      balance: `$${(Number(insuranceFund.balance) / 1e6).toFixed(2)}`,
      totalContributions: `$${(Number(insuranceFund.totalContributions) / 1e6).toFixed(2)}`,
      totalPayouts: `$${(Number(insuranceFund.totalPayouts) / 1e6).toFixed(2)}`,
    },
    tokenFunds: Array.from(tokenInsuranceFunds.entries()).map(([token, fund]) => ({
      token,
      balance: fund.balance.toString(),
      display: `$${(Number(fund.balance) / 1e6).toFixed(2)}`,
    })),
  });
}

/**
 * è·å–ä»£å¸ä¿é™©åŸºé‡‘çŠ¶æ€
 * GET /api/insurance-fund/:token
 */
async function handleGetTokenInsuranceFund(token: string): Promise<Response> {
  const normalizedToken = token.toLowerCase() as Address;
  const fund = getTokenInsuranceFund(normalizedToken);

  return jsonResponse({
    token: normalizedToken,
    balance: fund.balance.toString(),
    totalContributions: fund.totalContributions.toString(),
    totalPayouts: fund.totalPayouts.toString(),
    lastUpdated: fund.lastUpdated,
    display: {
      balance: `$${(Number(fund.balance) / 1e6).toFixed(2)}`,
      totalContributions: `$${(Number(fund.totalContributions) / 1e6).toFixed(2)}`,
      totalPayouts: `$${(Number(fund.totalPayouts) / 1e6).toFixed(2)}`,
    },
  });
}

// ============================================================
// Dynamic Funding API Handlers (P1)
// ============================================================

/**
 * è·å–åŠ¨æ€èµ„é‡‘è´¹ä¿¡æ¯
 * GET /api/dynamic-funding/:token
 */
async function handleGetDynamicFunding(token: string): Promise<Response> {
  const normalizedToken = token.toLowerCase() as Address;
  const config = getTokenFundingConfig(normalizedToken);
  const currentRate = currentFundingRates.get(normalizedToken) || 0n;
  const nextSettlement = nextFundingSettlement.get(normalizedToken) || 0;
  const tracker = volatilityTrackers.get(normalizedToken);
  const { longOI, shortOI } = calculateOpenInterest(normalizedToken);

  // è®¡ç®—åŠ¨æ€å‘¨æœŸ
  const dynamicInterval = getDynamicFundingInterval(normalizedToken);

  // è®¡ç®—å¹´åŒ–è´¹ç‡
  const intervalsPerYear = 365 * 24 * 60 * 60 * 1000 / dynamicInterval;
  const annualizedRate = Number(currentRate) * intervalsPerYear / 100; // ç™¾åˆ†æ¯”

  return jsonResponse({
    token: normalizedToken,
    currentRate: currentRate.toString(),
    config: {
      baseInterval: config.baseInterval,
      minInterval: config.minInterval,
      maxRate: config.maxRate,
      volatilityMultiplier: config.volatilityMultiplier,
      imbalanceMultiplier: config.imbalanceMultiplier,
    },
    dynamics: {
      currentInterval: dynamicInterval,
      volatility: tracker?.volatility || 0,
      longOI: longOI.toString(),
      shortOI: shortOI.toString(),
      imbalanceRatio: longOI + shortOI > 0n
        ? ((Number(longOI - shortOI) / Number(longOI + shortOI)) * 100).toFixed(2)
        : "0",
    },
    nextSettlement,
    annualizedRate: annualizedRate.toFixed(2),
    display: {
      currentRate: `${(Number(currentRate) / 100).toFixed(4)}%`,
      annualizedRate: `${annualizedRate.toFixed(2)}%`,
      nextSettlement: new Date(nextSettlement).toISOString(),
      interval: `${Math.floor(dynamicInterval / 60000)} minutes`,
    },
  });
}

/**
 * è·å–èµ„é‡‘è´¹æ”¯ä»˜å†å²
 * GET /api/funding-history/:token
 */
async function handleGetFundingHistory(token: string, url: URL): Promise<Response> {
  const normalizedToken = token.toLowerCase() as Address;
  const limit = parseInt(url.searchParams.get("limit") || "100");
  const trader = url.searchParams.get("trader")?.toLowerCase() as Address | undefined;

  let history = fundingPaymentHistory.get(normalizedToken) || [];

  // æŒ‰ trader è¿‡æ»¤
  if (trader) {
    history = history.filter(p => p.trader.toLowerCase() === trader);
  }

  // æŒ‰æ—¶é—´å€’åº
  history = history.slice(-limit).reverse();

  return jsonResponse({
    token: normalizedToken,
    count: history.length,
    payments: history.map(p => ({
      pairId: p.pairId,
      trader: p.trader,
      isLong: p.isLong,
      positionSize: p.positionSize,
      fundingRate: p.fundingRate,
      fundingAmount: p.fundingAmount,
      isPayer: p.isPayer,
      timestamp: p.timestamp,
      display: {
        fundingRate: `${(Number(p.fundingRate) / 100).toFixed(4)}%`,
        fundingAmount: `$${(Number(p.fundingAmount) / 1e6).toFixed(2)}`,
        time: new Date(p.timestamp).toISOString(),
      },
    })),
  });
}

/**
 * æ‰‹åŠ¨è§¦å‘èµ„é‡‘è´¹ç»“ç®— (ç®¡ç†å‘˜)
 * POST /api/funding/settle
 * Body: { token: Address }
 */
async function handleManualFundingSettlement(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { token } = body;

    if (!token) {
      return errorResponse("Missing token address");
    }

    const normalizedToken = token.toLowerCase() as Address;

    // è®¡ç®—æœ€æ–°è´¹ç‡
    const rate = calculateDynamicFundingRate(normalizedToken);

    // æ‰§è¡Œç»“ç®—
    await settleFunding(normalizedToken);

    return jsonResponse({
      success: true,
      token: normalizedToken,
      settledRate: rate.toString(),
      nextSettlement: nextFundingSettlement.get(normalizedToken),
      display: {
        settledRate: `${(Number(rate) / 100).toFixed(4)}%`,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

// ============================================================
// Take Profit / Stop Loss API Handlers (P2)
// ============================================================

/**
 * è®¾ç½®/æ›´æ–° TP/SL
 * POST /api/position/:pairId/tpsl
 * Body: {
 *   takeProfitPrice?: string,  // 1e12 ç²¾åº¦ï¼Œnull è¡¨ç¤ºä¸è®¾ç½®
 *   stopLossPrice?: string,    // 1e12 ç²¾åº¦ï¼Œnull è¡¨ç¤ºä¸è®¾ç½®
 * }
 */
async function handleSetTPSL(req: Request, pairId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { takeProfitPrice, stopLossPrice } = body;

    const tp = takeProfitPrice ? BigInt(takeProfitPrice) : null;
    const sl = stopLossPrice ? BigInt(stopLossPrice) : null;

    if (tp === null && sl === null) {
      return errorResponse("At least one of takeProfitPrice or stopLossPrice is required");
    }

    const order = setTakeProfitStopLoss(pairId, tp, sl);

    if (!order) {
      return errorResponse("Failed to set TP/SL. Check price validity.");
    }

    return jsonResponse({
      success: true,
      pairId,
      takeProfitPrice: order.takeProfitPrice?.toString() || null,
      stopLossPrice: order.stopLossPrice?.toString() || null,
      display: {
        takeProfitPrice: order.takeProfitPrice ? `$${(Number(order.takeProfitPrice) / 1e12).toFixed(6)}` : "Not set",
        stopLossPrice: order.stopLossPrice ? `$${(Number(order.stopLossPrice) / 1e12).toFixed(6)}` : "Not set",
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å– TP/SL çŠ¶æ€
 * GET /api/position/:pairId/tpsl
 */
async function handleGetTPSL(pairId: string): Promise<Response> {
  const order = tpslOrders.get(pairId);

  if (!order) {
    return jsonResponse({
      pairId,
      hasTPSL: false,
      takeProfitPrice: null,
      stopLossPrice: null,
    });
  }

  return jsonResponse({
    pairId,
    hasTPSL: true,
    trader: order.trader,
    token: order.token,
    isLong: order.isLong,
    takeProfitPrice: order.takeProfitPrice?.toString() || null,
    takeProfitTriggered: order.takeProfitTriggered,
    stopLossPrice: order.stopLossPrice?.toString() || null,
    stopLossTriggered: order.stopLossTriggered,
    executionStatus: order.executionStatus,
    executedAt: order.executedAt,
    executionPrice: order.executionPrice?.toString() || null,
    executionPnL: order.executionPnL?.toString() || null,
    createdAt: order.createdAt,
    updatedAt: order.updatedAt,
    display: {
      takeProfitPrice: order.takeProfitPrice ? `$${(Number(order.takeProfitPrice) / 1e12).toFixed(6)}` : "Not set",
      stopLossPrice: order.stopLossPrice ? `$${(Number(order.stopLossPrice) / 1e12).toFixed(6)}` : "Not set",
      executionPnL: order.executionPnL ? `$${(Number(order.executionPnL) / 1e6).toFixed(2)}` : null,
    },
  });
}

/**
 * å–æ¶ˆ TP/SL
 * DELETE /api/position/:pairId/tpsl
 * Body: { cancelType: "tp" | "sl" | "both" }
 */
async function handleCancelTPSL(req: Request, pairId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { cancelType = "both" } = body;

    if (!["tp", "sl", "both"].includes(cancelType)) {
      return errorResponse('cancelType must be "tp", "sl", or "both"');
    }

    const success = cancelTakeProfitStopLoss(pairId, cancelType as "tp" | "sl" | "both");

    if (!success) {
      return errorResponse("TP/SL order not found");
    }

    return jsonResponse({
      success: true,
      pairId,
      cancelled: cancelType,
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–æ‰€æœ‰ TP/SL è®¢å•
 * GET /api/tpsl/orders
 */
async function handleGetAllTPSLOrders(): Promise<Response> {
  const orders = Array.from(tpslOrders.values()).map(order => ({
    pairId: order.pairId,
    trader: order.trader,
    token: order.token,
    isLong: order.isLong,
    takeProfitPrice: order.takeProfitPrice?.toString() || null,
    stopLossPrice: order.stopLossPrice?.toString() || null,
    executionStatus: order.executionStatus,
    createdAt: order.createdAt,
  }));

  return jsonResponse({
    count: orders.length,
    orders,
  });
}

// ============================================================
// Add/Remove Margin (è¿½åŠ /å‡å°‘ä¿è¯é‡‘) - Meme Perp P2 åŠŸèƒ½
// ============================================================

/**
 * è¿½åŠ ä¿è¯é‡‘ç»“æœ
 */
interface AddMarginResult {
  success: boolean;
  pairId: string;
  addedAmount: bigint;
  newCollateral: bigint;
  newLeverage: number;
  newLiquidationPrice: bigint;
  reason?: string;
}

/**
 * å‡å°‘ä¿è¯é‡‘ç»“æœ
 */
interface RemoveMarginResult {
  success: boolean;
  pairId: string;
  removedAmount: bigint;
  newCollateral: bigint;
  newLeverage: number;
  newLiquidationPrice: bigint;
  maxRemovable: bigint;
  reason?: string;
}

/**
 * è¿½åŠ ä¿è¯é‡‘
 *
 * æ•ˆæœ:
 * 1. å¢åŠ ä»“ä½çš„ä¿è¯é‡‘
 * 2. é™ä½æœ‰æ•ˆæ æ†
 * 3. é™ä½å¼ºå¹³ä»·æ ¼é£é™©
 *
 * @param pairId ä»“ä½ ID
 * @param amount è¿½åŠ é‡‘é¢ (1e6 USD)
 */
function addMarginToPosition(pairId: string, amount: bigint): AddMarginResult {
  // æŸ¥æ‰¾ä»“ä½
  let position: Position | null = null;
  for (const [trader, positions] of userPositions.entries()) {
    const found = positions.find(p => p.pairId === pairId);
    if (found) {
      position = found;
      break;
    }
  }

  if (!position) {
    return {
      success: false,
      pairId,
      addedAmount: 0n,
      newCollateral: 0n,
      newLeverage: 0,
      newLiquidationPrice: 0n,
      reason: "Position not found",
    };
  }

  if (amount <= 0n) {
    return {
      success: false,
      pairId,
      addedAmount: 0n,
      newCollateral: BigInt(position.collateral),
      newLeverage: Number(position.leverage),
      newLiquidationPrice: BigInt(position.liquidationPrice),
      reason: "Amount must be positive",
    };
  }

  const oldCollateral = BigInt(position.collateral);
  const newCollateral = oldCollateral + amount;

  // è®¡ç®—æ–°æ æ† = ä»“ä½ä»·å€¼ / æ–°ä¿è¯é‡‘
  const currentPrice = BigInt(position.markPrice);
  const positionValue = (BigInt(position.size) * currentPrice) / (10n ** 24n);
  const newLeverage = Number((positionValue * 10000n) / newCollateral) / 10000;

  // æ›´æ–°ä»“ä½
  position.collateral = newCollateral.toString();
  position.margin = (newCollateral + BigInt(position.unrealizedPnL)).toString();
  position.leverage = Math.floor(newLeverage).toString();

  // é‡æ–°è®¡ç®—å¼ºå¹³ä»·æ ¼
  const entryPrice = BigInt(position.entryPrice);
  const mmr = BigInt(position.mmr);
  const newLiquidationPrice = calculateLiquidationPrice(
    entryPrice,
    BigInt(Math.floor(newLeverage * 10000)),
    position.isLong,
    mmr
  );
  position.liquidationPrice = newLiquidationPrice.toString();

  // é‡æ–°è®¡ç®—ä¿è¯é‡‘ç‡
  const newMarginRatio = positionValue > 0n
    ? Number((newCollateral * 10000n) / positionValue)
    : 10000;
  position.marginRatio = newMarginRatio.toString();

  position.updatedAt = Date.now();

  console.log(`[Margin] Added $${Number(amount) / 1e6} to ${pairId}. New collateral: $${Number(newCollateral) / 1e6}, leverage: ${newLeverage.toFixed(2)}x`);

  // å¹¿æ’­ä¿è¯é‡‘æ›´æ–°
  broadcastMarginUpdate(position, "add", amount);

  return {
    success: true,
    pairId,
    addedAmount: amount,
    newCollateral,
    newLeverage,
    newLiquidationPrice,
  };
}

/**
 * å‡å°‘ä¿è¯é‡‘
 *
 * æ•ˆæœ:
 * 1. å‡å°‘ä»“ä½çš„ä¿è¯é‡‘
 * 2. æé«˜æœ‰æ•ˆæ æ†
 * 3. æé«˜å¼ºå¹³ä»·æ ¼é£é™©
 *
 * é™åˆ¶:
 * - æ–°æ æ†ä¸èƒ½è¶…è¿‡æœ€å¤§æ æ† (100x)
 * - æ–°ä¿è¯é‡‘ç‡ä¸èƒ½ä½äºç»´æŒä¿è¯é‡‘ç‡ Ã— 1.5
 *
 * @param pairId ä»“ä½ ID
 * @param amount å‡å°‘é‡‘é¢ (1e6 USD)
 */
function removeMarginFromPosition(pairId: string, amount: bigint): RemoveMarginResult {
  // æŸ¥æ‰¾ä»“ä½
  let position: Position | null = null;
  for (const [trader, positions] of userPositions.entries()) {
    const found = positions.find(p => p.pairId === pairId);
    if (found) {
      position = found;
      break;
    }
  }

  if (!position) {
    return {
      success: false,
      pairId,
      removedAmount: 0n,
      newCollateral: 0n,
      newLeverage: 0,
      newLiquidationPrice: 0n,
      maxRemovable: 0n,
      reason: "Position not found",
    };
  }

  const oldCollateral = BigInt(position.collateral);
  const currentPrice = BigInt(position.markPrice);
  const positionValue = (BigInt(position.size) * currentPrice) / (10n ** 24n);
  const mmr = BigInt(position.mmr);

  // è®¡ç®—æœ€å¤§å¯å‡å°‘é‡‘é¢
  // é™åˆ¶1: æ–°æ æ† <= 100x -> æ–°ä¿è¯é‡‘ >= ä»“ä½ä»·å€¼ / 100
  const minCollateralForLeverage = positionValue / 100n;

  // é™åˆ¶2: æ–°ä¿è¯é‡‘ç‡ >= MMR Ã— 1.5 -> æ–°ä¿è¯é‡‘ >= ä»“ä½ä»·å€¼ Ã— MMR Ã— 1.5 / 10000
  const minCollateralForHealth = (positionValue * mmr * 15n) / 100000n;

  const minCollateral = minCollateralForLeverage > minCollateralForHealth
    ? minCollateralForLeverage
    : minCollateralForHealth;

  const maxRemovable = oldCollateral > minCollateral ? oldCollateral - minCollateral : 0n;

  if (amount <= 0n) {
    return {
      success: false,
      pairId,
      removedAmount: 0n,
      newCollateral: oldCollateral,
      newLeverage: Number(position.leverage),
      newLiquidationPrice: BigInt(position.liquidationPrice),
      maxRemovable,
      reason: "Amount must be positive",
    };
  }

  if (amount > maxRemovable) {
    return {
      success: false,
      pairId,
      removedAmount: 0n,
      newCollateral: oldCollateral,
      newLeverage: Number(position.leverage),
      newLiquidationPrice: BigInt(position.liquidationPrice),
      maxRemovable,
      reason: `Amount exceeds maximum removable. Max: $${Number(maxRemovable) / 1e6}`,
    };
  }

  const newCollateral = oldCollateral - amount;
  const newLeverage = Number((positionValue * 10000n) / newCollateral) / 10000;

  // æ›´æ–°ä»“ä½
  position.collateral = newCollateral.toString();
  position.margin = (newCollateral + BigInt(position.unrealizedPnL)).toString();
  position.leverage = Math.floor(newLeverage).toString();

  // é‡æ–°è®¡ç®—å¼ºå¹³ä»·æ ¼
  const entryPrice = BigInt(position.entryPrice);
  const newLiquidationPrice = calculateLiquidationPrice(
    entryPrice,
    BigInt(Math.floor(newLeverage * 10000)),
    position.isLong,
    mmr
  );
  position.liquidationPrice = newLiquidationPrice.toString();

  // é‡æ–°è®¡ç®—ä¿è¯é‡‘ç‡
  const newMarginRatio = positionValue > 0n
    ? Number((newCollateral * 10000n) / positionValue)
    : 10000;
  position.marginRatio = newMarginRatio.toString();

  position.updatedAt = Date.now();

  console.log(`[Margin] Removed $${Number(amount) / 1e6} from ${pairId}. New collateral: $${Number(newCollateral) / 1e6}, leverage: ${newLeverage.toFixed(2)}x`);

  // å¹¿æ’­ä¿è¯é‡‘æ›´æ–°
  broadcastMarginUpdate(position, "remove", amount);

  return {
    success: true,
    pairId,
    removedAmount: amount,
    newCollateral,
    newLeverage,
    newLiquidationPrice,
    maxRemovable: maxRemovable - amount,
  };
}

/**
 * è·å–å¯è°ƒæ•´ä¿è¯é‡‘ä¿¡æ¯
 */
function getMarginAdjustmentInfo(pairId: string): {
  pairId: string;
  currentCollateral: bigint;
  currentLeverage: number;
  maxRemovable: bigint;
  minCollateral: bigint;
  positionValue: bigint;
} | null {
  let position: Position | null = null;
  for (const [trader, positions] of userPositions.entries()) {
    const found = positions.find(p => p.pairId === pairId);
    if (found) {
      position = found;
      break;
    }
  }

  if (!position) return null;

  const currentCollateral = BigInt(position.collateral);
  const currentPrice = BigInt(position.markPrice);
  const positionValue = (BigInt(position.size) * currentPrice) / (10n ** 24n);
  const mmr = BigInt(position.mmr);

  const minCollateralForLeverage = positionValue / 100n;
  const minCollateralForHealth = (positionValue * mmr * 15n) / 100000n;
  const minCollateral = minCollateralForLeverage > minCollateralForHealth
    ? minCollateralForLeverage
    : minCollateralForHealth;

  const maxRemovable = currentCollateral > minCollateral ? currentCollateral - minCollateral : 0n;

  return {
    pairId,
    currentCollateral,
    currentLeverage: Number(position.leverage),
    maxRemovable,
    minCollateral,
    positionValue,
  };
}

/**
 * å¹¿æ’­ä¿è¯é‡‘æ›´æ–°äº‹ä»¶
 */
function broadcastMarginUpdate(position: Position, action: "add" | "remove", amount: bigint): void {
  const message = JSON.stringify({
    type: "margin_updated",
    pairId: position.pairId,
    trader: position.trader,
    token: position.token,
    action,
    amount: amount.toString(),
    newCollateral: position.collateral,
    newLeverage: position.leverage,
    newLiquidationPrice: position.liquidationPrice,
    timestamp: Date.now(),
  });

  for (const [client] of wsClients.entries()) {
    if (client.readyState === WebSocket.OPEN) client.send(message);
  }
}

// ============================================================
// Reduce-Only API Handlers (P2)
// ============================================================

/**
 * è·å–ç”¨æˆ·å¯å¹³ä»“ä¿¡æ¯
 * GET /api/user/:trader/reduce-only/:token
 */
async function handleGetReduceOnlyInfo(trader: string, token: string): Promise<Response> {
  const info = getReduceOnlyInfo(trader as Address, token as Address);

  return jsonResponse({
    trader,
    token,
    canReduce: info.canReduce || false,
    maxSize: info.maxSize?.toString() || "0",
    existingPosition: info.existingPosition || null,
    reduceOrderDirection: info.existingPosition
      ? (info.existingPosition.isLong ? "SHORT" : "LONG")  // å¹³ä»“æ–¹å‘ä¸ä»“ä½ç›¸å
      : null,
    message: info.reason || (info.canReduce
      ? `You can submit a ${info.existingPosition?.isLong ? "SHORT" : "LONG"} reduce-only order up to ${info.maxSize?.toString()}`
      : "No position to reduce"),
    display: {
      maxSize: info.maxSize ? `${Number(info.maxSize) / 1e18} tokens` : "0",
    },
  });
}

// ============================================================
// Add/Remove Margin API Handlers (P2)
// ============================================================

/**
 * è·å–ä¿è¯é‡‘è°ƒæ•´ä¿¡æ¯
 * GET /api/position/:pairId/margin
 */
async function handleGetMarginInfo(pairId: string): Promise<Response> {
  const info = getMarginAdjustmentInfo(pairId);

  if (!info) {
    return errorResponse("Position not found", 404);
  }

  return jsonResponse({
    pairId,
    currentCollateral: info.currentCollateral.toString(),
    currentLeverage: info.currentLeverage,
    maxRemovable: info.maxRemovable.toString(),
    minCollateral: info.minCollateral.toString(),
    positionValue: info.positionValue.toString(),
    display: {
      currentCollateral: `$${(Number(info.currentCollateral) / 1e6).toFixed(2)}`,
      currentLeverage: `${info.currentLeverage.toFixed(2)}x`,
      maxRemovable: `$${(Number(info.maxRemovable) / 1e6).toFixed(2)}`,
      minCollateral: `$${(Number(info.minCollateral) / 1e6).toFixed(2)}`,
      positionValue: `$${(Number(info.positionValue) / 1e6).toFixed(2)}`,
    },
  });
}

/**
 * è¿½åŠ ä¿è¯é‡‘
 * POST /api/position/:pairId/margin/add
 * Body: { amount: string }  // 1e6 ç²¾åº¦
 */
async function handleAddMargin(req: Request, pairId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { amount } = body;

    if (!amount) {
      return errorResponse("Amount is required");
    }

    const amountBigInt = BigInt(amount);
    const result = addMarginToPosition(pairId, amountBigInt);

    if (!result.success) {
      return errorResponse(result.reason || "Failed to add margin");
    }

    return jsonResponse({
      success: true,
      pairId,
      addedAmount: result.addedAmount.toString(),
      newCollateral: result.newCollateral.toString(),
      newLeverage: result.newLeverage,
      newLiquidationPrice: result.newLiquidationPrice.toString(),
      display: {
        addedAmount: `$${(Number(result.addedAmount) / 1e6).toFixed(2)}`,
        newCollateral: `$${(Number(result.newCollateral) / 1e6).toFixed(2)}`,
        newLeverage: `${result.newLeverage.toFixed(2)}x`,
        newLiquidationPrice: `$${(Number(result.newLiquidationPrice) / 1e12).toFixed(6)}`,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å‡å°‘ä¿è¯é‡‘
 * POST /api/position/:pairId/margin/remove
 * Body: { amount: string }  // 1e6 ç²¾åº¦
 */
async function handleRemoveMargin(req: Request, pairId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { amount } = body;

    if (!amount) {
      return errorResponse("Amount is required");
    }

    const amountBigInt = BigInt(amount);
    const result = removeMarginFromPosition(pairId, amountBigInt);

    if (!result.success) {
      return jsonResponse({
        success: false,
        reason: result.reason,
        maxRemovable: result.maxRemovable.toString(),
        display: {
          maxRemovable: `$${(Number(result.maxRemovable) / 1e6).toFixed(2)}`,
        },
      });
    }

    return jsonResponse({
      success: true,
      pairId,
      removedAmount: result.removedAmount.toString(),
      newCollateral: result.newCollateral.toString(),
      newLeverage: result.newLeverage,
      newLiquidationPrice: result.newLiquidationPrice.toString(),
      remainingRemovable: result.maxRemovable.toString(),
      display: {
        removedAmount: `$${(Number(result.removedAmount) / 1e6).toFixed(2)}`,
        newCollateral: `$${(Number(result.newCollateral) / 1e6).toFixed(2)}`,
        newLeverage: `${result.newLeverage.toFixed(2)}x`,
        newLiquidationPrice: `$${(Number(result.newLiquidationPrice) / 1e12).toFixed(6)}`,
        remainingRemovable: `$${(Number(result.maxRemovable) / 1e6).toFixed(2)}`,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

// ============================================================
// Trailing Stop API Handlers (P2)
// ============================================================

/**
 * è®¾ç½® Trailing Stop
 * POST /api/position/:pairId/trailing-stop
 * Body: {
 *   mode: "distance" | "percentage",
 *   trailValue: string | number,  // è·ç¦»(1e12) æˆ– ç™¾åˆ†æ¯”(basis points)
 *   activationPrice?: string,     // æ¿€æ´»ä»·æ ¼ (å¯é€‰)
 * }
 */
async function handleSetTrailingStop(req: Request, pairId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { mode, trailValue, activationPrice } = body;

    if (!mode || !["distance", "percentage"].includes(mode)) {
      return errorResponse('mode must be "distance" or "percentage"');
    }

    if (trailValue === undefined || trailValue === null) {
      return errorResponse("trailValue is required");
    }

    const trailVal = mode === "distance" ? BigInt(trailValue) : Number(trailValue);
    const actPrice = activationPrice ? BigInt(activationPrice) : undefined;

    const order = setTrailingStop(pairId, mode, trailVal, actPrice);

    if (!order) {
      return errorResponse("Failed to set Trailing Stop. Check parameters.");
    }

    return jsonResponse({
      success: true,
      pairId,
      mode: order.mode,
      trailDistance: order.trailDistance?.toString() || null,
      trailPercentage: order.trailPercentage,
      activationPrice: order.activationPrice?.toString() || null,
      isActivated: order.isActivated,
      peakPrice: order.peakPrice.toString(),
      currentStopPrice: order.currentStopPrice.toString(),
      display: {
        trailValue: mode === "distance"
          ? `$${(Number(order.trailDistance!) / 1e12).toFixed(6)}`
          : `${order.trailPercentage! / 100}%`,
        currentStopPrice: `$${(Number(order.currentStopPrice) / 1e12).toFixed(6)}`,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å– Trailing Stop çŠ¶æ€
 * GET /api/position/:pairId/trailing-stop
 */
async function handleGetTrailingStop(pairId: string): Promise<Response> {
  const order = trailingStopOrders.get(pairId);

  if (!order) {
    return jsonResponse({
      pairId,
      hasTrailingStop: false,
    });
  }

  return jsonResponse({
    pairId,
    hasTrailingStop: true,
    trader: order.trader,
    token: order.token,
    isLong: order.isLong,
    mode: order.mode,
    trailDistance: order.trailDistance?.toString() || null,
    trailPercentage: order.trailPercentage,
    activationPrice: order.activationPrice?.toString() || null,
    isActivated: order.isActivated,
    peakPrice: order.peakPrice.toString(),
    currentStopPrice: order.currentStopPrice.toString(),
    triggered: order.triggered,
    executionStatus: order.executionStatus,
    executedAt: order.executedAt,
    executionPrice: order.executionPrice?.toString() || null,
    executionPnL: order.executionPnL?.toString() || null,
    createdAt: order.createdAt,
    updatedAt: order.updatedAt,
    display: {
      trailValue: order.mode === "distance"
        ? `$${(Number(order.trailDistance!) / 1e12).toFixed(6)}`
        : `${order.trailPercentage! / 100}%`,
      peakPrice: `$${(Number(order.peakPrice) / 1e12).toFixed(6)}`,
      currentStopPrice: `$${(Number(order.currentStopPrice) / 1e12).toFixed(6)}`,
      executionPnL: order.executionPnL ? `$${(Number(order.executionPnL) / 1e6).toFixed(2)}` : null,
    },
  });
}

/**
 * å–æ¶ˆ Trailing Stop
 * DELETE /api/position/:pairId/trailing-stop
 */
async function handleCancelTrailingStop(pairId: string): Promise<Response> {
  const success = cancelTrailingStop(pairId);

  if (!success) {
    return errorResponse("Trailing Stop order not found");
  }

  return jsonResponse({
    success: true,
    pairId,
  });
}

/**
 * è·å–æ‰€æœ‰ Trailing Stop è®¢å•
 * GET /api/trailing-stop/orders
 */
async function handleGetAllTrailingStopOrders(): Promise<Response> {
  const orders = Array.from(trailingStopOrders.values()).map(order => ({
    pairId: order.pairId,
    trader: order.trader,
    token: order.token,
    isLong: order.isLong,
    mode: order.mode,
    isActivated: order.isActivated,
    peakPrice: order.peakPrice.toString(),
    currentStopPrice: order.currentStopPrice.toString(),
    triggered: order.triggered,
    executionStatus: order.executionStatus,
    createdAt: order.createdAt,
  }));

  return jsonResponse({
    count: orders.length,
    orders,
  });
}

// ============================================================
// P3: Conditional Orders API Handlers
// ============================================================

/**
 * åˆ›å»ºæ¡ä»¶å•
 * POST /api/conditional-order
 * Body: {
 *   trader: Address,
 *   token: Address,
 *   triggerPrice: string,       // è§¦å‘ä»·æ ¼ (1e12)
 *   triggerDirection: "ABOVE" | "BELOW",
 *   orderType: "STOP_MARKET" | "STOP_LIMIT" | "TRIGGER_MARKET" | "TRIGGER_LIMIT",
 *   isLong: boolean,
 *   size: string,               // ä»“ä½å¤§å° (1e18)
 *   leverage: string,           // æ æ† (1e4)
 *   limitPrice?: string,        // é™ä»· (ä»…é™ä»·å•éœ€è¦)
 *   reduceOnly?: boolean,
 *   postOnly?: boolean,
 * }
 */
async function handleCreateConditionalOrder(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const {
      trader,
      token,
      triggerPrice,
      triggerDirection,
      orderType,
      isLong,
      size,
      leverage,
      limitPrice,
      reduceOnly = false,
      postOnly = false,
    } = body;

    if (!trader || !token || !triggerPrice || !triggerDirection || !orderType || isLong === undefined || !size || !leverage) {
      return errorResponse("Missing required fields");
    }

    if (!["ABOVE", "BELOW"].includes(triggerDirection)) {
      return errorResponse('triggerDirection must be "ABOVE" or "BELOW"');
    }

    if (!["STOP_MARKET", "STOP_LIMIT", "TRIGGER_MARKET", "TRIGGER_LIMIT"].includes(orderType)) {
      return errorResponse("Invalid orderType");
    }

    const result = createConditionalOrder(
      trader as Address,
      token as Address,
      BigInt(triggerPrice),
      triggerDirection as TriggerDirection,
      orderType as ConditionalOrderType,
      isLong,
      BigInt(size),
      BigInt(leverage),
      limitPrice ? BigInt(limitPrice) : undefined,
      { reduceOnly, postOnly }
    );

    if ("error" in result) {
      return errorResponse(result.error);
    }

    return jsonResponse({
      success: true,
      orderId: result.id,
      trader: result.trader,
      token: result.token,
      triggerPrice: result.triggerPrice.toString(),
      triggerDirection: result.triggerDirection,
      orderType: result.orderType,
      isLong: result.isLong,
      size: result.size.toString(),
      leverage: result.leverage.toString(),
      limitPrice: result.limitPrice?.toString() || null,
      status: result.status,
      display: {
        triggerPrice: `$${(Number(result.triggerPrice) / 1e12).toFixed(6)}`,
        size: `${(Number(result.size) / 1e18).toFixed(4)} tokens`,
        leverage: `${Number(result.leverage) / 10000}x`,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å–æ¶ˆæ¡ä»¶å•
 * DELETE /api/conditional-order/:orderId
 */
async function handleCancelConditionalOrder(req: Request, orderId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { trader } = body;

    if (!trader) {
      return errorResponse("Missing trader address");
    }

    const success = cancelConditionalOrder(orderId, trader as Address);

    if (!success) {
      return errorResponse("Failed to cancel order. Order not found or not owned by trader.");
    }

    return jsonResponse({
      success: true,
      orderId,
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–ç”¨æˆ·çš„æ¡ä»¶å•
 * GET /api/conditional-orders?trader=0x...
 */
async function handleGetUserConditionalOrders(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const trader = url.searchParams.get("trader");

  if (!trader) {
    return errorResponse("Missing trader parameter");
  }

  const orders = getUserConditionalOrders(trader as Address);

  return jsonResponse({
    count: orders.length,
    orders: orders.map(o => ({
      orderId: o.id,
      token: o.token,
      triggerPrice: o.triggerPrice.toString(),
      triggerDirection: o.triggerDirection,
      orderType: o.orderType,
      isLong: o.isLong,
      size: o.size.toString(),
      leverage: o.leverage.toString(),
      limitPrice: o.limitPrice?.toString() || null,
      status: o.status,
      triggered: o.triggered,
      triggeredAt: o.triggeredAt,
      executedAt: o.executedAt,
      executionPrice: o.executionPrice?.toString() || null,
      createdAt: o.createdAt,
      display: {
        triggerPrice: `$${(Number(o.triggerPrice) / 1e12).toFixed(6)}`,
        size: `${(Number(o.size) / 1e18).toFixed(4)} tokens`,
        executionPrice: o.executionPrice ? `$${(Number(o.executionPrice) / 1e12).toFixed(6)}` : null,
      },
    })),
  });
}

/**
 * è·å–æ‰€æœ‰æ¡ä»¶å•
 * GET /api/conditional-orders/all
 */
async function handleGetAllConditionalOrders(): Promise<Response> {
  const orders = Array.from(conditionalOrders.values());

  return jsonResponse({
    count: orders.length,
    pending: orders.filter(o => o.status === "pending").length,
    triggered: orders.filter(o => o.status === "triggered").length,
    executed: orders.filter(o => o.status === "executed").length,
    orders: orders.map(o => ({
      orderId: o.id,
      trader: o.trader,
      token: o.token,
      triggerPrice: o.triggerPrice.toString(),
      triggerDirection: o.triggerDirection,
      orderType: o.orderType,
      isLong: o.isLong,
      status: o.status,
      createdAt: o.createdAt,
    })),
  });
}

// ============================================================
// P3: OCO Orders API Handlers
// ============================================================

/**
 * åˆ›å»º OCO è®¢å•
 * POST /api/oco-order
 */
async function handleCreateOCOOrder(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { trader, token, order1, order2 } = body;

    if (!trader || !token || !order1 || !order2) {
      return errorResponse("Missing required fields (trader, token, order1, order2)");
    }

    const result = createOCOOrder(
      trader as Address,
      token as Address,
      {
        triggerPrice: BigInt(order1.triggerPrice),
        triggerDirection: order1.triggerDirection as TriggerDirection,
        orderType: order1.orderType as ConditionalOrderType,
        isLong: order1.isLong,
        size: BigInt(order1.size),
        leverage: BigInt(order1.leverage),
        limitPrice: order1.limitPrice ? BigInt(order1.limitPrice) : undefined,
      },
      {
        triggerPrice: BigInt(order2.triggerPrice),
        triggerDirection: order2.triggerDirection as TriggerDirection,
        orderType: order2.orderType as ConditionalOrderType,
        isLong: order2.isLong,
        size: BigInt(order2.size),
        leverage: BigInt(order2.leverage),
        limitPrice: order2.limitPrice ? BigInt(order2.limitPrice) : undefined,
      }
    );

    if ("error" in result) {
      return errorResponse(result.error);
    }

    return jsonResponse({
      success: true,
      ocoId: result.id,
      order1: {
        orderId: result.order1.orderId,
        triggerPrice: result.order1.triggerPrice.toString(),
        triggerDirection: result.order1.triggerDirection,
      },
      order2: {
        orderId: result.order2.orderId,
        triggerPrice: result.order2.triggerPrice.toString(),
        triggerDirection: result.order2.triggerDirection,
      },
      status: result.status,
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å–æ¶ˆ OCO è®¢å•
 * DELETE /api/oco-order/:ocoId
 */
async function handleCancelOCOOrder(req: Request, ocoId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { trader } = body;

    if (!trader) {
      return errorResponse("Missing trader address");
    }

    const success = cancelOCOOrder(ocoId, trader as Address);

    if (!success) {
      return errorResponse("Failed to cancel OCO order");
    }

    return jsonResponse({ success: true, ocoId });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–ç”¨æˆ· OCO è®¢å•
 * GET /api/oco-orders?trader=0x...
 */
async function handleGetUserOCOOrders(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const trader = url.searchParams.get("trader");

  if (!trader) {
    return errorResponse("Missing trader parameter");
  }

  const orders = getUserOCOOrders(trader as Address);

  return jsonResponse({
    count: orders.length,
    orders: orders.map(o => ({
      ocoId: o.id,
      token: o.token,
      order1: {
        orderId: o.order1.orderId,
        triggerPrice: o.order1.triggerPrice.toString(),
        triggerDirection: o.order1.triggerDirection,
        orderType: o.order1.orderType,
        isLong: o.order1.isLong,
      },
      order2: {
        orderId: o.order2.orderId,
        triggerPrice: o.order2.triggerPrice.toString(),
        triggerDirection: o.order2.triggerDirection,
        orderType: o.order2.orderType,
        isLong: o.order2.isLong,
      },
      status: o.status,
      executedOrderId: o.executedOrderId,
      cancelledOrderId: o.cancelledOrderId,
      createdAt: o.createdAt,
    })),
  });
}

// ============================================================
// P3: Bracket Orders API Handlers
// ============================================================

/**
 * åˆ›å»º Bracket è®¢å•
 * POST /api/bracket-order
 */
async function handleCreateBracketOrder(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const {
      trader,
      token,
      isLong,
      size,
      leverage,
      price = "0",
      takeProfitPrice,
      stopLossPrice,
      tpOrderType = "TRIGGER_MARKET",
      slOrderType = "STOP_MARKET",
    } = body;

    if (!trader || !token || isLong === undefined || !size || !leverage) {
      return errorResponse("Missing required fields");
    }

    if (!takeProfitPrice && !stopLossPrice) {
      return errorResponse("At least one of Take Profit or Stop Loss is required");
    }

    const result = createBracketOrder(
      trader as Address,
      token as Address,
      {
        isLong,
        size: BigInt(size),
        leverage: BigInt(leverage),
        price: BigInt(price),
      },
      takeProfitPrice ? BigInt(takeProfitPrice) : null,
      stopLossPrice ? BigInt(stopLossPrice) : null,
      {
        tpOrderType: tpOrderType as ConditionalOrderType,
        slOrderType: slOrderType as ConditionalOrderType,
      }
    );

    if ("error" in result) {
      return errorResponse(result.error);
    }

    return jsonResponse({
      success: true,
      bracketId: result.id,
      trader: result.trader,
      token: result.token,
      entryOrder: {
        isLong: result.entryOrder.isLong,
        size: result.entryOrder.size.toString(),
        leverage: result.entryOrder.leverage.toString(),
        price: result.entryOrder.price.toString(),
      },
      takeProfitPrice: result.takeProfitOrder?.triggerPrice.toString() || null,
      stopLossPrice: result.stopLossOrder?.triggerPrice.toString() || null,
      status: result.status,
      display: {
        size: `${(Number(result.entryOrder.size) / 1e18).toFixed(4)} tokens`,
        leverage: `${Number(result.entryOrder.leverage) / 10000}x`,
        entryPrice: result.entryOrder.price === 0n
          ? "Market"
          : `$${(Number(result.entryOrder.price) / 1e12).toFixed(6)}`,
        takeProfitPrice: result.takeProfitOrder
          ? `$${(Number(result.takeProfitOrder.triggerPrice) / 1e12).toFixed(6)}`
          : null,
        stopLossPrice: result.stopLossOrder
          ? `$${(Number(result.stopLossOrder.triggerPrice) / 1e12).toFixed(6)}`
          : null,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–ç”¨æˆ· Bracket è®¢å•
 * GET /api/bracket-orders?trader=0x...
 */
async function handleGetUserBracketOrders(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const trader = url.searchParams.get("trader");

  if (!trader) {
    return errorResponse("Missing trader parameter");
  }

  const orders = getUserBracketOrders(trader as Address);

  return jsonResponse({
    count: orders.length,
    orders: orders.map(o => ({
      bracketId: o.id,
      token: o.token,
      entryOrder: {
        isLong: o.entryOrder.isLong,
        size: o.entryOrder.size.toString(),
        leverage: o.entryOrder.leverage.toString(),
        price: o.entryOrder.price.toString(),
      },
      takeProfitOrder: o.takeProfitOrder ? {
        orderId: o.takeProfitOrder.orderId,
        triggerPrice: o.takeProfitOrder.triggerPrice.toString(),
        orderType: o.takeProfitOrder.orderType,
      } : null,
      stopLossOrder: o.stopLossOrder ? {
        orderId: o.stopLossOrder.orderId,
        triggerPrice: o.stopLossOrder.triggerPrice.toString(),
        orderType: o.stopLossOrder.orderType,
      } : null,
      status: o.status,
      entryFilled: o.entryFilled,
      entryPrice: o.entryPrice?.toString() || null,
      pairId: o.pairId,
      createdAt: o.createdAt,
    })),
  });
}

/**
 * è·å–æ‰€æœ‰ Bracket è®¢å•
 * GET /api/bracket-orders/all
 */
async function handleGetAllBracketOrders(): Promise<Response> {
  const orders = Array.from(bracketOrders.values());

  return jsonResponse({
    count: orders.length,
    pending_entry: orders.filter(o => o.status === "pending_entry").length,
    active: orders.filter(o => o.status === "active").length,
    completed: orders.filter(o => ["tp_executed", "sl_executed"].includes(o.status)).length,
    orders: orders.map(o => ({
      bracketId: o.id,
      trader: o.trader,
      token: o.token,
      isLong: o.entryOrder.isLong,
      status: o.status,
      entryFilled: o.entryFilled,
      createdAt: o.createdAt,
    })),
  });
}

// ============================================================
// P4: Sub-accounts API Handlers
// ============================================================

/**
 * åˆ›å»ºå­è´¦æˆ·
 * POST /api/sub-account
 */
async function handleCreateSubAccount(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const {
      masterAccount,
      name,
      type = "isolated",
      positionMode = "one_way",
      maxLeverage,
      maxPositionValue,
      maxDrawdown,
    } = body;

    if (!masterAccount || !name) {
      return errorResponse("Missing required fields (masterAccount, name)");
    }

    const subAccount = createSubAccount(
      masterAccount as Address,
      name,
      {
        type: type as "isolated" | "cross",
        positionMode: positionMode as "one_way" | "hedge",
        maxLeverage: maxLeverage ? Number(maxLeverage) : undefined,
        maxPositionValue: maxPositionValue ? BigInt(maxPositionValue) : undefined,
        maxDrawdown: maxDrawdown ? Number(maxDrawdown) : undefined,
      }
    );

    return jsonResponse({
      success: true,
      subAccount: {
        id: subAccount.id,
        masterAccount: subAccount.masterAccount,
        name: subAccount.name,
        type: subAccount.type,
        positionMode: subAccount.positionMode,
        maxLeverage: subAccount.maxLeverage,
        maxPositionValue: subAccount.maxPositionValue.toString(),
        maxDrawdown: subAccount.maxDrawdown,
        status: subAccount.status,
        createdAt: subAccount.createdAt,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–å­è´¦æˆ·åˆ—è¡¨
 * GET /api/sub-accounts?masterAccount=0x...
 */
async function handleGetSubAccounts(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const masterAccount = url.searchParams.get("masterAccount");

  if (!masterAccount) {
    return errorResponse("Missing masterAccount parameter");
  }

  const accounts = getMasterSubAccounts(masterAccount as Address);

  return jsonResponse({
    count: accounts.length,
    subAccounts: accounts.map(acc => ({
      id: acc.id,
      name: acc.name,
      type: acc.type,
      positionMode: acc.positionMode,
      balance: acc.balance.toString(),
      lockedBalance: acc.lockedBalance.toString(),
      totalEquity: acc.totalEquity.toString(),
      status: acc.status,
      totalPnL: acc.totalPnL.toString(),
      createdAt: acc.createdAt,
      display: {
        balance: `$${(Number(acc.balance) / 1e6).toFixed(2)}`,
        totalEquity: `$${(Number(acc.totalEquity) / 1e6).toFixed(2)}`,
        totalPnL: `$${(Number(acc.totalPnL) / 1e6).toFixed(2)}`,
      },
    })),
  });
}

/**
 * è·å–å­è´¦æˆ·è¯¦æƒ…
 * GET /api/sub-account/:subAccountId
 */
async function handleGetSubAccount(subAccountId: string): Promise<Response> {
  const subAccount = getSubAccount(subAccountId);

  if (!subAccount) {
    return errorResponse("Sub-account not found", 404);
  }

  const stats = getSubAccountStats(subAccountId);
  const positions = subAccountPositions.get(subAccountId) || [];

  return jsonResponse({
    subAccount: {
      id: subAccount.id,
      masterAccount: subAccount.masterAccount,
      name: subAccount.name,
      type: subAccount.type,
      positionMode: subAccount.positionMode,
      maxLeverage: subAccount.maxLeverage,
      maxPositionValue: subAccount.maxPositionValue.toString(),
      maxDrawdown: subAccount.maxDrawdown,
      status: subAccount.status,
      createdAt: subAccount.createdAt,
      updatedAt: subAccount.updatedAt,
    },
    stats: stats ? {
      balance: stats.balance.toString(),
      lockedBalance: stats.lockedBalance.toString(),
      availableBalance: stats.availableBalance.toString(),
      totalEquity: stats.totalEquity.toString(),
      unrealizedPnL: stats.unrealizedPnL.toString(),
      totalPnL: stats.totalPnL.toString(),
      positionCount: stats.positionCount,
      marginUsage: stats.marginUsage,
      winRate: stats.winRate,
      display: {
        balance: `$${(Number(stats.balance) / 1e6).toFixed(2)}`,
        availableBalance: `$${(Number(stats.availableBalance) / 1e6).toFixed(2)}`,
        totalEquity: `$${(Number(stats.totalEquity) / 1e6).toFixed(2)}`,
        unrealizedPnL: `$${(Number(stats.unrealizedPnL) / 1e6).toFixed(2)}`,
        totalPnL: `$${(Number(stats.totalPnL) / 1e6).toFixed(2)}`,
        marginUsage: `${(stats.marginUsage / 100).toFixed(2)}%`,
        winRate: `${(stats.winRate / 100).toFixed(2)}%`,
      },
    } : null,
    positionCount: positions.length,
  });
}

/**
 * å­è´¦æˆ·è½¬è´¦
 * POST /api/sub-account/:subAccountId/transfer
 */
async function handleSubAccountTransfer(req: Request, subAccountId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { masterAccount, amount, direction } = body;

    if (!masterAccount || !amount || !direction) {
      return errorResponse("Missing required fields (masterAccount, amount, direction)");
    }

    if (!["deposit", "withdraw"].includes(direction)) {
      return errorResponse('direction must be "deposit" or "withdraw"');
    }

    const result = transferToSubAccount(
      masterAccount as Address,
      subAccountId,
      BigInt(amount),
      direction as "deposit" | "withdraw"
    );

    if ("error" in result) {
      return errorResponse(result.error);
    }

    const subAccount = getSubAccount(subAccountId)!;

    return jsonResponse({
      success: true,
      transfer: {
        id: result.id,
        fromAccount: result.fromAccount,
        toAccount: result.toAccount,
        amount: result.amount.toString(),
        status: result.status,
        timestamp: result.timestamp,
      },
      newBalance: subAccount.balance.toString(),
      display: {
        amount: `$${(Number(result.amount) / 1e6).toFixed(2)}`,
        newBalance: `$${(Number(subAccount.balance) / 1e6).toFixed(2)}`,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * æ›´æ–°å­è´¦æˆ·è®¾ç½®
 * PUT /api/sub-account/:subAccountId
 */
async function handleUpdateSubAccount(req: Request, subAccountId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { masterAccount, name, type, positionMode, maxLeverage, maxPositionValue, maxDrawdown } = body;

    if (!masterAccount) {
      return errorResponse("Missing masterAccount");
    }

    const result = updateSubAccountSettings(
      subAccountId,
      masterAccount as Address,
      {
        name,
        type: type as "isolated" | "cross" | undefined,
        positionMode: positionMode as "one_way" | "hedge" | undefined,
        maxLeverage: maxLeverage ? Number(maxLeverage) : undefined,
        maxPositionValue: maxPositionValue ? BigInt(maxPositionValue) : undefined,
        maxDrawdown: maxDrawdown ? Number(maxDrawdown) : undefined,
      }
    );

    if ("error" in result) {
      return errorResponse(result.error);
    }

    return jsonResponse({
      success: true,
      subAccount: {
        id: result.id,
        name: result.name,
        type: result.type,
        positionMode: result.positionMode,
        maxLeverage: result.maxLeverage,
        maxPositionValue: result.maxPositionValue.toString(),
        maxDrawdown: result.maxDrawdown,
        updatedAt: result.updatedAt,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å†»ç»“/è§£å†»å­è´¦æˆ·
 * POST /api/sub-account/:subAccountId/freeze
 */
async function handleFreezeSubAccount(req: Request, subAccountId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { masterAccount, action } = body;

    if (!masterAccount || !action) {
      return errorResponse("Missing masterAccount or action");
    }

    if (!["freeze", "unfreeze"].includes(action)) {
      return errorResponse('action must be "freeze" or "unfreeze"');
    }

    const success = action === "freeze"
      ? freezeSubAccount(subAccountId, masterAccount as Address)
      : unfreezeSubAccount(subAccountId, masterAccount as Address);

    if (!success) {
      return errorResponse(`Failed to ${action} sub-account`);
    }

    const subAccount = getSubAccount(subAccountId);

    return jsonResponse({
      success: true,
      subAccountId,
      status: subAccount?.status,
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å…³é—­å­è´¦æˆ·
 * DELETE /api/sub-account/:subAccountId
 */
async function handleCloseSubAccount(req: Request, subAccountId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { masterAccount } = body;

    if (!masterAccount) {
      return errorResponse("Missing masterAccount");
    }

    const result = closeSubAccount(subAccountId, masterAccount as Address);

    if (typeof result === "object" && "error" in result) {
      return errorResponse(result.error);
    }

    return jsonResponse({
      success: true,
      subAccountId,
      message: "Sub-account closed successfully",
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

// ============================================================
// P4: Cross-Margin Mode API Handlers
// ============================================================

/**
 * è·å–ç”¨æˆ·ä¿è¯é‡‘æ¨¡å¼
 * GET /api/margin-mode?trader=0x...
 */
async function handleGetMarginMode(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const trader = url.searchParams.get("trader");

  if (!trader) {
    return errorResponse("Missing trader parameter");
  }

  const mode = getUserMarginMode(trader as Address);
  const account = mode === "cross" ? getCrossMarginAccount(trader as Address) : null;

  return jsonResponse({
    trader,
    marginMode: mode,
    crossMarginAccount: account ? {
      walletBalance: account.walletBalance.toString(),
      unrealizedPnL: account.unrealizedPnL.toString(),
      availableBalance: account.availableBalance.toString(),
      marginBalance: account.marginBalance.toString(),
      initialMargin: account.initialMargin.toString(),
      maintenanceMargin: account.maintenanceMargin.toString(),
      marginRatio: account.marginRatio,
      display: {
        walletBalance: `$${(Number(account.walletBalance) / 1e6).toFixed(2)}`,
        unrealizedPnL: `$${(Number(account.unrealizedPnL) / 1e6).toFixed(2)}`,
        availableBalance: `$${(Number(account.availableBalance) / 1e6).toFixed(2)}`,
        marginBalance: `$${(Number(account.marginBalance) / 1e6).toFixed(2)}`,
        marginRatio: `${(account.marginRatio / 100).toFixed(2)}%`,
      },
    } : null,
  });
}

/**
 * è®¾ç½®ä¿è¯é‡‘æ¨¡å¼
 * POST /api/margin-mode
 */
async function handleSetMarginMode(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { trader, mode } = body;

    if (!trader || !mode) {
      return errorResponse("Missing trader or mode");
    }

    if (!["isolated", "cross"].includes(mode)) {
      return errorResponse('mode must be "isolated" or "cross"');
    }

    const result = setUserMarginMode(trader as Address, mode as "isolated" | "cross");

    if (!result.success) {
      return errorResponse(result.error || "Failed to set margin mode");
    }

    return jsonResponse({
      success: true,
      trader,
      marginMode: mode,
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å…¨ä»“è´¦æˆ·å……å€¼
 * POST /api/cross-margin/deposit
 */
async function handleCrossMarginDeposit(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { trader, amount } = body;

    if (!trader || !amount) {
      return errorResponse("Missing trader or amount");
    }

    if (getUserMarginMode(trader as Address) !== "cross") {
      return errorResponse("User is not in cross margin mode");
    }

    const success = updateCrossMarginBalance(trader as Address, BigInt(amount), "deposit");

    if (!success) {
      return errorResponse("Failed to deposit");
    }

    const account = getCrossMarginAccount(trader as Address);

    return jsonResponse({
      success: true,
      trader,
      depositedAmount: amount,
      newBalance: account?.walletBalance.toString(),
      display: {
        depositedAmount: `$${(Number(amount) / 1e6).toFixed(2)}`,
        newBalance: account ? `$${(Number(account.walletBalance) / 1e6).toFixed(2)}` : null,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * å…¨ä»“è´¦æˆ·æç°
 * POST /api/cross-margin/withdraw
 */
async function handleCrossMarginWithdraw(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { trader, amount } = body;

    if (!trader || !amount) {
      return errorResponse("Missing trader or amount");
    }

    if (getUserMarginMode(trader as Address) !== "cross") {
      return errorResponse("User is not in cross margin mode");
    }

    const success = updateCrossMarginBalance(trader as Address, BigInt(amount), "withdraw");

    if (!success) {
      return errorResponse("Insufficient available balance");
    }

    const account = getCrossMarginAccount(trader as Address);

    return jsonResponse({
      success: true,
      trader,
      withdrawnAmount: amount,
      newBalance: account?.walletBalance.toString(),
      display: {
        withdrawnAmount: `$${(Number(amount) / 1e6).toFixed(2)}`,
        newBalance: account ? `$${(Number(account.walletBalance) / 1e6).toFixed(2)}` : null,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

// ============================================================
// P4: Position Mode API Handlers
// ============================================================

/**
 * è·å–ç”¨æˆ·æŒä»“æ¨¡å¼
 * GET /api/position-mode?trader=0x...
 */
async function handleGetPositionMode(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const trader = url.searchParams.get("trader");

  if (!trader) {
    return errorResponse("Missing trader parameter");
  }

  const mode = getUserPositionMode(trader as Address);

  return jsonResponse({
    trader,
    positionMode: mode,
    description: mode === "hedge"
      ? "Hedge mode: Can hold both long and short positions on the same token"
      : "One-way mode: Only one direction allowed per token",
  });
}

/**
 * è®¾ç½®æŒä»“æ¨¡å¼
 * POST /api/position-mode
 */
async function handleSetPositionMode(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { trader, mode } = body;

    if (!trader || !mode) {
      return errorResponse("Missing trader or mode");
    }

    if (!["one_way", "hedge"].includes(mode)) {
      return errorResponse('mode must be "one_way" or "hedge"');
    }

    const result = setUserPositionMode(trader as Address, mode as "one_way" | "hedge");

    if (!result.success) {
      return errorResponse(result.error || "Failed to set position mode");
    }

    return jsonResponse({
      success: true,
      trader,
      positionMode: mode,
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–å‡€ä»“ä½ (å¯¹å†²æ¨¡å¼ä¸‹ä½¿ç”¨)
 * GET /api/net-position?trader=0x...&token=0x...
 */
async function handleGetNetPosition(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const trader = url.searchParams.get("trader");
  const token = url.searchParams.get("token");

  if (!trader || !token) {
    return errorResponse("Missing trader or token parameter");
  }

  const netPos = getNetPosition(trader as Address, token as Address);
  const positions = getUserTokenPositions(trader as Address, token as Address);

  return jsonResponse({
    trader,
    token,
    positionMode: getUserPositionMode(trader as Address),
    netPosition: {
      netSize: netPos.netSize.toString(),
      netDirection: netPos.netDirection,
      longSize: netPos.longSize.toString(),
      shortSize: netPos.shortSize.toString(),
      display: {
        netSize: `${(Number(netPos.netSize) / 1e18).toFixed(4)} tokens`,
        longSize: `${(Number(netPos.longSize) / 1e18).toFixed(4)} tokens`,
        shortSize: `${(Number(netPos.shortSize) / 1e18).toFixed(4)} tokens`,
      },
    },
    positionCount: positions.length,
    positions: positions.map(p => ({
      pairId: p.pairId,
      isLong: p.isLong,
      size: p.size,
      entryPrice: p.entryPrice,
      unrealizedPnL: p.unrealizedPnL,
    })),
  });
}

// ============================================================
// P4: TWAP Orders API Handlers
// ============================================================

/**
 * åˆ›å»º TWAP è®¢å•
 * POST /api/twap-order
 */
async function handleCreateTWAPOrder(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const {
      trader,
      token,
      isLong,
      totalSize,
      leverage,
      duration,        // ç§’
      intervals,
      priceLimit,
      randomize = true,
      reduceOnly = false,
      postOnly = false,
      startImmediately = true,
    } = body;

    if (!trader || !token || isLong === undefined || !totalSize || !leverage || !duration || !intervals) {
      return errorResponse("Missing required fields");
    }

    const result = createTWAPOrder(
      trader as Address,
      token as Address,
      isLong,
      BigInt(totalSize),
      BigInt(leverage),
      Number(duration),
      Number(intervals),
      {
        priceLimit: priceLimit ? BigInt(priceLimit) : undefined,
        randomize,
        reduceOnly,
        postOnly,
        startImmediately,
      }
    );

    if ("error" in result) {
      return errorResponse(result.error);
    }

    return jsonResponse({
      success: true,
      orderId: result.id,
      trader: result.trader,
      token: result.token,
      isLong: result.isLong,
      totalSize: result.totalSize.toString(),
      leverage: result.leverage.toString(),
      duration: result.duration,
      intervals: result.intervals,
      sizePerInterval: result.sizePerInterval.toString(),
      status: result.status,
      display: {
        totalSize: `${(Number(result.totalSize) / 1e18).toFixed(4)} tokens`,
        sizePerInterval: `${(Number(result.sizePerInterval) / 1e18).toFixed(4)} tokens`,
        duration: `${result.duration / 1000}s`,
        intervalSeconds: `${result.intervalMs / 1000}s`,
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å– TWAP è®¢å•è¯¦æƒ…
 * GET /api/twap-order/:orderId
 */
async function handleGetTWAPOrder(orderId: string): Promise<Response> {
  const order = getTWAPOrder(orderId);

  if (!order) {
    return errorResponse("TWAP order not found", 404);
  }

  return jsonResponse({
    orderId: order.id,
    trader: order.trader,
    token: order.token,
    isLong: order.isLong,
    totalSize: order.totalSize.toString(),
    leverage: order.leverage.toString(),
    duration: order.duration,
    intervals: order.intervals,
    sizePerInterval: order.sizePerInterval.toString(),
    priceLimit: order.priceLimit?.toString() || null,
    status: order.status,
    startTime: order.startTime,
    endTime: order.endTime,
    nextExecutionTime: order.nextExecutionTime,
    progress: {
      executedSize: order.executedSize.toString(),
      executedCount: order.executedCount,
      totalIntervals: order.intervals,
      percentComplete: Math.floor((order.executedCount * 100) / order.intervals),
    },
    avgExecutionPrice: order.avgExecutionPrice.toString(),
    totalValue: order.totalValue.toString(),
    recentExecutions: order.executions.slice(-10).map(e => ({
      timestamp: e.timestamp,
      size: e.size.toString(),
      price: e.price.toString(),
      success: e.success,
      error: e.error,
    })),
    display: {
      totalSize: `${(Number(order.totalSize) / 1e18).toFixed(4)} tokens`,
      executedSize: `${(Number(order.executedSize) / 1e18).toFixed(4)} tokens`,
      avgExecutionPrice: order.avgExecutionPrice > 0n
        ? `$${(Number(order.avgExecutionPrice) / 1e12).toFixed(6)}`
        : null,
      progress: `${order.executedCount}/${order.intervals} (${Math.floor((order.executedCount * 100) / order.intervals)}%)`,
    },
    createdAt: order.createdAt,
    updatedAt: order.updatedAt,
  });
}

/**
 * æš‚åœ/æ¢å¤ TWAP è®¢å•
 * POST /api/twap-order/:orderId/control
 */
async function handleTWAPOrderControl(req: Request, orderId: string): Promise<Response> {
  try {
    const body = await req.json();
    const { action, trader } = body;

    if (!action || !trader) {
      return errorResponse("Missing action or trader");
    }

    const order = getTWAPOrder(orderId);
    if (!order) {
      return errorResponse("TWAP order not found", 404);
    }

    if (order.trader.toLowerCase() !== (trader as Address).toLowerCase()) {
      return errorResponse("Not authorized");
    }

    let success = false;

    switch (action) {
      case "start":
        success = startTWAPOrder(orderId);
        break;
      case "pause":
        success = pauseTWAPOrder(orderId);
        break;
      case "cancel":
        success = cancelTWAPOrder(orderId, trader as Address);
        break;
      default:
        return errorResponse('action must be "start", "pause", or "cancel"');
    }

    if (!success) {
      return errorResponse(`Failed to ${action} TWAP order`);
    }

    const updatedOrder = getTWAPOrder(orderId);

    return jsonResponse({
      success: true,
      orderId,
      action,
      newStatus: updatedOrder?.status,
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–ç”¨æˆ· TWAP è®¢å•åˆ—è¡¨
 * GET /api/twap-orders?trader=0x...
 */
async function handleGetUserTWAPOrders(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const trader = url.searchParams.get("trader");

  if (!trader) {
    return errorResponse("Missing trader parameter");
  }

  const orders = getUserTWAPOrders(trader as Address);

  return jsonResponse({
    count: orders.length,
    running: orders.filter(o => o.status === "running").length,
    completed: orders.filter(o => o.status === "completed").length,
    orders: orders.map(o => ({
      orderId: o.id,
      token: o.token,
      isLong: o.isLong,
      totalSize: o.totalSize.toString(),
      executedSize: o.executedSize.toString(),
      status: o.status,
      progress: `${o.executedCount}/${o.intervals}`,
      avgExecutionPrice: o.avgExecutionPrice.toString(),
      createdAt: o.createdAt,
      display: {
        totalSize: `${(Number(o.totalSize) / 1e18).toFixed(4)} tokens`,
        executedSize: `${(Number(o.executedSize) / 1e18).toFixed(4)} tokens`,
        avgPrice: o.avgExecutionPrice > 0n ? `$${(Number(o.avgExecutionPrice) / 1e12).toFixed(6)}` : "-",
      },
    })),
  });
}

/**
 * è·å–æ‰€æœ‰æ´»è·ƒ TWAP è®¢å•
 * GET /api/twap-orders/active
 */
async function handleGetActiveTWAPOrders(): Promise<Response> {
  const allOrders = Array.from(twapOrders.values());
  const activeOrders = allOrders.filter(o => o.status === "running" || o.status === "paused");

  return jsonResponse({
    count: activeOrders.length,
    running: activeOrders.filter(o => o.status === "running").length,
    paused: activeOrders.filter(o => o.status === "paused").length,
    orders: activeOrders.map(o => ({
      orderId: o.id,
      trader: o.trader,
      token: o.token,
      isLong: o.isLong,
      status: o.status,
      progress: `${o.executedCount}/${o.intervals}`,
      nextExecutionTime: o.nextExecutionTime,
    })),
  });
}

// ============================================================
// P5: Referral System API Handlers
// ============================================================

/**
 * æ³¨å†Œæˆä¸ºæ¨èäºº (è·å–é‚€è¯·ç )
 * POST /api/referral/register
 */
async function handleRegisterReferrer(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { address } = body;

    if (!address) {
      return errorResponse("Missing address");
    }

    const result = registerAsReferrer(address as Address);

    if ("error" in result) {
      return errorResponse(result.error);
    }

    return jsonResponse({
      success: true,
      referrer: {
        address: result.address,
        code: result.code,
        referralCount: result.level1Referrals.length,
        totalEarnings: result.totalEarnings.toString(),
        createdAt: result.createdAt,
      },
      message: `Your referral code is: ${result.code}`,
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * ç»‘å®šé‚€è¯·ç 
 * POST /api/referral/bind
 */
async function handleBindReferral(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { address, referralCode } = body;

    if (!address || !referralCode) {
      return errorResponse("Missing address or referralCode");
    }

    const result = bindReferral(address as Address, referralCode);

    if (!result.success) {
      return errorResponse(result.error || "Failed to bind referral");
    }

    const referee = getRefereeInfo(address as Address);

    return jsonResponse({
      success: true,
      referee: referee ? {
        address: referee.address,
        referrer: referee.referrer,
        referralCode: referee.referrerCode,
        joinedAt: referee.joinedAt,
      } : null,
      message: "Successfully bound to referrer",
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–æ¨èäººä¿¡æ¯
 * GET /api/referral/referrer?address=0x...
 */
async function handleGetReferrer(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const address = url.searchParams.get("address");

  if (!address) {
    return errorResponse("Missing address parameter");
  }

  const referrer = getReferrerInfo(address as Address);

  if (!referrer) {
    return jsonResponse({
      isReferrer: false,
      message: "Not a registered referrer. Call POST /api/referral/register to get a referral code.",
    });
  }

  return jsonResponse({
    isReferrer: true,
    referrer: {
      address: referrer.address,
      code: referrer.code,
      level1Referrals: referrer.level1Referrals.length,
      level2Referrals: referrer.level2Referrals.length,
      totalEarnings: referrer.totalEarnings.toString(),
      pendingEarnings: referrer.pendingEarnings.toString(),
      withdrawnEarnings: referrer.withdrawnEarnings.toString(),
      level1Earnings: referrer.level1Earnings.toString(),
      level2Earnings: referrer.level2Earnings.toString(),
      totalTradesReferred: referrer.totalTradesReferred,
      totalVolumeReferred: referrer.totalVolumeReferred.toString(),
      createdAt: referrer.createdAt,
      display: {
        totalEarnings: `$${(Number(referrer.totalEarnings) / 1e6).toFixed(2)}`,
        pendingEarnings: `$${(Number(referrer.pendingEarnings) / 1e6).toFixed(2)}`,
        withdrawnEarnings: `$${(Number(referrer.withdrawnEarnings) / 1e6).toFixed(2)}`,
        level1Earnings: `$${(Number(referrer.level1Earnings) / 1e6).toFixed(2)}`,
        level2Earnings: `$${(Number(referrer.level2Earnings) / 1e6).toFixed(2)}`,
        totalVolumeReferred: `$${(Number(referrer.totalVolumeReferred) / 1e6).toFixed(2)}`,
      },
    },
  });
}

/**
 * è·å–è¢«é‚€è¯·äººä¿¡æ¯
 * GET /api/referral/referee?address=0x...
 */
async function handleGetReferee(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const address = url.searchParams.get("address");

  if (!address) {
    return errorResponse("Missing address parameter");
  }

  const referee = getRefereeInfo(address as Address);

  if (!referee) {
    return jsonResponse({
      isReferred: false,
      message: "Not referred by anyone. Use POST /api/referral/bind to bind a referral code.",
    });
  }

  return jsonResponse({
    isReferred: true,
    referee: {
      address: referee.address,
      referrer: referee.referrer,
      referralCode: referee.referrerCode,
      level2Referrer: referee.level2Referrer,
      totalFeesPaid: referee.totalFeesPaid.toString(),
      totalCommissionGenerated: referee.totalCommissionGenerated.toString(),
      joinedAt: referee.joinedAt,
      display: {
        totalFeesPaid: `$${(Number(referee.totalFeesPaid) / 1e6).toFixed(2)}`,
        totalCommissionGenerated: `$${(Number(referee.totalCommissionGenerated) / 1e6).toFixed(2)}`,
      },
    },
  });
}

/**
 * è·å–è¿”ä½£è®°å½•
 * GET /api/referral/commissions?address=0x...&limit=50
 */
async function handleGetCommissions(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const address = url.searchParams.get("address");
  const limit = parseInt(url.searchParams.get("limit") || "50");

  if (!address) {
    return errorResponse("Missing address parameter");
  }

  const commissions = getReferrerCommissions(address as Address, limit);

  return jsonResponse({
    count: commissions.length,
    commissions: commissions.map(c => ({
      id: c.id,
      referee: c.referee,
      level: c.level,
      tradeId: c.tradeId,
      tradeFee: c.tradeFee.toString(),
      commissionAmount: c.commissionAmount.toString(),
      commissionRate: c.commissionRate,
      timestamp: c.timestamp,
      status: c.status,
      display: {
        tradeFee: `$${(Number(c.tradeFee) / 1e6).toFixed(4)}`,
        commissionAmount: `$${(Number(c.commissionAmount) / 1e6).toFixed(4)}`,
        commissionRate: `${c.commissionRate / 100}%`,
      },
    })),
  });
}

/**
 * æå–è¿”ä½£
 * POST /api/referral/withdraw
 */
async function handleWithdrawCommission(req: Request): Promise<Response> {
  try {
    const body = await req.json();
    const { address, amount } = body;

    if (!address) {
      return errorResponse("Missing address");
    }

    const result = withdrawCommission(
      address as Address,
      amount ? BigInt(amount) : undefined
    );

    if (!result.success) {
      return errorResponse(result.error || "Failed to withdraw");
    }

    const referrer = getReferrerInfo(address as Address);

    return jsonResponse({
      success: true,
      withdrawnAmount: result.withdrawnAmount?.toString(),
      remainingPending: referrer?.pendingEarnings.toString(),
      display: {
        withdrawnAmount: `$${(Number(result.withdrawnAmount || 0n) / 1e6).toFixed(2)}`,
        remainingPending: referrer ? `$${(Number(referrer.pendingEarnings) / 1e6).toFixed(2)}` : "$0.00",
      },
    });
  } catch (e) {
    return errorResponse(e instanceof Error ? e.message : "Unknown error", 500);
  }
}

/**
 * è·å–æ¨èæ’è¡Œæ¦œ
 * GET /api/referral/leaderboard?limit=20
 */
async function handleGetReferralLeaderboard(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const limit = parseInt(url.searchParams.get("limit") || "20");

  const leaderboard = getReferralLeaderboard(limit);

  return jsonResponse({
    leaderboard: leaderboard.map((entry, index) => ({
      rank: index + 1,
      address: entry.address,
      code: entry.code,
      referralCount: entry.referralCount,
      totalEarnings: entry.totalEarnings.toString(),
      display: {
        totalEarnings: `$${(Number(entry.totalEarnings) / 1e6).toFixed(2)}`,
      },
    })),
  });
}

/**
 * è·å–å…¨å±€æ¨èç»Ÿè®¡
 * GET /api/referral/stats
 */
async function handleGetReferralStats(): Promise<Response> {
  const stats = getReferralStats();

  return jsonResponse({
    totalReferrers: stats.totalReferrers,
    totalReferees: stats.totalReferees,
    totalCommissionsPaid: stats.totalCommissionsPaid.toString(),
    totalCommissionsPending: stats.totalCommissionsPending.toString(),
    config: {
      level1Rate: REFERRAL_CONFIG.level1Rate,
      level2Rate: REFERRAL_CONFIG.level2Rate,
      minWithdrawAmount: REFERRAL_CONFIG.minWithdrawAmount.toString(),
    },
    display: {
      totalCommissionsPaid: `$${(Number(stats.totalCommissionsPaid) / 1e6).toFixed(2)}`,
      totalCommissionsPending: `$${(Number(stats.totalCommissionsPending) / 1e6).toFixed(2)}`,
      level1Rate: `${REFERRAL_CONFIG.level1Rate / 100}%`,
      level2Rate: `${REFERRAL_CONFIG.level2Rate / 100}%`,
      minWithdrawAmount: `$${Number(REFERRAL_CONFIG.minWithdrawAmount) / 1e6}`,
    },
  });
}

/**
 * é€šè¿‡é‚€è¯·ç æŸ¥è¯¢æ¨èäºº
 * GET /api/referral/code/:code
 */
async function handleGetReferrerByCode(code: string): Promise<Response> {
  const upperCode = code.toUpperCase();
  const referrerAddress = referralCodes.get(upperCode);

  if (!referrerAddress) {
    return jsonResponse({
      valid: false,
      message: "Invalid referral code",
    });
  }

  const referrer = getReferrerInfo(referrerAddress);

  return jsonResponse({
    valid: true,
    code: upperCode,
    referrer: referrer ? {
      address: referrer.address,
      referralCount: referrer.level1Referrals.length,
      createdAt: referrer.createdAt,
    } : null,
  });
}

// ============================================================
// Batch Submission Loop
// ============================================================

async function runBatchSubmissionLoop(): Promise<void> {
  if (!submitter) {
    console.log("[Batch] No submitter configured, skipping batch submission");
    return;
  }

  setInterval(async () => {
    const matches = engine.getPendingMatches();

    if (matches.length > 0) {
      console.log(`[Batch] Submitting ${matches.length} matches...`);
      const hash = await submitter!.submitBatch(matches);

      if (hash) {
        // Clear pending matches on success
        engine.clearPendingMatches();

        // Track submitted matches
        for (const match of matches) {
          const matchId = `${match.longOrder.id}_${match.shortOrder.id}`;
          submittedMatches.set(matchId, match);
        }
      }
    }
  }, BATCH_INTERVAL_MS);
}

// ============================================================
// Request Router
// ============================================================

async function handleRequest(req: Request): Promise<Response> {
  const url = new URL(req.url);
  const path = url.pathname;
  const method = req.method;

  // CORS preflight
  if (method === "OPTIONS") {
    return new Response(null, {
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type",
      },
    });
  }

  // Health check
  if (path === "/health") {
    return jsonResponse({ status: "ok", pendingMatches: engine.getPendingMatches().length });
  }

  // API routes
  if (path === "/api/order/submit" && method === "POST") {
    return handleOrderSubmit(req);
  }

  if (path.match(/^\/api\/user\/0x[a-fA-F0-9]+\/nonce$/) && method === "GET") {
    const trader = path.split("/")[3];
    return handleGetNonce(trader);
  }

  if (path.match(/^\/api\/orderbook\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetOrderBook(token);
  }

  if (path.match(/^\/api\/user\/0x[a-fA-F0-9]+\/orders$/) && method === "GET") {
    const trader = path.split("/")[3];
    return handleGetUserOrders(trader);
  }

  if (path.match(/^\/api\/order\/[^/]+\/cancel$/) && method === "POST") {
    const orderId = path.split("/")[3];
    return handleCancelOrder(req, orderId);
  }

  if (path.match(/^\/api\/user\/0x[a-fA-F0-9]+\/positions$/) && method === "GET") {
    const trader = path.split("/")[3];
    return handleGetUserPositions(trader);
  }

  // ä½™é¢ç›¸å…³ API
  if (path.match(/^\/api\/user\/0x[a-fA-F0-9]+\/balance$/) && method === "GET") {
    const trader = path.split("/")[3];
    return handleGetUserBalance(trader);
  }

  if (path.match(/^\/api\/user\/0x[a-fA-F0-9]+\/deposit$/) && method === "POST") {
    const trader = path.split("/")[3];
    return handleDeposit(req, trader);
  }

  if (path.match(/^\/api\/user\/0x[a-fA-F0-9]+\/withdraw$/) && method === "POST") {
    const trader = path.split("/")[3];
    return handleWithdraw(req, trader);
  }

  if (path.match(/^\/api\/position\/[^/]+\/close$/) && method === "POST") {
    const pairId = path.split("/")[3];
    return handleClosePair(req, pairId);
  }

  if (path === "/api/price/update" && method === "POST") {
    return handleUpdatePrice(req);
  }

  if (path.match(/^\/api\/trades\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetTrades(token, url);
  }

  if (path.match(/^\/api\/kline\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetKlines(token, url);
  }

  if (path.match(/^\/api\/stats\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetStats(token);
  }

  if (path.match(/^\/api\/funding\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetFundingRate(token);
  }

  // ============================================================
  // çŒæ€åœº API è·¯ç”±
  // ============================================================

  // æ¸…ç®—åœ°å›¾ï¼šæ˜¾ç¤ºå„ä»·æ ¼ç‚¹çš„æ¸…ç®—é‡åˆ†å¸ƒ
  if (path.match(/^\/api\/liquidation-map\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetLiquidationMap(token);
  }

  // å…¨å±€æŒä»“åˆ—è¡¨ï¼šå…¬å¼€æ‰€æœ‰ç”¨æˆ·æŒä»“
  if (path.match(/^\/api\/positions\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetAllPositions(token);
  }

  // æ¸…ç®—å†å²
  if (path.match(/^\/api\/liquidations\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetLiquidations(token, url);
  }

  // çŒæ€æ’è¡Œæ¦œ
  if (path === "/api/hunters" && method === "GET") {
    return handleGetHunterLeaderboard(url);
  }

  // ============================================================
  // ä¿é™©åŸºé‡‘ API (P1)
  // ============================================================

  // è·å–å…¨å±€ä¿é™©åŸºé‡‘çŠ¶æ€
  if (path === "/api/insurance-fund" && method === "GET") {
    return handleGetInsuranceFund();
  }

  // è·å–ä»£å¸ä¿é™©åŸºé‡‘çŠ¶æ€
  if (path.match(/^\/api\/insurance-fund\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetTokenInsuranceFund(token);
  }

  // ============================================================
  // Dynamic Funding API (P1)
  // ============================================================

  // è·å–åŠ¨æ€èµ„é‡‘è´¹ä¿¡æ¯
  if (path.match(/^\/api\/dynamic-funding\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetDynamicFunding(token);
  }

  // è·å–èµ„é‡‘è´¹æ”¯ä»˜å†å²
  if (path.match(/^\/api\/funding-history\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const token = path.split("/")[3];
    return handleGetFundingHistory(token, url);
  }

  // æ‰‹åŠ¨è§¦å‘èµ„é‡‘è´¹ç»“ç®— (ç®¡ç†å‘˜)
  if (path === "/api/funding/settle" && method === "POST") {
    return handleManualFundingSettlement(req);
  }

  // ============================================================
  // Take Profit / Stop Loss API (P2)
  // ============================================================

  // è®¾ç½®/æ›´æ–° TP/SL
  if (path.match(/^\/api\/position\/[^/]+\/tpsl$/) && method === "POST") {
    const pairId = path.split("/")[3];
    return handleSetTPSL(req, pairId);
  }

  // è·å– TP/SL çŠ¶æ€
  if (path.match(/^\/api\/position\/[^/]+\/tpsl$/) && method === "GET") {
    const pairId = path.split("/")[3];
    return handleGetTPSL(pairId);
  }

  // å–æ¶ˆ TP/SL
  if (path.match(/^\/api\/position\/[^/]+\/tpsl$/) && method === "DELETE") {
    const pairId = path.split("/")[3];
    return handleCancelTPSL(req, pairId);
  }

  // è·å–æ‰€æœ‰ TP/SL è®¢å•
  if (path === "/api/tpsl/orders" && method === "GET") {
    return handleGetAllTPSLOrders();
  }

  // ============================================================
  // Trailing Stop API (P2)
  // ============================================================

  // è®¾ç½® Trailing Stop
  if (path.match(/^\/api\/position\/[^/]+\/trailing-stop$/) && method === "POST") {
    const pairId = path.split("/")[3];
    return handleSetTrailingStop(req, pairId);
  }

  // è·å– Trailing Stop çŠ¶æ€
  if (path.match(/^\/api\/position\/[^/]+\/trailing-stop$/) && method === "GET") {
    const pairId = path.split("/")[3];
    return handleGetTrailingStop(pairId);
  }

  // å–æ¶ˆ Trailing Stop
  if (path.match(/^\/api\/position\/[^/]+\/trailing-stop$/) && method === "DELETE") {
    const pairId = path.split("/")[3];
    return handleCancelTrailingStop(pairId);
  }

  // è·å–æ‰€æœ‰ Trailing Stop è®¢å•
  if (path === "/api/trailing-stop/orders" && method === "GET") {
    return handleGetAllTrailingStopOrders();
  }

  // ============================================================
  // Reduce-Only API (P2)
  // ============================================================

  // è·å–ç”¨æˆ·å¯å¹³ä»“ä¿¡æ¯
  if (path.match(/^\/api\/user\/0x[a-fA-F0-9]+\/reduce-only\/0x[a-fA-F0-9]+$/) && method === "GET") {
    const trader = path.split("/")[3];
    const token = path.split("/")[5];
    return handleGetReduceOnlyInfo(trader, token);
  }

  // ============================================================
  // Add/Remove Margin API (P2)
  // ============================================================

  // è·å–ä¿è¯é‡‘è°ƒæ•´ä¿¡æ¯
  if (path.match(/^\/api\/position\/[^/]+\/margin$/) && method === "GET") {
    const pairId = path.split("/")[3];
    return handleGetMarginInfo(pairId);
  }

  // è¿½åŠ ä¿è¯é‡‘
  if (path.match(/^\/api\/position\/[^/]+\/margin\/add$/) && method === "POST") {
    const pairId = path.split("/")[3];
    return handleAddMargin(req, pairId);
  }

  // å‡å°‘ä¿è¯é‡‘
  if (path.match(/^\/api\/position\/[^/]+\/margin\/remove$/) && method === "POST") {
    const pairId = path.split("/")[3];
    return handleRemoveMargin(req, pairId);
  }

  // ============================================================
  // Conditional Orders API (P3)
  // ============================================================

  // åˆ›å»ºæ¡ä»¶å•
  if (path === "/api/conditional-order" && method === "POST") {
    return handleCreateConditionalOrder(req);
  }

  // å–æ¶ˆæ¡ä»¶å•
  if (path.match(/^\/api\/conditional-order\/[^/]+$/) && method === "DELETE") {
    const orderId = path.split("/")[3];
    return handleCancelConditionalOrder(req, orderId);
  }

  // è·å–ç”¨æˆ·æ¡ä»¶å•
  if (path === "/api/conditional-orders" && method === "GET") {
    return handleGetUserConditionalOrders(req);
  }

  // è·å–æ‰€æœ‰æ¡ä»¶å•
  if (path === "/api/conditional-orders/all" && method === "GET") {
    return handleGetAllConditionalOrders();
  }

  // ============================================================
  // OCO Orders API (P3)
  // ============================================================

  // åˆ›å»º OCO è®¢å•
  if (path === "/api/oco-order" && method === "POST") {
    return handleCreateOCOOrder(req);
  }

  // å–æ¶ˆ OCO è®¢å•
  if (path.match(/^\/api\/oco-order\/[^/]+$/) && method === "DELETE") {
    const ocoId = path.split("/")[3];
    return handleCancelOCOOrder(req, ocoId);
  }

  // è·å–ç”¨æˆ· OCO è®¢å•
  if (path === "/api/oco-orders" && method === "GET") {
    return handleGetUserOCOOrders(req);
  }

  // ============================================================
  // Bracket Orders API (P3)
  // ============================================================

  // åˆ›å»º Bracket è®¢å•
  if (path === "/api/bracket-order" && method === "POST") {
    return handleCreateBracketOrder(req);
  }

  // è·å–ç”¨æˆ· Bracket è®¢å•
  if (path === "/api/bracket-orders" && method === "GET") {
    return handleGetUserBracketOrders(req);
  }

  // è·å–æ‰€æœ‰ Bracket è®¢å•
  if (path === "/api/bracket-orders/all" && method === "GET") {
    return handleGetAllBracketOrders();
  }

  // ============================================================
  // Sub-accounts API (P4)
  // ============================================================

  // åˆ›å»ºå­è´¦æˆ·
  if (path === "/api/sub-account" && method === "POST") {
    return handleCreateSubAccount(req);
  }

  // è·å–å­è´¦æˆ·åˆ—è¡¨
  if (path === "/api/sub-accounts" && method === "GET") {
    return handleGetSubAccounts(req);
  }

  // è·å–å­è´¦æˆ·è¯¦æƒ…
  if (path.match(/^\/api\/sub-account\/[^/]+$/) && method === "GET") {
    const subAccountId = path.split("/")[3];
    return handleGetSubAccount(subAccountId);
  }

  // æ›´æ–°å­è´¦æˆ·è®¾ç½®
  if (path.match(/^\/api\/sub-account\/[^/]+$/) && method === "PUT") {
    const subAccountId = path.split("/")[3];
    return handleUpdateSubAccount(req, subAccountId);
  }

  // å…³é—­å­è´¦æˆ·
  if (path.match(/^\/api\/sub-account\/[^/]+$/) && method === "DELETE") {
    const subAccountId = path.split("/")[3];
    return handleCloseSubAccount(req, subAccountId);
  }

  // å­è´¦æˆ·è½¬è´¦
  if (path.match(/^\/api\/sub-account\/[^/]+\/transfer$/) && method === "POST") {
    const subAccountId = path.split("/")[3];
    return handleSubAccountTransfer(req, subAccountId);
  }

  // å†»ç»“/è§£å†»å­è´¦æˆ·
  if (path.match(/^\/api\/sub-account\/[^/]+\/freeze$/) && method === "POST") {
    const subAccountId = path.split("/")[3];
    return handleFreezeSubAccount(req, subAccountId);
  }

  // ============================================================
  // Cross-Margin Mode API (P4)
  // ============================================================

  // è·å–ä¿è¯é‡‘æ¨¡å¼
  if (path === "/api/margin-mode" && method === "GET") {
    return handleGetMarginMode(req);
  }

  // è®¾ç½®ä¿è¯é‡‘æ¨¡å¼
  if (path === "/api/margin-mode" && method === "POST") {
    return handleSetMarginMode(req);
  }

  // å…¨ä»“è´¦æˆ·å……å€¼
  if (path === "/api/cross-margin/deposit" && method === "POST") {
    return handleCrossMarginDeposit(req);
  }

  // å…¨ä»“è´¦æˆ·æç°
  if (path === "/api/cross-margin/withdraw" && method === "POST") {
    return handleCrossMarginWithdraw(req);
  }

  // ============================================================
  // Position Mode API (P4)
  // ============================================================

  // è·å–æŒä»“æ¨¡å¼
  if (path === "/api/position-mode" && method === "GET") {
    return handleGetPositionMode(req);
  }

  // è®¾ç½®æŒä»“æ¨¡å¼
  if (path === "/api/position-mode" && method === "POST") {
    return handleSetPositionMode(req);
  }

  // è·å–å‡€ä»“ä½ (å¯¹å†²æ¨¡å¼)
  if (path === "/api/net-position" && method === "GET") {
    return handleGetNetPosition(req);
  }

  // ============================================================
  // TWAP Orders API (P4)
  // ============================================================

  // åˆ›å»º TWAP è®¢å•
  if (path === "/api/twap-order" && method === "POST") {
    return handleCreateTWAPOrder(req);
  }

  // è·å– TWAP è®¢å•è¯¦æƒ…
  if (path.match(/^\/api\/twap-order\/[^/]+$/) && method === "GET") {
    const orderId = path.split("/")[3];
    return handleGetTWAPOrder(orderId);
  }

  // æ§åˆ¶ TWAP è®¢å• (start/pause/cancel)
  if (path.match(/^\/api\/twap-order\/[^/]+\/control$/) && method === "POST") {
    const orderId = path.split("/")[3];
    return handleTWAPOrderControl(req, orderId);
  }

  // è·å–ç”¨æˆ· TWAP è®¢å•
  if (path === "/api/twap-orders" && method === "GET") {
    return handleGetUserTWAPOrders(req);
  }

  // è·å–æ´»è·ƒ TWAP è®¢å•
  if (path === "/api/twap-orders/active" && method === "GET") {
    return handleGetActiveTWAPOrders();
  }

  // ============================================================
  // Referral System API (P5)
  // ============================================================

  // æ³¨å†Œæˆä¸ºæ¨èäºº
  if (path === "/api/referral/register" && method === "POST") {
    return handleRegisterReferrer(req);
  }

  // ç»‘å®šé‚€è¯·ç 
  if (path === "/api/referral/bind" && method === "POST") {
    return handleBindReferral(req);
  }

  // è·å–æ¨èäººä¿¡æ¯
  if (path === "/api/referral/referrer" && method === "GET") {
    return handleGetReferrer(req);
  }

  // è·å–è¢«é‚€è¯·äººä¿¡æ¯
  if (path === "/api/referral/referee" && method === "GET") {
    return handleGetReferee(req);
  }

  // è·å–è¿”ä½£è®°å½•
  if (path === "/api/referral/commissions" && method === "GET") {
    return handleGetCommissions(req);
  }

  // æå–è¿”ä½£
  if (path === "/api/referral/withdraw" && method === "POST") {
    return handleWithdrawCommission(req);
  }

  // è·å–æ¨èæ’è¡Œæ¦œ
  if (path === "/api/referral/leaderboard" && method === "GET") {
    return handleGetReferralLeaderboard(req);
  }

  // è·å–å…¨å±€æ¨èç»Ÿè®¡
  if (path === "/api/referral/stats" && method === "GET") {
    return handleGetReferralStats();
  }

  // é€šè¿‡é‚€è¯·ç æŸ¥è¯¢æ¨èäºº
  if (path.match(/^\/api\/referral\/code\/[A-Za-z0-9]+$/) && method === "GET") {
    const code = path.split("/")[4];
    return handleGetReferrerByCode(code);
  }

  // Not found
  return errorResponse("Not found", 404);
}

// ============================================================
// Security: Log Sanitization
// ============================================================

/**
 * Sanitizes log messages to prevent sensitive data leakage
 * Redacts: private keys (0x + 64 hex chars), API secrets, passwords
 */
function sanitizeLog(message: string): string {
  return message
    // Redact private keys (0x followed by 64 hex characters)
    .replace(/0x[0-9a-fA-F]{64}/g, '0x***PRIVATE_KEY_REDACTED***')
    // Redact any remaining long hex strings that might be sensitive
    .replace(/0x[0-9a-fA-F]{40,}/g, (match) => {
      // Keep addresses (40 chars) but redact longer ones
      if (match.length === 42) return match; // 0x + 40 chars = address
      return '0x***REDACTED***';
    });
}

/**
 * Safe console.log that sanitizes sensitive data
 */
function safeLog(message: string): void {
  console.log(sanitizeLog(message));
}

/**
 * Safe console.error that sanitizes sensitive data
 */
function safeError(message: string, error?: any): void {
  console.error(sanitizeLog(message), error);
}

// ============================================================
// WebSocket Handlers
// ============================================================

interface WSMessage {
  type: "subscribe" | "unsubscribe";
  channel: "orderbook" | "trades";
  token: Address;
}

function broadcastOrderBook(token: Address): void {
  if (!wss) return;

  const orderBook = engine.getOrderBook(token);
  const depth = orderBook.getDepth(20);
  const currentPrice = orderBook.getCurrentPrice();

  const message = JSON.stringify({
    type: "orderbook",
    token,
    data: {
      longs: depth.longs.map((level) => ({
        price: level.price.toString(),
        size: level.totalSize.toString(),
        count: level.orders.length,
      })),
      shorts: depth.shorts.map((level) => ({
        price: level.price.toString(),
        size: level.totalSize.toString(),
        count: level.orders.length,
      })),
      lastPrice: currentPrice.toString(),
    },
  });

  for (const [client, tokens] of wsClients) {
    if (client.readyState === WebSocket.OPEN && tokens.has(token)) {
      client.send(message);
    }
  }
}

function broadcastTrade(trade: Trade): void {
  if (!wss) return;

  const message = JSON.stringify({
    type: "trade",
    token: trade.token,
    data: {
      id: trade.id,
      price: trade.price.toString(),
      size: trade.size.toString(),
      side: trade.side,
      timestamp: trade.timestamp,
    },
  });

  for (const [client, tokens] of wsClients) {
    if (client.readyState === WebSocket.OPEN && tokens.has(trade.token)) {
      client.send(message);
    }
  }
}

function handleWSMessage(ws: WebSocket, message: string): void {
  try {
    const msg = JSON.parse(message) as WSMessage;

    if (msg.type === "subscribe" && msg.token) {
      const tokens = wsClients.get(ws) || new Set();
      tokens.add(msg.token.toLowerCase() as Address);
      wsClients.set(ws, tokens);

      // Send current orderbook immediately
      broadcastOrderBook(msg.token.toLowerCase() as Address);
      console.log(`[WS] Client subscribed to ${msg.token}`);
    } else if (msg.type === "unsubscribe" && msg.token) {
      const tokens = wsClients.get(ws);
      if (tokens) {
        tokens.delete(msg.token.toLowerCase() as Address);
      }
      console.log(`[WS] Client unsubscribed from ${msg.token}`);
    }
  } catch (e) {
    console.error("[WS] Invalid message:", e);
  }
}

// ============================================================
// Server Start
// ============================================================

function startServer(): void {
  // Initialize submitter if credentials are available
  if (MATCHER_PRIVATE_KEY && SETTLEMENT_ADDRESS) {
    submitter = new SettlementSubmitter(RPC_URL, MATCHER_PRIVATE_KEY, SETTLEMENT_ADDRESS);
    console.log(`[Server] Settlement submitter initialized for ${SETTLEMENT_ADDRESS}`);
  } else {
    console.log("[Server] No submitter configured (MATCHER_PRIVATE_KEY or SETTLEMENT_ADDRESS missing)");
  }

  // é…ç½®ä»·æ ¼æ•°æ®æºï¼ˆTokenFactory è·å–çœŸå®ç°è´§ä»·æ ¼ï¼‰
  engine.configurePriceSource(RPC_URL, TOKEN_FACTORY_ADDRESS, PRICE_FEED_ADDRESS);
  console.log(`[Server] TokenFactory: ${TOKEN_FACTORY_ADDRESS}`);
  console.log(`[Server] PriceFeed: ${PRICE_FEED_ADDRESS}`);

  // Start batch submission loop
  runBatchSubmissionLoop();

  // Start cleanup interval
  setInterval(() => {
    engine.cleanupExpired();
  }, 60000); // Clean up every minute

  // å®šæœŸä» PriceFeed åŒæ­¥ç°è´§ä»·æ ¼
  const syncSpotPrices = async () => {
    for (const token of SUPPORTED_TOKENS) {
      try {
        await engine.fetchSpotPrice(token);
      } catch (e) {
        console.error(`[Server] Failed to sync spot price for ${token}:`, e);
      }
    }
  };

  // åˆå§‹åŒæ­¥
  syncSpotPrices();

  // ä»é“¾ä¸ŠåŒæ­¥å·²æœ‰ä»“ä½ (è§£å†³ P003)
  syncPositionsFromChain().then(() => {
    console.log("[Server] Initial position sync completed");
  }).catch((e) => {
    console.error("[Server] Initial position sync failed:", e);
  });

  // å®šæ—¶åŒæ­¥ç°è´§ä»·æ ¼
  setInterval(syncSpotPrices, SPOT_PRICE_SYNC_INTERVAL_MS);
  console.log(`[Server] Spot price sync interval: ${SPOT_PRICE_SYNC_INTERVAL_MS}ms`);

  // å®šæ—¶åŒæ­¥é“¾ä¸Šä»“ä½ (æ¯5åˆ†é’ŸåŒæ­¥ä¸€æ¬¡ï¼Œä¿æŒæ•°æ®ä¸€è‡´)
  setInterval(() => {
    syncPositionsFromChain().catch((e) => {
      console.error("[Server] Periodic position sync failed:", e);
    });
  }, 300000); // 5 minutes
  console.log("[Server] Position sync interval: 300000ms (5 minutes)");

  // ========================================
  // å¯åŠ¨é“¾ä¸Šäº‹ä»¶ç›‘å¬ (å®æ—¶åŒæ­¥é“¾ä¸ŠçŠ¶æ€)
  // ========================================
  startEventWatching().catch((e) => {
    console.error("[Events] Failed to start event watching:", e);
  });

  // ========================================
  // å¯åŠ¨ 100ms Risk Engine (Meme Perp æ ¸å¿ƒ)
  // ========================================
  startRiskEngine();
  console.log(`[Server] Risk Engine started: ${RISK_ENGINE_INTERVAL_MS}ms interval`);

  // ========================================
  // å¯åŠ¨ Dynamic Funding Engine (P1)
  // ========================================
  startDynamicFundingEngine();
  console.log(`[Server] Dynamic Funding Engine started: ${DYNAMIC_FUNDING_CHECK_INTERVAL}ms check interval`);

  // å®šæœŸè®¡ç®—èµ„é‡‘è´¹ç‡ï¼ˆåŸºäºç°è´§ä»·æ ¼é”šå®šï¼‰
  setInterval(() => {
    for (const token of SUPPORTED_TOKENS) {
      const rate = engine.calculateFundingRate(token);

      // å¦‚æœæœ‰é“¾ä¸Šæäº¤å™¨ï¼Œæ›´æ–°é“¾ä¸Šèµ„é‡‘è´¹ç‡
      if (submitter && rate !== 0n) {
        submitter.updateFundingRate(token, rate).catch((e) => {
          console.error(`[Server] Failed to update on-chain funding rate:`, e);
        });
      }
    }
  }, FUNDING_RATE_INTERVAL_MS);
  console.log(`[Server] Funding rate interval: ${FUNDING_RATE_INTERVAL_MS}ms`);

  // Start HTTP server (Node.js compatible)
  import("http").then((http) => {
    const server = http.createServer(async (req, res) => {
      // Set CORS headers for all responses
      res.setHeader("Access-Control-Allow-Origin", "*");
      res.setHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
      res.setHeader("Access-Control-Allow-Headers", "Content-Type");

      // Handle CORS preflight
      if (req.method === "OPTIONS") {
        res.statusCode = 204;
        res.end();
        return;
      }

      try {
        const url = `http://${req.headers.host}${req.url}`;

        // Read body if present
        let bodyStr = "";
        if (req.method !== "GET" && req.method !== "HEAD") {
          const chunks: Buffer[] = [];
          for await (const chunk of req) {
            chunks.push(chunk);
          }
          bodyStr = Buffer.concat(chunks).toString();
        }

        // Create Request with body included
        const request = new Request(url, {
          method: req.method,
          headers: req.headers as HeadersInit,
          body: bodyStr || undefined,
        });

        const response = await handleRequest(request);

        // Set response headers
        response.headers.forEach((value, key) => {
          res.setHeader(key, value);
        });

        res.statusCode = response.status;

        // Send response body
        const text = await response.text();
        res.end(text);
      } catch (error) {
        console.error("[Server] Request error:", error);
        res.statusCode = 500;
        res.setHeader("Content-Type", "application/json");
        res.end(JSON.stringify({ error: "Internal server error" }));
      }
    });

    server.listen(PORT, () => {
      console.log(`[Server] Matching engine API running on http://localhost:${PORT}`);
      console.log(`[Server] Batch interval: ${BATCH_INTERVAL_MS}ms`);

      // Start WebSocket server on same port
      wss = new WebSocketServer({ server });
      console.log(`[Server] WebSocket server running on ws://localhost:${PORT}`);

      wss.on("connection", (ws) => {
        console.log("[WS] Client connected");
        wsClients.set(ws, new Set());

        ws.on("message", (data) => {
          handleWSMessage(ws, data.toString());
        });

        ws.on("close", () => {
          wsClients.delete(ws);
          console.log("[WS] Client disconnected");
        });

        ws.on("error", (err) => {
          console.error("[WS] Error:", err);
          wsClients.delete(ws);
        });
      });
    });
  });
}

// Start if running directly
if (import.meta.main) {
  startServer();
}

export { startServer, engine, submitter };
